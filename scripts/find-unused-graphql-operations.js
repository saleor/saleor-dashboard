#!/usr/bin/env node

/* eslint-disable */

/**
 * Script to find unused GraphQL operations in the Saleor Dashboard codebase
 *
 * This script:
 * 1. Scans all GraphQL operation files (queries.ts, mutations.ts, fragments/*.ts)
 * 2. Extracts operation names (queries, mutations, fragments)
 * 3. Determines what hooks/documents/types are generated by graphql-codegen
 * 4. Searches the codebase for usage of these generated artifacts
 * 5. Reports operations that are never used
 *
 * warning: This is generated by Claude, have limited trust
 */

const fs = require("fs");
const path = require("path");

// Configuration
const SRC_DIR = path.join(__dirname, "..", "src");
const ROOT_DIR = path.join(__dirname, "..");
const GENERATED_FILES = [
  path.join(SRC_DIR, "graphql/hooks.generated.ts"),
  path.join(SRC_DIR, "graphql/types.generated.ts"),
  path.join(SRC_DIR, "graphql/typePolicies.generated.ts"),
  path.join(SRC_DIR, "graphql/fragmentTypes.generated.ts"),
];

// Find all TypeScript files to search
function getAllTypeScriptFiles(dir, fileList = [], excludePaths = []) {
  const entries = fs.readdirSync(dir, { withFileTypes: true });

  for (const entry of entries) {
    const fullPath = path.join(dir, entry.name);

    // Skip excluded paths
    if (excludePaths.some(excluded => fullPath === excluded)) {
      continue;
    }

    if (entry.isDirectory()) {
      if (entry.name !== "node_modules" && !entry.name.startsWith(".")) {
        getAllTypeScriptFiles(fullPath, fileList, excludePaths);
      }
    } else if (entry.isFile() && (entry.name.endsWith(".ts") || entry.name.endsWith(".tsx"))) {
      fileList.push(fullPath);
    }
  }

  return fileList;
}

// Find all GraphQL operation files
function findGraphQLFiles() {
  const files = {
    queries: [],
    mutations: [],
    fragments: [],
  };

  function walkDir(dir, type) {
    try {
      const entries = fs.readdirSync(dir, { withFileTypes: true });

      for (const entry of entries) {
        const fullPath = path.join(dir, entry.name);

        if (entry.isDirectory() && entry.name !== "node_modules" && !entry.name.startsWith(".")) {
          walkDir(fullPath, type);
        } else if (entry.isFile() && entry.name === `${type}.ts`) {
          files[type].push(fullPath);
        }
      }
    } catch (error) {
      // Skip directories we can't read
    }
  }

  // Find queries and mutations
  walkDir(SRC_DIR, "queries");
  walkDir(SRC_DIR, "mutations");

  // Find fragments (in fragments subdirectories)
  const fragmentsDir = path.join(SRC_DIR, "fragments");
  if (fs.existsSync(fragmentsDir)) {
    const fragmentFiles = fs
      .readdirSync(fragmentsDir)
      .filter(f => f.endsWith(".ts"))
      .map(f => path.join(fragmentsDir, f));
    files.fragments = fragmentFiles;
  }

  return files;
}

// Extract operation names from a GraphQL file
function extractOperations(filePath, operationType) {
  const content = fs.readFileSync(filePath, "utf8");
  const operations = [];

  if (operationType === "fragments") {
    // Match fragment definitions: export const fragmentName = gql`fragment FragmentName on Type`
    const fragmentRegex = /export\s+const\s+(\w+)\s+=\s+gql`[^`]*fragment\s+(\w+)\s+on/g;
    let match;
    while ((match = fragmentRegex.exec(content)) !== null) {
      const exportName = match[1];
      const fragmentName = match[2];
      operations.push({
        type: "fragment",
        exportName,
        operationName: fragmentName,
        filePath,
      });
    }
  } else if (operationType === "queries") {
    // Match query definitions: export const queryName = gql`query QueryName(...)`
    const queryRegex = /export\s+const\s+(\w+)\s+=\s+gql`[^`]*query\s+(\w+)\s*(?:\(|{)/g;
    let match;
    while ((match = queryRegex.exec(content)) !== null) {
      const exportName = match[1];
      const queryName = match[2];
      operations.push({
        type: "query",
        exportName,
        operationName: queryName,
        filePath,
      });
    }
  } else if (operationType === "mutations") {
    // Match mutation definitions: export const mutationName = gql`mutation MutationName(...)`
    const mutationRegex = /export\s+const\s+(\w+)\s+=\s+gql`[^`]*mutation\s+(\w+)\s*(?:\(|{)/g;
    let match;
    while ((match = mutationRegex.exec(content)) !== null) {
      const exportName = match[1];
      const mutationName = match[2];
      operations.push({
        type: "mutation",
        exportName,
        operationName: mutationName,
        filePath,
      });
    }
  }

  return operations;
}

// Generate all possible generated names from an operation
function getGeneratedNames(operation) {
  const { operationName, type } = operation;
  const names = [];

  if (type === "fragment") {
    // Fragments generate:
    // - FragmentNameFragmentDoc
    // - FragmentNameFragment (type)
    names.push(`${operationName}FragmentDoc`);
    names.push(`${operationName}Fragment`);
  } else if (type === "query") {
    // Queries generate:
    // - QueryNameDocument
    // - useQueryNameQuery
    // - useQueryNameLazyQuery
    // - QueryNameQuery (type)
    // - QueryNameQueryVariables (type)
    names.push(`${operationName}Document`);
    names.push(`use${operationName}Query`);
    names.push(`use${operationName}LazyQuery`);
    names.push(`${operationName}Query`);
    names.push(`${operationName}QueryVariables`);
  } else if (type === "mutation") {
    // Mutations generate:
    // - MutationNameDocument
    // - useMutationNameMutation
    // - MutationNameMutation (type)
    // - MutationNameMutationVariables (type)
    names.push(`${operationName}Document`);
    names.push(`use${operationName}Mutation`);
    names.push(`${operationName}Mutation`);
    names.push(`${operationName}MutationVariables`);
  }

  return names;
}

// Main function
function main() {
  console.log("üîç Finding unused GraphQL operations...\n");
  console.log("üìÅ Scanning GraphQL files...");

  const graphqlFiles = findGraphQLFiles();
  console.log(`   Found ${graphqlFiles.queries.length} query files`);
  console.log(`   Found ${graphqlFiles.mutations.length} mutation files`);
  console.log(`   Found ${graphqlFiles.fragments.length} fragment files\n`);

  // Extract all operations
  const allOperations = [];
  const operationFiles = new Set();

  for (const file of graphqlFiles.queries) {
    operationFiles.add(file);
    const operations = extractOperations(file, "queries");
    allOperations.push(...operations);
  }

  for (const file of graphqlFiles.mutations) {
    operationFiles.add(file);
    const operations = extractOperations(file, "mutations");
    allOperations.push(...operations);
  }

  for (const file of graphqlFiles.fragments) {
    operationFiles.add(file);
    const operations = extractOperations(file, "fragments");
    allOperations.push(...operations);
  }

  console.log(`üìä Found ${allOperations.length} total operations:`);
  const queriesCount = allOperations.filter(op => op.type === "query").length;
  const mutationsCount = allOperations.filter(op => op.type === "mutation").length;
  const fragmentsCount = allOperations.filter(op => op.type === "fragment").length;
  console.log(`   ${queriesCount} queries`);
  console.log(`   ${mutationsCount} mutations`);
  console.log(`   ${fragmentsCount} fragments\n`);

  console.log("üìÑ Loading TypeScript files...");

  // Get all TS files excluding generated files and operation definition files
  const excludeFiles = [...GENERATED_FILES, ...Array.from(operationFiles)];
  const tsFiles = getAllTypeScriptFiles(SRC_DIR, [], excludeFiles);
  console.log(`   Found ${tsFiles.length} files to search\n`);

  console.log("üîé Reading files and checking for usage...\n");

  // Build a map of all names we're looking for to their operations
  const nameToOperation = new Map();
  for (const operation of allOperations) {
    const generatedNames = getGeneratedNames(operation);
    for (const name of generatedNames) {
      if (!nameToOperation.has(name)) {
        nameToOperation.set(name, []);
      }
      nameToOperation.set(name, operation);
    }
  }

  // Read all files and check for usage
  const usedOperations = new Set();
  let filesProcessed = 0;

  for (const filePath of tsFiles) {
    filesProcessed++;
    if (filesProcessed % 100 === 0) {
      process.stdout.write(`   Processed ${filesProcessed}/${tsFiles.length} files...\r`);
    }

    try {
      const content = fs.readFileSync(filePath, "utf8");

      // Check all names in this file
      for (const [name, operation] of nameToOperation) {
        // Use word boundary regex for more accurate matching
        const regex = new RegExp(`\\b${name}\\b`);
        if (regex.test(content)) {
          usedOperations.add(operation);
        }
      }
    } catch (error) {
      // Skip files we can't read
    }
  }

  console.log(`   Processed ${tsFiles.length}/${tsFiles.length} files.   \n`);

  // Find unused operations
  const unusedOperations = allOperations.filter(op => !usedOperations.has(op));

  // Report results
  console.log("‚ïê".repeat(80));
  console.log(`üìà SUMMARY`);
  console.log("‚ïê".repeat(80));
  console.log(`Total operations: ${allOperations.length}`);
  console.log(`Used operations: ${usedOperations.size}`);
  console.log(`Unused operations: ${unusedOperations.length}`);
  console.log("‚ïê".repeat(80));
  console.log();

  if (unusedOperations.length === 0) {
    console.log("‚úÖ No unused operations found! All GraphQL operations are being used.\n");
    return;
  }

  // Group unused operations by type
  const unusedByType = {
    query: unusedOperations.filter(op => op.type === "query"),
    mutation: unusedOperations.filter(op => op.type === "mutation"),
    fragment: unusedOperations.filter(op => op.type === "fragment"),
  };

  // Report unused operations
  if (unusedByType.query.length > 0) {
    console.log("üî¥ UNUSED QUERIES:\n");
    for (const op of unusedByType.query) {
      const relativePath = path.relative(ROOT_DIR, op.filePath);
      console.log(`   ‚Ä¢ ${op.operationName}`);
      console.log(`     Export: ${op.exportName}`);
      console.log(`     File: ${relativePath}`);
      console.log();
    }
  }

  if (unusedByType.mutation.length > 0) {
    console.log("üî¥ UNUSED MUTATIONS:\n");
    for (const op of unusedByType.mutation) {
      const relativePath = path.relative(ROOT_DIR, op.filePath);
      console.log(`   ‚Ä¢ ${op.operationName}`);
      console.log(`     Export: ${op.exportName}`);
      console.log(`     File: ${relativePath}`);
      console.log();
    }
  }

  if (unusedByType.fragment.length > 0) {
    console.log("üî¥ UNUSED FRAGMENTS:\n");
    for (const op of unusedByType.fragment) {
      const relativePath = path.relative(ROOT_DIR, op.filePath);
      console.log(`   ‚Ä¢ ${op.operationName}`);
      console.log(`     Export: ${op.exportName}`);
      console.log(`     File: ${relativePath}`);
      console.log();
    }
  }

  console.log("‚ïê".repeat(80));
  console.log("üí° TIP: Review these operations and remove them if they are truly unused.");
  console.log("   Some operations might be used dynamically or in ways not detected by");
  console.log("   this script, so please verify before removing.");
  console.log("‚ïê".repeat(80));
}

// Run the script
main();
