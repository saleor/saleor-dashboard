export type Maybe<T> = T | null;
export type InputMaybe<T> = Maybe<T>;
export type Exact<T extends { [key: string]: unknown }> = { [K in keyof T]: T[K] };
export type MakeOptional<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]?: Maybe<T[SubKey]> };
export type MakeMaybe<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]: Maybe<T[SubKey]> };
/** All built-in and custom scalars, mapped to their actual values */
export type Scalars = {
  ID: string;
  String: string;
  Boolean: boolean;
  Int: number;
  Float: number;
  /**
   * The `Date` scalar type represents a Date
   * value as specified by
   * [iso8601](https://en.wikipedia.org/wiki/ISO_8601).
   */
  Date: string;
  /**
   * The `DateTime` scalar type represents a DateTime
   * value as specified by
   * [iso8601](https://en.wikipedia.org/wiki/ISO_8601).
   */
  DateTime: any;
  /** The `Day` scalar type represents number of days by integer value. */
  Day: number;
  /**
   * Custom Decimal implementation.
   *
   * Returns Decimal as a float in the API,
   * parses float to the Decimal on the way back.
   */
  Decimal: any;
  /**
   * The `GenericScalar` scalar type represents a generic
   * GraphQL scalar value that could be:
   * String, Boolean, Int, Float, List or Object.
   */
  GenericScalar: any;
  /** The `Hour` scalar type represents number of hours by integer value. */
  Hour: number;
  JSON: any;
  JSONString: any;
  /**
   * Metadata is a map of key-value pairs, both keys and values are `String`.
   *
   * Example:
   * ```
   * {
   *     "key1": "value1",
   *     "key2": "value2"
   * }
   * ```
   */
  Metadata: any;
  /** The `Minute` scalar type represents number of minutes by integer value. */
  Minute: any;
  /**
   * Nonnegative Decimal scalar implementation.
   *
   * Should be used in places where value must be nonnegative (0 or greater).
   */
  PositiveDecimal: any;
  /**
   * Positive Integer scalar implementation.
   *
   * Should be used in places where value must be positive (greater than 0).
   */
  PositiveInt: any;
  UUID: any;
  /** Variables of this type must be set to null in mutations. They will be replaced with a filename from a following multipart part containing a binary file. See: https://github.com/jaydenseric/graphql-multipart-request-spec. */
  Upload: any;
  WeightScalar: any;
  /** _Any value scalar as defined by Federation spec. */
  _Any: any;
};

/**
 * Create a new address for the customer.
 *
 * Requires one of following set of permissions: AUTHENTICATED_USER or AUTHENTICATED_APP + IMPERSONATE_USER.
 *
 * Triggers the following webhook events:
 * - CUSTOMER_UPDATED (async): A customer account was updated.
 * - ADDRESS_CREATED (async): An address was created.
 */
export type AccountAddressCreate = {
  __typename: 'AccountAddressCreate';
  /** @deprecated Use `errors` field instead. */
  accountErrors: Array<AccountError>;
  address: Maybe<Address>;
  errors: Array<AccountError>;
  /** A user instance for which the address was created. */
  user: Maybe<User>;
};

/**
 * Deletes an address of the logged-in user. Requires one of the following permissions: MANAGE_USERS, IS_OWNER.
 *
 * Triggers the following webhook events:
 * - ADDRESS_DELETED (async): An address was deleted.
 */
export type AccountAddressDelete = {
  __typename: 'AccountAddressDelete';
  /** @deprecated Use `errors` field instead. */
  accountErrors: Array<AccountError>;
  address: Maybe<Address>;
  errors: Array<AccountError>;
  /** A user instance for which the address was deleted. */
  user: Maybe<User>;
};

/**
 * Updates an address of the logged-in user. Requires one of the following permissions: MANAGE_USERS, IS_OWNER.
 *
 * Triggers the following webhook events:
 * - ADDRESS_UPDATED (async): An address was updated.
 */
export type AccountAddressUpdate = {
  __typename: 'AccountAddressUpdate';
  /** @deprecated Use `errors` field instead. */
  accountErrors: Array<AccountError>;
  address: Maybe<Address>;
  errors: Array<AccountError>;
  /** A user object for which the address was edited. */
  user: Maybe<User>;
};

/** Event sent when account change email is requested. */
export type AccountChangeEmailRequested = Event & {
  __typename: 'AccountChangeEmailRequested';
  /** The channel data. */
  channel: Maybe<Channel>;
  /** Time of the event. */
  issuedAt: Maybe<Scalars['DateTime']>;
  /** The user or application that triggered the event. */
  issuingPrincipal: Maybe<IssuingPrincipal>;
  /** The new email address the user wants to change to. */
  newEmail: Maybe<Scalars['String']>;
  /** The application receiving the webhook. */
  recipient: Maybe<App>;
  /** The URL to redirect the user after he accepts the request. */
  redirectUrl: Maybe<Scalars['String']>;
  /** Shop data. */
  shop: Maybe<Shop>;
  /** The token required to confirm request. */
  token: Maybe<Scalars['String']>;
  /** The user the event relates to. */
  user: Maybe<User>;
  /** Saleor version that triggered the event. */
  version: Maybe<Scalars['String']>;
};

/** Event sent when account confirmation requested. This event is always sent. enableAccountConfirmationByEmail flag set to True is not required. */
export type AccountConfirmationRequested = Event & {
  __typename: 'AccountConfirmationRequested';
  /** The channel data. */
  channel: Maybe<Channel>;
  /** Time of the event. */
  issuedAt: Maybe<Scalars['DateTime']>;
  /** The user or application that triggered the event. */
  issuingPrincipal: Maybe<IssuingPrincipal>;
  /** The application receiving the webhook. */
  recipient: Maybe<App>;
  /** The URL to redirect the user after he accepts the request. */
  redirectUrl: Maybe<Scalars['String']>;
  /** Shop data. */
  shop: Maybe<Shop>;
  /** The token required to confirm request. */
  token: Maybe<Scalars['String']>;
  /** The user the event relates to. */
  user: Maybe<User>;
  /** Saleor version that triggered the event. */
  version: Maybe<Scalars['String']>;
};

/** Event sent when account is confirmed. */
export type AccountConfirmed = Event & {
  __typename: 'AccountConfirmed';
  /** The channel data. */
  channel: Maybe<Channel>;
  /** Time of the event. */
  issuedAt: Maybe<Scalars['DateTime']>;
  /** The user or application that triggered the event. */
  issuingPrincipal: Maybe<IssuingPrincipal>;
  /** The application receiving the webhook. */
  recipient: Maybe<App>;
  /** The URL to redirect the user after he accepts the request. */
  redirectUrl: Maybe<Scalars['String']>;
  /** Shop data. */
  shop: Maybe<Shop>;
  /** The token required to confirm request. */
  token: Maybe<Scalars['String']>;
  /** The user the event relates to. */
  user: Maybe<User>;
  /** Saleor version that triggered the event. */
  version: Maybe<Scalars['String']>;
};

/**
 * Remove user account.
 *
 * Requires one of the following permissions: AUTHENTICATED_USER.
 *
 * Triggers the following webhook events:
 * - ACCOUNT_DELETED (async): Account was deleted.
 */
export type AccountDelete = {
  __typename: 'AccountDelete';
  /** @deprecated Use `errors` field instead. */
  accountErrors: Array<AccountError>;
  errors: Array<AccountError>;
  user: Maybe<User>;
};

/** Event sent when account delete is requested. */
export type AccountDeleteRequested = Event & {
  __typename: 'AccountDeleteRequested';
  /** The channel data. */
  channel: Maybe<Channel>;
  /** Time of the event. */
  issuedAt: Maybe<Scalars['DateTime']>;
  /** The user or application that triggered the event. */
  issuingPrincipal: Maybe<IssuingPrincipal>;
  /** The application receiving the webhook. */
  recipient: Maybe<App>;
  /** The URL to redirect the user after he accepts the request. */
  redirectUrl: Maybe<Scalars['String']>;
  /** Shop data. */
  shop: Maybe<Shop>;
  /** The token required to confirm request. */
  token: Maybe<Scalars['String']>;
  /** The user the event relates to. */
  user: Maybe<User>;
  /** Saleor version that triggered the event. */
  version: Maybe<Scalars['String']>;
};

/** Event sent when account is deleted. */
export type AccountDeleted = Event & {
  __typename: 'AccountDeleted';
  /** The channel data. */
  channel: Maybe<Channel>;
  /** Time of the event. */
  issuedAt: Maybe<Scalars['DateTime']>;
  /** The user or application that triggered the event. */
  issuingPrincipal: Maybe<IssuingPrincipal>;
  /** The application receiving the webhook. */
  recipient: Maybe<App>;
  /** The URL to redirect the user after he accepts the request. */
  redirectUrl: Maybe<Scalars['String']>;
  /** Shop data. */
  shop: Maybe<Shop>;
  /** The token required to confirm request. */
  token: Maybe<Scalars['String']>;
  /** The user the event relates to. */
  user: Maybe<User>;
  /** Saleor version that triggered the event. */
  version: Maybe<Scalars['String']>;
};

/** Event sent when account email is changed. */
export type AccountEmailChanged = Event & {
  __typename: 'AccountEmailChanged';
  /** The channel data. */
  channel: Maybe<Channel>;
  /** Time of the event. */
  issuedAt: Maybe<Scalars['DateTime']>;
  /** The user or application that triggered the event. */
  issuingPrincipal: Maybe<IssuingPrincipal>;
  /** The new email address. */
  newEmail: Maybe<Scalars['String']>;
  /** The application receiving the webhook. */
  recipient: Maybe<App>;
  /** The URL to redirect the user after he accepts the request. */
  redirectUrl: Maybe<Scalars['String']>;
  /** Shop data. */
  shop: Maybe<Shop>;
  /** The token required to confirm request. */
  token: Maybe<Scalars['String']>;
  /** The user the event relates to. */
  user: Maybe<User>;
  /** Saleor version that triggered the event. */
  version: Maybe<Scalars['String']>;
};

/** Represents errors in account mutations. */
export type AccountError = {
  __typename: 'AccountError';
  /** A type of address that causes the error. */
  addressType: Maybe<AddressTypeEnum>;
  /** The error code. */
  code: AccountErrorCode;
  /** Name of a field that caused the error. A value of `null` indicates that the error isn't associated with a particular field. */
  field: Maybe<Scalars['String']>;
  /** The error message. */
  message: Maybe<Scalars['String']>;
};

export type AccountErrorCode =
  | 'ACCOUNT_NOT_CONFIRMED'
  | 'ACTIVATE_OWN_ACCOUNT'
  | 'ACTIVATE_SUPERUSER_ACCOUNT'
  | 'CHANNEL_INACTIVE'
  | 'DEACTIVATE_OWN_ACCOUNT'
  | 'DEACTIVATE_SUPERUSER_ACCOUNT'
  | 'DELETE_NON_STAFF_USER'
  | 'DELETE_OWN_ACCOUNT'
  | 'DELETE_STAFF_ACCOUNT'
  | 'DELETE_SUPERUSER_ACCOUNT'
  | 'DUPLICATED_INPUT_ITEM'
  | 'GRAPHQL_ERROR'
  | 'INACTIVE'
  | 'INVALID'
  | 'INVALID_CREDENTIALS'
  | 'INVALID_PASSWORD'
  | 'JWT_DECODE_ERROR'
  | 'JWT_INVALID_CSRF_TOKEN'
  | 'JWT_INVALID_TOKEN'
  | 'JWT_MISSING_TOKEN'
  | 'JWT_SIGNATURE_EXPIRED'
  | 'LEFT_NOT_MANAGEABLE_PERMISSION'
  | 'LOGIN_ATTEMPT_DELAYED'
  | 'MISSING_CHANNEL_SLUG'
  | 'NOT_FOUND'
  | 'OUT_OF_SCOPE_GROUP'
  | 'OUT_OF_SCOPE_PERMISSION'
  | 'OUT_OF_SCOPE_USER'
  | 'PASSWORD_ENTIRELY_NUMERIC'
  | 'PASSWORD_RESET_ALREADY_REQUESTED'
  | 'PASSWORD_TOO_COMMON'
  | 'PASSWORD_TOO_SHORT'
  | 'PASSWORD_TOO_SIMILAR'
  | 'REQUIRED'
  | 'UNIQUE'
  | 'UNKNOWN_IP_ADDRESS';

/** Fields required to update the user. */
export type AccountInput = {
  /** Billing address of the customer. */
  defaultBillingAddress: InputMaybe<AddressInput>;
  /** Shipping address of the customer. */
  defaultShippingAddress: InputMaybe<AddressInput>;
  /** Given name. */
  firstName: InputMaybe<Scalars['String']>;
  /** User language code. */
  languageCode: InputMaybe<LanguageCodeEnum>;
  /** Family name. */
  lastName: InputMaybe<Scalars['String']>;
  /**
   * Fields required to update the user metadata. Can be read by any API client authorized to read the object it's attached to.
   *
   * Warning: never store sensitive information, including financial data such as credit card details.
   */
  metadata: InputMaybe<Array<MetadataInput>>;
};

/**
 * Register a new user.
 *
 * Triggers the following webhook events:
 * - CUSTOMER_CREATED (async): A new customer account was created.
 * - NOTIFY_USER (async): A notification for account confirmation.
 * - ACCOUNT_CONFIRMATION_REQUESTED (async): An user confirmation was requested. This event is always sent regardless of settings.
 */
export type AccountRegister = {
  __typename: 'AccountRegister';
  /** @deprecated Use `errors` field instead. */
  accountErrors: Array<AccountError>;
  errors: Array<AccountError>;
  /** Informs whether users need to confirm their email address. */
  requiresConfirmation: Maybe<Scalars['Boolean']>;
  /** @deprecated The field always returns a `User` object constructed from the input data. The `user.id` is always empty. To determine whether the user exists in Saleor, query via an external app with the required permissions. */
  user: Maybe<User>;
};

/** Fields required to create a user. */
export type AccountRegisterInput = {
  /** Slug of a channel which will be used to notify users. Optional when only one channel exists. */
  channel: InputMaybe<Scalars['String']>;
  /** The email address of the user. */
  email: Scalars['String'];
  /** Given name. */
  firstName: InputMaybe<Scalars['String']>;
  /** User language code. */
  languageCode: InputMaybe<LanguageCodeEnum>;
  /** Family name. */
  lastName: InputMaybe<Scalars['String']>;
  /**
   * User public metadata. Can be read by any API client authorized to read the object it's attached to.
   *
   * Warning: never store sensitive information, including financial data such as credit card details.
   */
  metadata: InputMaybe<Array<MetadataInput>>;
  /** Password. */
  password: Scalars['String'];
  /** Base of frontend URL that will be needed to create confirmation URL. Required when account confirmation is enabled. */
  redirectUrl: InputMaybe<Scalars['String']>;
};

/**
 * Sends an email with the account removal link for the logged-in user.
 *
 * Requires one of the following permissions: AUTHENTICATED_USER.
 *
 * Triggers the following webhook events:
 * - NOTIFY_USER (async): A notification for account delete request.
 * - ACCOUNT_DELETE_REQUESTED (async): An account delete requested.
 */
export type AccountRequestDeletion = {
  __typename: 'AccountRequestDeletion';
  /** @deprecated Use `errors` field instead. */
  accountErrors: Array<AccountError>;
  errors: Array<AccountError>;
};

/**
 * Sets a default address for the authenticated user.
 *
 * Requires one of the following permissions: AUTHENTICATED_USER.
 *
 * Triggers the following webhook events:
 * - CUSTOMER_UPDATED (async): A customer's address was updated.
 */
export type AccountSetDefaultAddress = {
  __typename: 'AccountSetDefaultAddress';
  /** @deprecated Use `errors` field instead. */
  accountErrors: Array<AccountError>;
  errors: Array<AccountError>;
  /** An updated user instance. */
  user: Maybe<User>;
};

/** Event sent when setting a new password is requested. */
export type AccountSetPasswordRequested = Event & {
  __typename: 'AccountSetPasswordRequested';
  /** The channel data. */
  channel: Maybe<Channel>;
  /** Time of the event. */
  issuedAt: Maybe<Scalars['DateTime']>;
  /** The user or application that triggered the event. */
  issuingPrincipal: Maybe<IssuingPrincipal>;
  /** The application receiving the webhook. */
  recipient: Maybe<App>;
  /** The URL to redirect the user after he accepts the request. */
  redirectUrl: Maybe<Scalars['String']>;
  /** Shop data. */
  shop: Maybe<Shop>;
  /** The token required to confirm request. */
  token: Maybe<Scalars['String']>;
  /** The user the event relates to. */
  user: Maybe<User>;
  /** Saleor version that triggered the event. */
  version: Maybe<Scalars['String']>;
};

/**
 * Updates the account of the logged-in user.
 *
 * Requires one of following set of permissions: AUTHENTICATED_USER or AUTHENTICATED_APP + IMPERSONATE_USER.
 *
 * Triggers the following webhook events:
 * - CUSTOMER_UPDATED (async): A customer account was updated.
 * - CUSTOMER_METADATA_UPDATED (async): Optionally called when customer's metadata was updated.
 */
export type AccountUpdate = {
  __typename: 'AccountUpdate';
  /** @deprecated Use `errors` field instead. */
  accountErrors: Array<AccountError>;
  errors: Array<AccountError>;
  user: Maybe<User>;
};

/** Represents user address data. */
export type Address = Node & ObjectWithMetadata & {
  __typename: 'Address';
  /** The city of the address. */
  city: Scalars['String'];
  /** The district of the address. */
  cityArea: Scalars['String'];
  /** Company or organization name. */
  companyName: Scalars['String'];
  /** The country of the address. */
  country: CountryDisplay;
  /** The country area of the address. */
  countryArea: Scalars['String'];
  /** The given name of the address. */
  firstName: Scalars['String'];
  /** The ID of the address. */
  id: Scalars['ID'];
  /** Address is user's default billing address. */
  isDefaultBillingAddress: Maybe<Scalars['Boolean']>;
  /** Address is user's default shipping address. */
  isDefaultShippingAddress: Maybe<Scalars['Boolean']>;
  /** The family name of the address. */
  lastName: Scalars['String'];
  /** List of public metadata items. Can be accessed without permissions. */
  metadata: Array<MetadataItem>;
  /**
   * A single key from public metadata.
   *
   * Tip: Use GraphQL aliases to fetch multiple keys.
   */
  metafield: Maybe<Scalars['String']>;
  /** Public metadata. Use `keys` to control which fields you want to include. The default is to include everything. */
  metafields: Maybe<Scalars['Metadata']>;
  /** The phone number assigned the address. */
  phone: Maybe<Scalars['String']>;
  /** The postal code of the address. */
  postalCode: Scalars['String'];
  /** List of private metadata items. Requires staff permissions to access. */
  privateMetadata: Array<MetadataItem>;
  /**
   * A single key from private metadata. Requires staff permissions to access.
   *
   * Tip: Use GraphQL aliases to fetch multiple keys.
   */
  privateMetafield: Maybe<Scalars['String']>;
  /** Private metadata. Requires staff permissions to access. Use `keys` to control which fields you want to include. The default is to include everything. */
  privateMetafields: Maybe<Scalars['Metadata']>;
  /** The first line of the address. */
  streetAddress1: Scalars['String'];
  /** The second line of the address. */
  streetAddress2: Scalars['String'];
};


/** Represents user address data. */
export type AddressMetafieldArgs = {
  key: Scalars['String'];
};


/** Represents user address data. */
export type AddressMetafieldsArgs = {
  keys: InputMaybe<Array<Scalars['String']>>;
};


/** Represents user address data. */
export type AddressPrivateMetafieldArgs = {
  key: Scalars['String'];
};


/** Represents user address data. */
export type AddressPrivateMetafieldsArgs = {
  keys: InputMaybe<Array<Scalars['String']>>;
};

/**
 * Creates user address.
 *
 * Requires one of the following permissions: MANAGE_USERS.
 *
 * Triggers the following webhook events:
 * - ADDRESS_CREATED (async): A new address was created.
 */
export type AddressCreate = {
  __typename: 'AddressCreate';
  /** @deprecated Use `errors` field instead. */
  accountErrors: Array<AccountError>;
  address: Maybe<Address>;
  errors: Array<AccountError>;
  /** A user instance for which the address was created. */
  user: Maybe<User>;
};

/** Event sent when new address is created. */
export type AddressCreated = Event & {
  __typename: 'AddressCreated';
  /** The address the event relates to. */
  address: Maybe<Address>;
  /** Time of the event. */
  issuedAt: Maybe<Scalars['DateTime']>;
  /** The user or application that triggered the event. */
  issuingPrincipal: Maybe<IssuingPrincipal>;
  /** The application receiving the webhook. */
  recipient: Maybe<App>;
  /** Saleor version that triggered the event. */
  version: Maybe<Scalars['String']>;
};

/**
 * Deletes an address.
 *
 * Requires one of the following permissions: MANAGE_USERS.
 *
 * Triggers the following webhook events:
 * - ADDRESS_DELETED (async): An address was deleted.
 */
export type AddressDelete = {
  __typename: 'AddressDelete';
  /** @deprecated Use `errors` field instead. */
  accountErrors: Array<AccountError>;
  address: Maybe<Address>;
  errors: Array<AccountError>;
  /** A user instance for which the address was deleted. */
  user: Maybe<User>;
};

/** Event sent when address is deleted. */
export type AddressDeleted = Event & {
  __typename: 'AddressDeleted';
  /** The address the event relates to. */
  address: Maybe<Address>;
  /** Time of the event. */
  issuedAt: Maybe<Scalars['DateTime']>;
  /** The user or application that triggered the event. */
  issuingPrincipal: Maybe<IssuingPrincipal>;
  /** The application receiving the webhook. */
  recipient: Maybe<App>;
  /** Saleor version that triggered the event. */
  version: Maybe<Scalars['String']>;
};

/** Filtering options for addresses. */
export type AddressFilterInput = {
  country: InputMaybe<CountryCodeEnumFilterInput>;
  phoneNumber: InputMaybe<StringFilterInput>;
};

export type AddressInput = {
  /** City. */
  city: InputMaybe<Scalars['String']>;
  /** District. */
  cityArea: InputMaybe<Scalars['String']>;
  /** Company or organization. */
  companyName: InputMaybe<Scalars['String']>;
  /** Country. */
  country: InputMaybe<CountryCode>;
  /** State or province. */
  countryArea: InputMaybe<Scalars['String']>;
  /** Given name. */
  firstName: InputMaybe<Scalars['String']>;
  /** Family name. */
  lastName: InputMaybe<Scalars['String']>;
  /**
   * Address public metadata. Can be read by any API client authorized to read the object it's attached to.
   *
   * Warning: never store sensitive information, including financial data such as credit card details.
   */
  metadata: InputMaybe<Array<MetadataInput>>;
  /**
   * Phone number.
   *
   * Phone numbers are validated with Google's [libphonenumber](https://github.com/google/libphonenumber) library.
   */
  phone: InputMaybe<Scalars['String']>;
  /** Postal code. */
  postalCode: InputMaybe<Scalars['String']>;
  /**
   * Determine if the address should be validated. By default, Saleor accepts only address inputs matching ruleset from [Google Address Data]{https://chromium-i18n.appspot.com/ssl-address), using [i18naddress](https://github.com/mirumee/google-i18n-address) library. Some mutations may require additional permissions to use the the field. More info about permissions can be found in relevant mutation.
   *
   * Added in Saleor 3.19.
   *
   * Note: this API is currently in Feature Preview and can be subject to changes at later point.
   */
  skipValidation: InputMaybe<Scalars['Boolean']>;
  /** Address. */
  streetAddress1: InputMaybe<Scalars['String']>;
  /** Address. */
  streetAddress2: InputMaybe<Scalars['String']>;
};

/**
 * Sets a default address for the given user.
 *
 * Requires one of the following permissions: MANAGE_USERS.
 *
 * Triggers the following webhook events:
 * - CUSTOMER_UPDATED (async): A customer was updated.
 */
export type AddressSetDefault = {
  __typename: 'AddressSetDefault';
  /** @deprecated Use `errors` field instead. */
  accountErrors: Array<AccountError>;
  errors: Array<AccountError>;
  /** An updated user instance. */
  user: Maybe<User>;
};

export type AddressTypeEnum =
  | 'BILLING'
  | 'SHIPPING';

/**
 * Updates an address.
 *
 * Requires one of the following permissions: MANAGE_USERS.
 *
 * Triggers the following webhook events:
 * - ADDRESS_UPDATED (async): An address was updated.
 */
export type AddressUpdate = {
  __typename: 'AddressUpdate';
  /** @deprecated Use `errors` field instead. */
  accountErrors: Array<AccountError>;
  address: Maybe<Address>;
  errors: Array<AccountError>;
  /** A user object for which the address was edited. */
  user: Maybe<User>;
};

/** Event sent when address is updated. */
export type AddressUpdated = Event & {
  __typename: 'AddressUpdated';
  /** The address the event relates to. */
  address: Maybe<Address>;
  /** Time of the event. */
  issuedAt: Maybe<Scalars['DateTime']>;
  /** The user or application that triggered the event. */
  issuingPrincipal: Maybe<IssuingPrincipal>;
  /** The application receiving the webhook. */
  recipient: Maybe<App>;
  /** Saleor version that triggered the event. */
  version: Maybe<Scalars['String']>;
};

/** Represents address validation rules for a country. */
export type AddressValidationData = {
  __typename: 'AddressValidationData';
  /**
   * The address format of the address validation rule.
   *
   * Many fields in the JSON refer to address fields by one-letter abbreviations. These are defined as follows:
   *
   * - `N`: Name
   * - `O`: Organization
   * - `A`: Street Address Line(s)
   * - `D`: Dependent locality (may be an inner-city district or a suburb)
   * - `C`: City or Locality
   * - `S`: Administrative area such as a state, province, island etc
   * - `Z`: Zip or postal code
   * - `X`: Sorting code
   *
   * [Click here for more information.](https://github.com/google/libaddressinput/wiki/AddressValidationMetadata)
   */
  addressFormat: Scalars['String'];
  /**
   * The latin address format of the address validation rule.
   *
   * Many fields in the JSON refer to address fields by one-letter abbreviations. These are defined as follows:
   *
   * - `N`: Name
   * - `O`: Organization
   * - `A`: Street Address Line(s)
   * - `D`: Dependent locality (may be an inner-city district or a suburb)
   * - `C`: City or Locality
   * - `S`: Administrative area such as a state, province, island etc
   * - `Z`: Zip or postal code
   * - `X`: Sorting code
   *
   * [Click here for more information.](https://github.com/google/libaddressinput/wiki/AddressValidationMetadata)
   */
  addressLatinFormat: Scalars['String'];
  /** The allowed fields to use in address. */
  allowedFields: Array<Scalars['String']>;
  /** The available choices for the city area of the address validation rule. */
  cityAreaChoices: Array<ChoiceValue>;
  /** The formal name of the city area of the address validation rule. */
  cityAreaType: Scalars['String'];
  /** The available choices for the city of the address validation rule. */
  cityChoices: Array<ChoiceValue>;
  /** The formal name of the city of the address validation rule. */
  cityType: Scalars['String'];
  /** The available choices for the country area of the address validation rule. */
  countryAreaChoices: Array<ChoiceValue>;
  /** The formal name of the county area of the address validation rule. */
  countryAreaType: Scalars['String'];
  /** The country code of the address validation rule. */
  countryCode: Scalars['String'];
  /** The country name of the address validation rule. */
  countryName: Scalars['String'];
  /** The example postal code of the address validation rule. */
  postalCodeExamples: Array<Scalars['String']>;
  /** The regular expression for postal code validation. */
  postalCodeMatchers: Array<Scalars['String']>;
  /** The postal code prefix of the address validation rule. */
  postalCodePrefix: Scalars['String'];
  /** The formal name of the postal code of the address validation rule. */
  postalCodeType: Scalars['String'];
  /** The required fields to create a valid address. */
  requiredFields: Array<Scalars['String']>;
  /** The list of fields that should be in upper case for address validation rule. */
  upperFields: Array<Scalars['String']>;
};

/** Represents allocation. */
export type Allocation = Node & {
  __typename: 'Allocation';
  /** The ID of allocation. */
  id: Scalars['ID'];
  /**
   * Quantity allocated for orders.
   *
   * Requires one of the following permissions: MANAGE_PRODUCTS, MANAGE_ORDERS.
   */
  quantity: Scalars['Int'];
  /**
   * The warehouse were items were allocated.
   *
   * Requires one of the following permissions: MANAGE_PRODUCTS, MANAGE_ORDERS.
   */
  warehouse: Warehouse;
};

/**
 * Determine the allocation strategy for the channel.
 *
 *     PRIORITIZE_SORTING_ORDER - allocate stocks according to the warehouses' order
 *     within the channel
 *
 *     PRIORITIZE_HIGH_STOCK - allocate stock in a warehouse with the most stock
 */
export type AllocationStrategyEnum =
  | 'PRIORITIZE_HIGH_STOCK'
  | 'PRIORITIZE_SORTING_ORDER';

/** Represents app data. */
export type App = Node & ObjectWithMetadata & {
  __typename: 'App';
  /** Description of this app. */
  aboutApp: Maybe<Scalars['String']>;
  /** JWT token used to authenticate by third-party app. */
  accessToken: Maybe<Scalars['String']>;
  /** URL to iframe with the app. */
  appUrl: Maybe<Scalars['String']>;
  /** The App's author name. */
  author: Maybe<Scalars['String']>;
  /** App's brand data. */
  brand: Maybe<AppBrand>;
  /**
   * Circuit breaker last state change date.
   *
   * Added in Saleor 3.21.
   */
  breakerLastStateChange: Maybe<Scalars['DateTime']>;
  /**
   * Circuit breaker state, if open, sync webhooks operation is disrupted.
   *
   * Added in Saleor 3.21.
   */
  breakerState: CircuitBreakerStateEnum;
  /**
   * URL to iframe with the configuration for the app.
   * @deprecated Use `appUrl` instead.
   */
  configurationUrl: Maybe<Scalars['String']>;
  /** The date and time when the app was created. */
  created: Maybe<Scalars['DateTime']>;
  /**
   * Description of the data privacy defined for this app.
   * @deprecated Use `dataPrivacyUrl` instead.
   */
  dataPrivacy: Maybe<Scalars['String']>;
  /** URL to details about the privacy policy on the app owner page. */
  dataPrivacyUrl: Maybe<Scalars['String']>;
  /** App's dashboard extensions. */
  extensions: Array<AppExtension>;
  /** Homepage of the app. */
  homepageUrl: Maybe<Scalars['String']>;
  /** The ID of the app. */
  id: Scalars['ID'];
  /**
   * Canonical app ID from the manifest
   *
   * Added in Saleor 3.19.
   */
  identifier: Maybe<Scalars['String']>;
  /** Determine if app will be set active or not. */
  isActive: Maybe<Scalars['Boolean']>;
  /** URL to manifest used during app's installation. */
  manifestUrl: Maybe<Scalars['String']>;
  /** List of public metadata items. Can be accessed without permissions. */
  metadata: Array<MetadataItem>;
  /**
   * A single key from public metadata.
   *
   * Tip: Use GraphQL aliases to fetch multiple keys.
   */
  metafield: Maybe<Scalars['String']>;
  /** Public metadata. Use `keys` to control which fields you want to include. The default is to include everything. */
  metafields: Maybe<Scalars['Metadata']>;
  /** Name of the app. */
  name: Maybe<Scalars['String']>;
  /** List of the app's permissions. */
  permissions: Maybe<Array<Permission>>;
  /** List of private metadata items. Requires staff permissions to access. */
  privateMetadata: Array<MetadataItem>;
  /**
   * A single key from private metadata. Requires staff permissions to access.
   *
   * Tip: Use GraphQL aliases to fetch multiple keys.
   */
  privateMetafield: Maybe<Scalars['String']>;
  /** Private metadata. Requires staff permissions to access. Use `keys` to control which fields you want to include. The default is to include everything. */
  privateMetafields: Maybe<Scalars['Metadata']>;
  /**
   * List of problems associated with this app.
   *
   * Added in Saleor 3.22.
   *
   * Requires one of the following permissions: AUTHENTICATED_APP, MANAGE_APPS.
   */
  problems: Maybe<Array<AppProblem>>;
  /** Support page for the app. */
  supportUrl: Maybe<Scalars['String']>;
  /**
   * Last 4 characters of the tokens.
   *
   * Requires one of the following permissions: MANAGE_APPS, OWNER.
   */
  tokens: Maybe<Array<AppToken>>;
  /** Type of the app. */
  type: Maybe<AppTypeEnum>;
  /** Version number of the app. */
  version: Maybe<Scalars['String']>;
  /**
   * List of webhooks assigned to this app.
   *
   * Requires one of the following permissions: MANAGE_APPS, OWNER.
   */
  webhooks: Maybe<Array<Webhook>>;
};


/** Represents app data. */
export type AppMetafieldArgs = {
  key: Scalars['String'];
};


/** Represents app data. */
export type AppMetafieldsArgs = {
  keys: InputMaybe<Array<Scalars['String']>>;
};


/** Represents app data. */
export type AppPrivateMetafieldArgs = {
  key: Scalars['String'];
};


/** Represents app data. */
export type AppPrivateMetafieldsArgs = {
  keys: InputMaybe<Array<Scalars['String']>>;
};


/** Represents app data. */
export type AppProblemsArgs = {
  limit: InputMaybe<Scalars['PositiveInt']>;
};

/**
 * Activate the app.
 *
 * Requires one of the following permissions: MANAGE_APPS.
 *
 * Triggers the following webhook events:
 * - APP_STATUS_CHANGED (async): An app was activated.
 */
export type AppActivate = {
  __typename: 'AppActivate';
  app: Maybe<App>;
  /** @deprecated Use `errors` field instead. */
  appErrors: Array<AppError>;
  errors: Array<AppError>;
};

/** Represents the app's brand data. */
export type AppBrand = {
  __typename: 'AppBrand';
  /** App's logos details. */
  logo: AppBrandLogo;
};

/** Represents the app's brand logo data. */
export type AppBrandLogo = {
  __typename: 'AppBrandLogo';
  /** URL to the default logo image. */
  default: Scalars['String'];
};


/** Represents the app's brand logo data. */
export type AppBrandLogoDefaultArgs = {
  format?: InputMaybe<IconThumbnailFormatEnum>;
  size: InputMaybe<Scalars['Int']>;
};

export type AppCountableConnection = {
  __typename: 'AppCountableConnection';
  edges: Array<AppCountableEdge>;
  /** Pagination data for this connection. */
  pageInfo: PageInfo;
  /** A total count of items in the collection. */
  totalCount: Maybe<Scalars['Int']>;
};

export type AppCountableEdge = {
  __typename: 'AppCountableEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node: App;
};

/**
 * Creates a new app. Requires the following permissions: AUTHENTICATED_STAFF_USER and MANAGE_APPS.
 *
 * Triggers the following webhook events:
 * - APP_INSTALLED (async): An app was installed.
 */
export type AppCreate = {
  __typename: 'AppCreate';
  app: Maybe<App>;
  /** @deprecated Use `errors` field instead. */
  appErrors: Array<AppError>;
  /** The newly created authentication token. */
  authToken: Maybe<Scalars['String']>;
  errors: Array<AppError>;
};

/**
 * Deactivate the app.
 *
 * Requires one of the following permissions: MANAGE_APPS.
 *
 * Triggers the following webhook events:
 * - APP_STATUS_CHANGED (async): An app was deactivated.
 */
export type AppDeactivate = {
  __typename: 'AppDeactivate';
  app: Maybe<App>;
  /** @deprecated Use `errors` field instead. */
  appErrors: Array<AppError>;
  errors: Array<AppError>;
};

/**
 * Deletes an app.
 *
 * Requires one of the following permissions: MANAGE_APPS.
 *
 * Triggers the following webhook events:
 * - APP_DELETED (async): An app was deleted.
 */
export type AppDelete = {
  __typename: 'AppDelete';
  app: Maybe<App>;
  /** @deprecated Use `errors` field instead. */
  appErrors: Array<AppError>;
  errors: Array<AppError>;
};

/**
 * Deletes failed installation.
 *
 * Requires one of the following permissions: MANAGE_APPS.
 */
export type AppDeleteFailedInstallation = {
  __typename: 'AppDeleteFailedInstallation';
  /** @deprecated Use `errors` field instead. */
  appErrors: Array<AppError>;
  appInstallation: Maybe<AppInstallation>;
  errors: Array<AppError>;
};

/** Event sent when app is deleted. */
export type AppDeleted = Event & {
  __typename: 'AppDeleted';
  /** The application the event relates to. */
  app: Maybe<App>;
  /** Time of the event. */
  issuedAt: Maybe<Scalars['DateTime']>;
  /** The user or application that triggered the event. */
  issuingPrincipal: Maybe<IssuingPrincipal>;
  /** The application receiving the webhook. */
  recipient: Maybe<App>;
  /** Saleor version that triggered the event. */
  version: Maybe<Scalars['String']>;
};

export type AppError = {
  __typename: 'AppError';
  /** The error code. */
  code: AppErrorCode;
  /** Name of a field that caused the error. A value of `null` indicates that the error isn't associated with a particular field. */
  field: Maybe<Scalars['String']>;
  /** The error message. */
  message: Maybe<Scalars['String']>;
  /** List of permissions which causes the error. */
  permissions: Maybe<Array<PermissionEnum>>;
};

export type AppErrorCode =
  | 'FORBIDDEN'
  | 'GRAPHQL_ERROR'
  | 'INVALID'
  | 'INVALID_CUSTOM_HEADERS'
  | 'INVALID_MANIFEST_FORMAT'
  | 'INVALID_PERMISSION'
  | 'INVALID_STATUS'
  | 'INVALID_URL_FORMAT'
  | 'MANIFEST_URL_CANT_CONNECT'
  | 'NOT_FOUND'
  | 'OUT_OF_SCOPE_APP'
  | 'OUT_OF_SCOPE_PERMISSION'
  | 'REQUIRED'
  | 'UNIQUE'
  | 'UNSUPPORTED_SALEOR_VERSION';

/** Represents app data. */
export type AppExtension = Node & {
  __typename: 'AppExtension';
  /** JWT token used to authenticate by third-party app extension. */
  accessToken: Maybe<Scalars['String']>;
  /** The app assigned to app extension. */
  app: App;
  /** The ID of the app extension. */
  id: Scalars['ID'];
  /** Label of the extension to show in the dashboard. */
  label: Scalars['String'];
  /**
   * Place where given extension will be mounted.
   * @deprecated Use `mountName` instead.
   */
  mount: AppExtensionMountEnum;
  /**
   * Name of the extension mount point in the dashboard. Replaces `mount`
   *
   * Added in Saleor 3.22.
   */
  mountName: Scalars['String'];
  /**
   * App extension options.
   *
   * Added in Saleor 3.22.
   * @deprecated Use `settings` field instead.
   */
  options: Maybe<AppExtensionPossibleOptions>;
  /** List of the app extension's permissions. */
  permissions: Array<Permission>;
  /**
   * App extension settings. Replaces `options` field.
   *
   * Added in Saleor 3.22.
   */
  settings: Scalars['JSON'];
  /**
   * Type of way how app extension will be opened.
   * @deprecated Use `targetName` instead.
   */
  target: AppExtensionTargetEnum;
  /**
   * Name of the extension target in the dashboard. Replaces `target`
   *
   * Added in Saleor 3.22.
   */
  targetName: Scalars['String'];
  /** URL of a view where extension's iframe is placed. */
  url: Scalars['String'];
};

export type AppExtensionCountableConnection = {
  __typename: 'AppExtensionCountableConnection';
  edges: Array<AppExtensionCountableEdge>;
  /** Pagination data for this connection. */
  pageInfo: PageInfo;
  /** A total count of items in the collection. */
  totalCount: Maybe<Scalars['Int']>;
};

export type AppExtensionCountableEdge = {
  __typename: 'AppExtensionCountableEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node: AppExtension;
};

export type AppExtensionFilterInput = {
  /**
   * DEPRECATED: Use `mountName` instead.
   * @deprecated Field no longer supported
   */
  mount: InputMaybe<Array<AppExtensionMountEnum>>;
  /**
   * Plain-text mount name (case insensitive)
   *
   * Added in Saleor 3.22.
   */
  mountName: InputMaybe<Array<Scalars['String']>>;
  /**
   * DEPRECATED: Use `targetName` instead.
   * @deprecated Field no longer supported
   */
  target: InputMaybe<AppExtensionTargetEnum>;
  /**
   * Plain-text target name (case insensitive)
   *
   * Added in Saleor 3.22.
   */
  targetName: InputMaybe<Scalars['String']>;
};

/** All places where app extension can be mounted. */
export type AppExtensionMountEnum =
  | 'CATEGORY_DETAILS_MORE_ACTIONS'
  | 'CATEGORY_OVERVIEW_CREATE'
  | 'CATEGORY_OVERVIEW_MORE_ACTIONS'
  | 'COLLECTION_DETAILS_MORE_ACTIONS'
  | 'COLLECTION_DETAILS_WIDGETS'
  | 'COLLECTION_OVERVIEW_CREATE'
  | 'COLLECTION_OVERVIEW_MORE_ACTIONS'
  | 'CUSTOMER_DETAILS_MORE_ACTIONS'
  | 'CUSTOMER_DETAILS_WIDGETS'
  | 'CUSTOMER_OVERVIEW_CREATE'
  | 'CUSTOMER_OVERVIEW_MORE_ACTIONS'
  | 'DISCOUNT_DETAILS_MORE_ACTIONS'
  | 'DISCOUNT_OVERVIEW_CREATE'
  | 'DISCOUNT_OVERVIEW_MORE_ACTIONS'
  | 'DRAFT_ORDER_DETAILS_MORE_ACTIONS'
  | 'DRAFT_ORDER_DETAILS_WIDGETS'
  | 'DRAFT_ORDER_OVERVIEW_CREATE'
  | 'DRAFT_ORDER_OVERVIEW_MORE_ACTIONS'
  | 'GIFT_CARD_DETAILS_MORE_ACTIONS'
  | 'GIFT_CARD_DETAILS_WIDGETS'
  | 'GIFT_CARD_OVERVIEW_CREATE'
  | 'GIFT_CARD_OVERVIEW_MORE_ACTIONS'
  | 'MENU_DETAILS_MORE_ACTIONS'
  | 'MENU_OVERVIEW_CREATE'
  | 'MENU_OVERVIEW_MORE_ACTIONS'
  | 'NAVIGATION_CATALOG'
  | 'NAVIGATION_CUSTOMERS'
  | 'NAVIGATION_DISCOUNTS'
  | 'NAVIGATION_ORDERS'
  | 'NAVIGATION_PAGES'
  | 'NAVIGATION_TRANSLATIONS'
  | 'ORDER_DETAILS_MORE_ACTIONS'
  | 'ORDER_DETAILS_WIDGETS'
  | 'ORDER_OVERVIEW_CREATE'
  | 'ORDER_OVERVIEW_MORE_ACTIONS'
  | 'PAGE_DETAILS_MORE_ACTIONS'
  | 'PAGE_OVERVIEW_CREATE'
  | 'PAGE_OVERVIEW_MORE_ACTIONS'
  | 'PAGE_TYPE_DETAILS_MORE_ACTIONS'
  | 'PAGE_TYPE_OVERVIEW_CREATE'
  | 'PAGE_TYPE_OVERVIEW_MORE_ACTIONS'
  | 'PRODUCT_DETAILS_MORE_ACTIONS'
  | 'PRODUCT_DETAILS_WIDGETS'
  | 'PRODUCT_OVERVIEW_CREATE'
  | 'PRODUCT_OVERVIEW_MORE_ACTIONS'
  | 'TRANSLATIONS_MORE_ACTIONS'
  | 'VOUCHER_DETAILS_MORE_ACTIONS'
  | 'VOUCHER_DETAILS_WIDGETS'
  | 'VOUCHER_OVERVIEW_CREATE'
  | 'VOUCHER_OVERVIEW_MORE_ACTIONS';

/** Represents the options for an app extension. */
export type AppExtensionOptionsNewTab = {
  __typename: 'AppExtensionOptionsNewTab';
  /**
   * Options controlling behavior of the NEW_TAB extension target
   * @deprecated Use `settings` field directly.
   */
  newTabTarget: Maybe<NewTabTargetOptions>;
};

/** Represents the options for an app extension. */
export type AppExtensionOptionsWidget = {
  __typename: 'AppExtensionOptionsWidget';
  /**
   * Options for displaying a Widget
   * @deprecated Use `settings` field directly.
   */
  widgetTarget: Maybe<WidgetTargetOptions>;
};

export type AppExtensionPossibleOptions = AppExtensionOptionsNewTab | AppExtensionOptionsWidget;

/**
 * All available ways of opening an app extension.
 *
 *     POPUP - app's extension will be mounted as a popup window
 *     APP_PAGE - redirect to app's page
 */
export type AppExtensionTargetEnum =
  | 'APP_PAGE'
  | 'NEW_TAB'
  | 'POPUP'
  | 'WIDGET';

/**
 * Fetch and validate manifest.
 *
 * Requires one of the following permissions: MANAGE_APPS.
 */
export type AppFetchManifest = {
  __typename: 'AppFetchManifest';
  /** @deprecated Use `errors` field instead. */
  appErrors: Array<AppError>;
  errors: Array<AppError>;
  /** The validated manifest. */
  manifest: Maybe<Manifest>;
};

export type AppFilterInput = {
  isActive: InputMaybe<Scalars['Boolean']>;
  search: InputMaybe<Scalars['String']>;
  type: InputMaybe<AppTypeEnum>;
};

export type AppInput = {
  /**
   * Canonical app ID. If not provided, the identifier will be generated based on app.id.
   *
   * Added in Saleor 3.19.
   */
  identifier: InputMaybe<Scalars['String']>;
  /** Name of the app. */
  name: InputMaybe<Scalars['String']>;
  /** List of permission code names to assign to this app. */
  permissions: InputMaybe<Array<PermissionEnum>>;
};

/** Install new app by using app manifest. Requires the following permissions: AUTHENTICATED_STAFF_USER and MANAGE_APPS. */
export type AppInstall = {
  __typename: 'AppInstall';
  /** @deprecated Use `errors` field instead. */
  appErrors: Array<AppError>;
  appInstallation: Maybe<AppInstallation>;
  errors: Array<AppError>;
};

export type AppInstallInput = {
  /** Determine if app will be set active or not. */
  activateAfterInstallation: InputMaybe<Scalars['Boolean']>;
  /** Name of the app to install. */
  appName: InputMaybe<Scalars['String']>;
  /** URL to app's manifest in JSON format. */
  manifestUrl: InputMaybe<Scalars['String']>;
  /** List of permission code names to assign to this app. */
  permissions: InputMaybe<Array<PermissionEnum>>;
};

/** Represents ongoing installation of app. */
export type AppInstallation = Job & Node & {
  __typename: 'AppInstallation';
  /** The name of the app installation. */
  appName: Scalars['String'];
  /** App's brand data. */
  brand: Maybe<AppBrand>;
  /** Created date time of job in ISO 8601 format. */
  createdAt: Scalars['DateTime'];
  /** The ID of the app installation. */
  id: Scalars['ID'];
  /** The URL address of manifest for the app installation. */
  manifestUrl: Scalars['String'];
  /** Job message. */
  message: Maybe<Scalars['String']>;
  /** Job status. */
  status: JobStatusEnum;
  /** Date time of job last update in ISO 8601 format. */
  updatedAt: Scalars['DateTime'];
};

/** Event sent when new app is installed. */
export type AppInstalled = Event & {
  __typename: 'AppInstalled';
  /** The application the event relates to. */
  app: Maybe<App>;
  /** Time of the event. */
  issuedAt: Maybe<Scalars['DateTime']>;
  /** The user or application that triggered the event. */
  issuingPrincipal: Maybe<IssuingPrincipal>;
  /** The application receiving the webhook. */
  recipient: Maybe<App>;
  /** Saleor version that triggered the event. */
  version: Maybe<Scalars['String']>;
};

/** Represents the app's manifest brand data. */
export type AppManifestBrand = {
  __typename: 'AppManifestBrand';
  /** App's logos details. */
  logo: AppManifestBrandLogo;
};

/** Represents the app's manifest brand data. */
export type AppManifestBrandLogo = {
  __typename: 'AppManifestBrandLogo';
  /** Data URL with a base64 encoded logo image. */
  default: Scalars['String'];
};


/** Represents the app's manifest brand data. */
export type AppManifestBrandLogoDefaultArgs = {
  format?: InputMaybe<IconThumbnailFormatEnum>;
  size: InputMaybe<Scalars['Int']>;
};

export type AppManifestExtension = {
  __typename: 'AppManifestExtension';
  /** Label of the extension to show in the dashboard. */
  label: Scalars['String'];
  /**
   * Place where given extension will be mounted.
   * @deprecated Use `mountName` instead.
   */
  mount: AppExtensionMountEnum;
  /**
   * Name of the extension mount point in the dashboard. Replaces `mount`
   *
   * Added in Saleor 3.22.
   */
  mountName: Scalars['String'];
  /** List of the app extension's permissions. */
  permissions: Array<Permission>;
  /**
   * JSON object with settings for this extension.
   *
   * Added in Saleor 3.22.
   */
  settings: Scalars['JSON'];
  /**
   * Type of way how app extension will be opened.
   * @deprecated Use `targetName` instead.
   */
  target: AppExtensionTargetEnum;
  /**
   * Name of the extension target in the dashboard. Replaces `target`
   *
   * Added in Saleor 3.22.
   */
  targetName: Scalars['String'];
  /** URL of a view where extension's iframe is placed. */
  url: Scalars['String'];
};

export type AppManifestRequiredSaleorVersion = {
  __typename: 'AppManifestRequiredSaleorVersion';
  /** Required Saleor version as semver range. */
  constraint: Scalars['String'];
  /** Informs if the Saleor version matches the required one. */
  satisfied: Scalars['Boolean'];
};

export type AppManifestWebhook = {
  __typename: 'AppManifestWebhook';
  /** The asynchronous events that webhook wants to subscribe. */
  asyncEvents: Maybe<Array<WebhookEventTypeAsyncEnum>>;
  /** The name of the webhook. */
  name: Scalars['String'];
  /** Subscription query of a webhook */
  query: Scalars['String'];
  /** The synchronous events that webhook wants to subscribe. */
  syncEvents: Maybe<Array<WebhookEventTypeSyncEnum>>;
  /** The url to receive the payload. */
  targetUrl: Scalars['String'];
};

/**
 * Represents a problem associated with an app.
 *
 * Added in Saleor 3.22.
 */
export type AppProblem = Node & {
  __typename: 'AppProblem';
  /**
   * Number of occurrences.
   *
   * Added in Saleor 3.22.
   */
  count: Scalars['Int'];
  /**
   * The date and time when the problem was created.
   *
   * Added in Saleor 3.22.
   */
  createdAt: Scalars['DateTime'];
  /**
   * Dismissal information. Null if the problem has not been dismissed.
   *
   * Added in Saleor 3.22.
   *
   * Requires one of the following permissions: AUTHENTICATED_APP, MANAGE_APPS.
   */
  dismissed: Maybe<AppProblemDismissed>;
  /**
   * The ID of the app problem.
   *
   * Added in Saleor 3.22.
   */
  id: Scalars['ID'];
  /**
   * Whether the problem has reached critical threshold.
   *
   * Added in Saleor 3.22.
   */
  isCritical: Scalars['Boolean'];
  /**
   * Key identifying the type of problem.
   *
   * Added in Saleor 3.22.
   */
  key: Scalars['String'];
  /**
   * The problem message.
   *
   * Added in Saleor 3.22.
   */
  message: Scalars['String'];
  /**
   * The date and time when the problem was last updated.
   *
   * Added in Saleor 3.22.
   */
  updatedAt: Scalars['DateTime'];
};

/**
 * Add a problem to the calling app.
 *
 * Added in Saleor 3.22.
 *
 * Requires one of the following permissions: AUTHENTICATED_APP.
 */
export type AppProblemCreate = {
  __typename: 'AppProblemCreate';
  /** The created or updated app problem. */
  appProblem: Maybe<AppProblem>;
  errors: Array<AppProblemCreateError>;
};

export type AppProblemCreateError = {
  __typename: 'AppProblemCreateError';
  /** The error code. */
  code: AppProblemCreateErrorCode;
  /** Name of a field that caused the error. A value of `null` indicates that the error isn't associated with a particular field. */
  field: Maybe<Scalars['String']>;
  /** The error message. */
  message: Maybe<Scalars['String']>;
};

export type AppProblemCreateErrorCode =
  | 'GRAPHQL_ERROR'
  | 'INVALID'
  | 'NOT_FOUND'
  | 'REQUIRED';

export type AppProblemCreateInput = {
  /** Time window in minutes for aggregating problems with the same key. Defaults to 60. If 0, a new problem is always created. */
  aggregationPeriod: InputMaybe<Scalars['Minute']>;
  /** If set, the problem becomes critical when count reaches this value. If sent again with higher value than already counted, problem can be de-escalated. */
  criticalThreshold: InputMaybe<Scalars['PositiveInt']>;
  /** Key identifying the type of problem. App can add multiple problems under the same key, to merge them together or delete them in batch. Must be between 3 and 128 characters. */
  key: Scalars['String'];
  /** The problem message to display. Must be at least 3 characters. Messages longer than 2048 characters will be truncated to 2048 characters with '...' suffix. */
  message: Scalars['String'];
};

/**
 * Dismiss problems for an app.
 *
 * Added in Saleor 3.22.
 *
 * Requires one of the following permissions: MANAGE_APPS, AUTHENTICATED_APP.
 */
export type AppProblemDismiss = {
  __typename: 'AppProblemDismiss';
  errors: Array<AppProblemDismissError>;
};

/** Input for app callers to dismiss their own problems. */
export type AppProblemDismissByAppInput = {
  /** List of problem IDs to dismiss. Cannot be combined with keys. Max 100. */
  ids: InputMaybe<Array<Scalars['ID']>>;
  /** List of problem keys to dismiss. Cannot be combined with ids. Max 100. */
  keys: InputMaybe<Array<Scalars['String']>>;
};

/** Input for staff callers to dismiss problems by IDs. */
export type AppProblemDismissByStaffWithIdsInput = {
  /** List of problem IDs to dismiss. Max 100. */
  ids: Array<Scalars['ID']>;
};

/** Input for staff callers to dismiss problems by keys. */
export type AppProblemDismissByStaffWithKeysInput = {
  /** ID of the app whose problems to dismiss. */
  app: Scalars['ID'];
  /** List of problem keys to dismiss. Max 100. */
  keys: Array<Scalars['String']>;
};

export type AppProblemDismissError = {
  __typename: 'AppProblemDismissError';
  /** The error code. */
  code: AppProblemDismissErrorCode;
  /** Name of a field that caused the error. A value of `null` indicates that the error isn't associated with a particular field. */
  field: Maybe<Scalars['String']>;
  /** The error message. */
  message: Maybe<Scalars['String']>;
};

export type AppProblemDismissErrorCode =
  | 'GRAPHQL_ERROR'
  | 'INVALID'
  | 'NOT_FOUND'
  | 'OUT_OF_SCOPE_APP'
  | 'REQUIRED';

/** Input for dismissing app problems. Only one can be specified. */
export type AppProblemDismissInput = {
  /** For app callers only - dismiss own problems. */
  byApp: InputMaybe<AppProblemDismissByAppInput>;
  /** For staff callers - dismiss problems by IDs. */
  byStaffWithIds: InputMaybe<AppProblemDismissByStaffWithIdsInput>;
  /** For staff callers - dismiss problems by keys for specified app. */
  byStaffWithKeys: InputMaybe<AppProblemDismissByStaffWithKeysInput>;
};

/**
 * Dismissal information for an app problem.
 *
 * Added in Saleor 3.22.
 */
export type AppProblemDismissed = {
  __typename: 'AppProblemDismissed';
  /**
   * Whether the problem was dismissed by an App or a User.
   *
   * Added in Saleor 3.22.
   */
  by: AppProblemDismissedByEnum;
  /**
   * The user who dismissed this problem. Null if dismissed by an app or the user was deleted.
   *
   * Added in Saleor 3.22.
   *
   * Requires one of the following permissions: MANAGE_STAFF.
   */
  user: Maybe<User>;
  /**
   * Email of the user who dismissed this problem. Preserved even if the user is deleted.
   *
   * Added in Saleor 3.22.
   *
   * Requires one of the following permissions: AUTHENTICATED_STAFF_USER.
   */
  userEmail: Maybe<Scalars['String']>;
};

export type AppProblemDismissedByEnum =
  | 'APP'
  | 'USER';

/**
 * Re-enable sync webhooks for provided app. Can be used to manually re-enable sync webhooks for the app before the cooldown period ends.
 *
 * Added in Saleor 3.21.
 *
 * Requires one of the following permissions: MANAGE_APPS.
 */
export type AppReenableSyncWebhooks = {
  __typename: 'AppReenableSyncWebhooks';
  /** App for which sync webhooks were re-enabled. */
  app: Maybe<App>;
  /** @deprecated Use `errors` field instead. */
  appErrors: Array<AppError>;
  errors: Array<AppError>;
};

/**
 * Retry failed installation of new app.
 *
 * Requires one of the following permissions: MANAGE_APPS.
 *
 * Triggers the following webhook events:
 * - APP_INSTALLED (async): An app was installed.
 */
export type AppRetryInstall = {
  __typename: 'AppRetryInstall';
  /** @deprecated Use `errors` field instead. */
  appErrors: Array<AppError>;
  appInstallation: Maybe<AppInstallation>;
  errors: Array<AppError>;
};

export type AppSortField =
  /** Sort apps by creation date. */
  | 'CREATION_DATE'
  /** Sort apps by name. */
  | 'NAME';

export type AppSortingInput = {
  /** Specifies the direction in which to sort apps. */
  direction: OrderDirection;
  /** Sort apps by the selected field. */
  field: AppSortField;
};

/** Event sent when app status has changed. */
export type AppStatusChanged = Event & {
  __typename: 'AppStatusChanged';
  /** The application the event relates to. */
  app: Maybe<App>;
  /** Time of the event. */
  issuedAt: Maybe<Scalars['DateTime']>;
  /** The user or application that triggered the event. */
  issuingPrincipal: Maybe<IssuingPrincipal>;
  /** The application receiving the webhook. */
  recipient: Maybe<App>;
  /** Saleor version that triggered the event. */
  version: Maybe<Scalars['String']>;
};

/** Represents token data. */
export type AppToken = Node & {
  __typename: 'AppToken';
  /** Last 4 characters of the token. */
  authToken: Maybe<Scalars['String']>;
  /** The ID of the app token. */
  id: Scalars['ID'];
  /** Name of the authenticated token. */
  name: Maybe<Scalars['String']>;
};

/**
 * Creates a new token.
 *
 * Requires one of the following permissions: MANAGE_APPS.
 */
export type AppTokenCreate = {
  __typename: 'AppTokenCreate';
  /** @deprecated Use `errors` field instead. */
  appErrors: Array<AppError>;
  appToken: Maybe<AppToken>;
  /** The newly created authentication token. */
  authToken: Maybe<Scalars['String']>;
  errors: Array<AppError>;
};

/**
 * Deletes an authentication token assigned to app.
 *
 * Requires one of the following permissions: MANAGE_APPS.
 */
export type AppTokenDelete = {
  __typename: 'AppTokenDelete';
  /** @deprecated Use `errors` field instead. */
  appErrors: Array<AppError>;
  appToken: Maybe<AppToken>;
  errors: Array<AppError>;
};

export type AppTokenInput = {
  /** ID of app. */
  app: Scalars['ID'];
  /** Name of the token. */
  name: InputMaybe<Scalars['String']>;
};

/** Verify provided app token. */
export type AppTokenVerify = {
  __typename: 'AppTokenVerify';
  /** @deprecated Use `errors` field instead. */
  appErrors: Array<AppError>;
  errors: Array<AppError>;
  /** Determine if token is valid or not. */
  valid: Scalars['Boolean'];
};

/** Enum determining type of your App. */
export type AppTypeEnum =
  /** Local Saleor App. The app is fully manageable from dashboard. You can change assigned permissions, add webhooks, or authentication token */
  | 'LOCAL'
  /** Third party external App. Installation is fully automated. Saleor uses a defined App manifest to gather all required information. */
  | 'THIRDPARTY';

/**
 * Updates an existing app.
 *
 * Requires one of the following permissions: MANAGE_APPS.
 *
 * Triggers the following webhook events:
 * - APP_UPDATED (async): An app was updated.
 */
export type AppUpdate = {
  __typename: 'AppUpdate';
  app: Maybe<App>;
  /** @deprecated Use `errors` field instead. */
  appErrors: Array<AppError>;
  errors: Array<AppError>;
};

/** Event sent when app is updated. */
export type AppUpdated = Event & {
  __typename: 'AppUpdated';
  /** The application the event relates to. */
  app: Maybe<App>;
  /** Time of the event. */
  issuedAt: Maybe<Scalars['DateTime']>;
  /** The user or application that triggered the event. */
  issuingPrincipal: Maybe<IssuingPrincipal>;
  /** The application receiving the webhook. */
  recipient: Maybe<App>;
  /** Saleor version that triggered the event. */
  version: Maybe<Scalars['String']>;
};

export type AreaUnitsEnum =
  | 'SQ_CM'
  | 'SQ_DM'
  | 'SQ_FT'
  | 'SQ_INCH'
  | 'SQ_KM'
  | 'SQ_M'
  | 'SQ_MM'
  | 'SQ_YD';

/**
 * Assigns storefront's navigation menus.
 *
 * Requires one of the following permissions: MANAGE_MENUS, MANAGE_SETTINGS.
 */
export type AssignNavigation = {
  __typename: 'AssignNavigation';
  errors: Array<MenuError>;
  /** Assigned navigation menu. */
  menu: Maybe<Menu>;
  /** @deprecated Use `errors` field instead. */
  menuErrors: Array<MenuError>;
};

/**
 * Represents an attribute assigned to an object.
 *
 * Added in Saleor 3.22.
 */
export type AssignedAttribute = {
  /** Attribute assigned to an object. */
  attribute: Attribute;
};

export type AssignedAttributeReferenceInput = {
  /** Returns objects with a reference pointing to a category identified by the given slug. */
  categorySlugs: InputMaybe<ContainsFilterInput>;
  /** Returns objects with a reference pointing to a collection identified by the given slug. */
  collectionSlugs: InputMaybe<ContainsFilterInput>;
  /** Returns objects with a reference pointing to a page identified by the given slug. */
  pageSlugs: InputMaybe<ContainsFilterInput>;
  /** Returns objects with a reference pointing to a product identified by the given slug. */
  productSlugs: InputMaybe<ContainsFilterInput>;
  /** Returns objects with a reference pointing to a product variant identified by the given sku. */
  productVariantSkus: InputMaybe<ContainsFilterInput>;
  /** Returns objects with a reference pointing to an object identified by the given ID. */
  referencedIds: InputMaybe<ContainsFilterInput>;
};

export type AssignedAttributeValueInput = {
  /** Filter by boolean value for attributes of boolean type. */
  boolean: InputMaybe<Scalars['Boolean']>;
  /** Filter by date value for attributes of date type. */
  date: InputMaybe<DateRangeInput>;
  /** Filter by date time value for attributes of date time type. */
  dateTime: InputMaybe<DateTimeRangeInput>;
  /** Filter by name assigned to AttributeValue. */
  name: InputMaybe<StringFilterInput>;
  /** Filter by numeric value for attributes of numeric type. */
  numeric: InputMaybe<DecimalFilterInput>;
  /** Filter by reference attribute value. */
  reference: InputMaybe<AssignedAttributeReferenceInput>;
  /** Filter by slug assigned to AttributeValue. */
  slug: InputMaybe<StringFilterInput>;
};

export type AssignedAttributeWhereInput = {
  /** Filter by attribute slug. */
  slug: InputMaybe<Scalars['String']>;
  /** Filter by value of the attribute. Only one value input field is allowed. If provided more than one, the error will be raised. */
  value: InputMaybe<AssignedAttributeValueInput>;
};

/**
 * Represents a boolean attribute.
 *
 * Added in Saleor 3.22.
 */
export type AssignedBooleanAttribute = AssignedAttribute & {
  __typename: 'AssignedBooleanAttribute';
  /** Attribute assigned to an object. */
  attribute: Attribute;
  /** The assigned boolean value. */
  value: Maybe<Scalars['Boolean']>;
};

/**
 * Represents a single choice value of the attribute.
 *
 * Added in Saleor 3.22.
 */
export type AssignedChoiceAttributeValue = {
  __typename: 'AssignedChoiceAttributeValue';
  /** Name of a value displayed in the interface. */
  name: Maybe<Scalars['String']>;
  /** Internal representation of a value (unique per attribute). */
  slug: Maybe<Scalars['String']>;
  /** Translation of the name. */
  translation: Maybe<Scalars['String']>;
};


/**
 * Represents a single choice value of the attribute.
 *
 * Added in Saleor 3.22.
 */
export type AssignedChoiceAttributeValueTranslationArgs = {
  languageCode: LanguageCodeEnum;
};

/**
 * Represents a date attribute.
 *
 * Added in Saleor 3.22.
 */
export type AssignedDateAttribute = AssignedAttribute & {
  __typename: 'AssignedDateAttribute';
  /** Attribute assigned to an object. */
  attribute: Attribute;
  /** The assigned date value. */
  value: Maybe<Scalars['Date']>;
};

/**
 * Represents a date time attribute.
 *
 * Added in Saleor 3.22.
 */
export type AssignedDateTimeAttribute = AssignedAttribute & {
  __typename: 'AssignedDateTimeAttribute';
  /** Attribute assigned to an object. */
  attribute: Attribute;
  /** The assigned date time value. */
  value: Maybe<Scalars['DateTime']>;
};

/**
 * Represents file attribute.
 *
 * Added in Saleor 3.22.
 */
export type AssignedFileAttribute = AssignedAttribute & {
  __typename: 'AssignedFileAttribute';
  /** Attribute assigned to an object. */
  attribute: Attribute;
  /** The assigned file. */
  value: Maybe<File>;
};

/**
 * Represents multi category reference attribute.
 *
 * Added in Saleor 3.22.
 */
export type AssignedMultiCategoryReferenceAttribute = AssignedAttribute & {
  __typename: 'AssignedMultiCategoryReferenceAttribute';
  /** Attribute assigned to an object. */
  attribute: Attribute;
  /** List of assigned category references. */
  value: Array<Category>;
};


/**
 * Represents multi category reference attribute.
 *
 * Added in Saleor 3.22.
 */
export type AssignedMultiCategoryReferenceAttributeValueArgs = {
  limit?: InputMaybe<Scalars['PositiveInt']>;
};

/**
 * Represents a multi choice attribute.
 *
 * Added in Saleor 3.22.
 */
export type AssignedMultiChoiceAttribute = AssignedAttribute & {
  __typename: 'AssignedMultiChoiceAttribute';
  /** Attribute assigned to an object. */
  attribute: Attribute;
  /** List of assigned choice values. */
  value: Array<AssignedChoiceAttributeValue>;
};


/**
 * Represents a multi choice attribute.
 *
 * Added in Saleor 3.22.
 */
export type AssignedMultiChoiceAttributeValueArgs = {
  limit?: InputMaybe<Scalars['PositiveInt']>;
};

/**
 * Represents multi collection reference attribute.
 *
 * Added in Saleor 3.22.
 */
export type AssignedMultiCollectionReferenceAttribute = AssignedAttribute & {
  __typename: 'AssignedMultiCollectionReferenceAttribute';
  /** Attribute assigned to an object. */
  attribute: Attribute;
  /** List of assigned collection references. */
  value: Array<Collection>;
};


/**
 * Represents multi collection reference attribute.
 *
 * Added in Saleor 3.22.
 */
export type AssignedMultiCollectionReferenceAttributeValueArgs = {
  limit?: InputMaybe<Scalars['PositiveInt']>;
};

/**
 * Represents multi page reference attribute.
 *
 * Added in Saleor 3.22.
 */
export type AssignedMultiPageReferenceAttribute = AssignedAttribute & {
  __typename: 'AssignedMultiPageReferenceAttribute';
  /** Attribute assigned to an object. */
  attribute: Attribute;
  /** List of assigned page references. */
  value: Array<Page>;
};


/**
 * Represents multi page reference attribute.
 *
 * Added in Saleor 3.22.
 */
export type AssignedMultiPageReferenceAttributeValueArgs = {
  limit?: InputMaybe<Scalars['PositiveInt']>;
};

/**
 * Represents multi product reference attribute.
 *
 * Added in Saleor 3.22.
 */
export type AssignedMultiProductReferenceAttribute = AssignedAttribute & {
  __typename: 'AssignedMultiProductReferenceAttribute';
  /** Attribute assigned to an object. */
  attribute: Attribute;
  /** List of assigned product references. */
  value: Array<Product>;
};


/**
 * Represents multi product reference attribute.
 *
 * Added in Saleor 3.22.
 */
export type AssignedMultiProductReferenceAttributeValueArgs = {
  limit?: InputMaybe<Scalars['PositiveInt']>;
};

/**
 * Represents multi product variant reference attribute.
 *
 * Added in Saleor 3.22.
 */
export type AssignedMultiProductVariantReferenceAttribute = AssignedAttribute & {
  __typename: 'AssignedMultiProductVariantReferenceAttribute';
  /** Attribute assigned to an object. */
  attribute: Attribute;
  /** List of assigned product variant references. */
  value: Array<ProductVariant>;
};


/**
 * Represents multi product variant reference attribute.
 *
 * Added in Saleor 3.22.
 */
export type AssignedMultiProductVariantReferenceAttributeValueArgs = {
  limit?: InputMaybe<Scalars['PositiveInt']>;
};

/**
 * Represents a numeric value of an attribute.
 *
 * Added in Saleor 3.22.
 */
export type AssignedNumericAttribute = AssignedAttribute & {
  __typename: 'AssignedNumericAttribute';
  /** Attribute assigned to an object. */
  attribute: Attribute;
  /** The assigned numeric value. */
  value: Maybe<Scalars['Float']>;
};

/**
 * Represents plain text attribute.
 *
 * Added in Saleor 3.22.
 */
export type AssignedPlainTextAttribute = AssignedAttribute & {
  __typename: 'AssignedPlainTextAttribute';
  /** Attribute assigned to an object. */
  attribute: Attribute;
  /** Translation of the plain text content in the specified language. */
  translation: Maybe<Scalars['String']>;
  /** The assigned plain text content. */
  value: Maybe<Scalars['String']>;
};


/**
 * Represents plain text attribute.
 *
 * Added in Saleor 3.22.
 */
export type AssignedPlainTextAttributeTranslationArgs = {
  languageCode: LanguageCodeEnum;
};

/**
 * Represents single category reference attribute.
 *
 * Added in Saleor 3.22.
 */
export type AssignedSingleCategoryReferenceAttribute = AssignedAttribute & {
  __typename: 'AssignedSingleCategoryReferenceAttribute';
  /** Attribute assigned to an object. */
  attribute: Attribute;
  /** The assigned category reference. */
  value: Maybe<Category>;
};

/**
 * Represents a single choice attribute.
 *
 * Added in Saleor 3.22.
 */
export type AssignedSingleChoiceAttribute = AssignedAttribute & {
  __typename: 'AssignedSingleChoiceAttribute';
  /** Attribute assigned to an object. */
  attribute: Attribute;
  /** The assigned choice value. */
  value: Maybe<AssignedChoiceAttributeValue>;
};

/**
 * Represents single collection reference attribute.
 *
 * Added in Saleor 3.22.
 */
export type AssignedSingleCollectionReferenceAttribute = AssignedAttribute & {
  __typename: 'AssignedSingleCollectionReferenceAttribute';
  /** Attribute assigned to an object. */
  attribute: Attribute;
  /** The assigned collection reference. */
  value: Maybe<Collection>;
};

/**
 * Represents single page reference attribute.
 *
 * Added in Saleor 3.22.
 */
export type AssignedSinglePageReferenceAttribute = AssignedAttribute & {
  __typename: 'AssignedSinglePageReferenceAttribute';
  /** Attribute assigned to an object. */
  attribute: Attribute;
  /** The assigned page reference. */
  value: Maybe<Page>;
};

/**
 * Represents single product reference attribute.
 *
 * Added in Saleor 3.22.
 */
export type AssignedSingleProductReferenceAttribute = AssignedAttribute & {
  __typename: 'AssignedSingleProductReferenceAttribute';
  /** Attribute assigned to an object. */
  attribute: Attribute;
  /** The assigned product reference. */
  value: Maybe<Product>;
};

/**
 * Represents single product variant reference attribute.
 *
 * Added in Saleor 3.22.
 */
export type AssignedSingleProductVariantReferenceAttribute = AssignedAttribute & {
  __typename: 'AssignedSingleProductVariantReferenceAttribute';
  /** Attribute assigned to an object. */
  attribute: Attribute;
  /** The assigned product variant reference. */
  value: Maybe<ProductVariant>;
};

/**
 * Represents a swatch attribute.
 *
 * Added in Saleor 3.22.
 */
export type AssignedSwatchAttribute = AssignedAttribute & {
  __typename: 'AssignedSwatchAttribute';
  /** Attribute assigned to an object. */
  attribute: Attribute;
  /** The assigned swatch value. */
  value: Maybe<AssignedSwatchAttributeValue>;
};

/**
 * Represents a single swatch value.
 *
 * Added in Saleor 3.22.
 */
export type AssignedSwatchAttributeValue = {
  __typename: 'AssignedSwatchAttributeValue';
  /** File associated with the attribute. */
  file: Maybe<File>;
  /** Hex color code. */
  hexColor: Maybe<Scalars['String']>;
  /** Name of the selected swatch value. */
  name: Maybe<Scalars['String']>;
  /** Slug of the selected swatch value. */
  slug: Maybe<Scalars['String']>;
};

/**
 * Represents text attribute.
 *
 * Added in Saleor 3.22.
 */
export type AssignedTextAttribute = AssignedAttribute & {
  __typename: 'AssignedTextAttribute';
  /** Attribute assigned to an object. */
  attribute: Attribute;
  /** Translation of the rich text content in the specified language. */
  translation: Maybe<Scalars['JSON']>;
  /** The assigned rich text content. */
  value: Maybe<Scalars['JSON']>;
};


/**
 * Represents text attribute.
 *
 * Added in Saleor 3.22.
 */
export type AssignedTextAttributeTranslationArgs = {
  languageCode: LanguageCodeEnum;
};

/** Represents assigned attribute to variant with variant selection attached. */
export type AssignedVariantAttribute = {
  __typename: 'AssignedVariantAttribute';
  /** Attribute assigned to variant. */
  attribute: Attribute;
  /** Determines, whether assigned attribute is allowed for variant selection. Supported variant types for variant selection are: ['dropdown', 'boolean', 'swatch', 'numeric'] */
  variantSelection: Scalars['Boolean'];
};

/** Custom attribute of a product. Attributes can be assigned to products and variants at the product type level. */
export type Attribute = Node & ObjectWithMetadata & {
  __typename: 'Attribute';
  /**
   * Whether the attribute can be displayed in the admin product list. Requires one of the following permissions: MANAGE_PAGES, MANAGE_PAGE_TYPES_AND_ATTRIBUTES, MANAGE_PRODUCTS, MANAGE_PRODUCT_TYPES_AND_ATTRIBUTES.
   * @deprecated Field no longer supported
   */
  availableInGrid: Scalars['Boolean'];
  /** A list of predefined attribute choices available for selection. Available only for attributes with predefined choices. */
  choices: Maybe<AttributeValueCountableConnection>;
  /** The entity type which can be used as a reference. */
  entityType: Maybe<AttributeEntityTypeEnum>;
  /** External ID of this attribute. */
  externalReference: Maybe<Scalars['String']>;
  /** Whether the attribute can be filtered in dashboard. Requires one of the following permissions: MANAGE_PAGES, MANAGE_PAGE_TYPES_AND_ATTRIBUTES, MANAGE_PRODUCTS, MANAGE_PRODUCT_TYPES_AND_ATTRIBUTES. */
  filterableInDashboard: Scalars['Boolean'];
  /**
   * Whether the attribute can be filtered in storefront. Requires one of the following permissions: MANAGE_PAGES, MANAGE_PAGE_TYPES_AND_ATTRIBUTES, MANAGE_PRODUCTS, MANAGE_PRODUCT_TYPES_AND_ATTRIBUTES.
   * @deprecated Field no longer supported
   */
  filterableInStorefront: Scalars['Boolean'];
  /** The ID of the attribute. */
  id: Scalars['ID'];
  /** The input type to use for entering attribute values in the dashboard. */
  inputType: Maybe<AttributeInputTypeEnum>;
  /** List of public metadata items. Can be accessed without permissions. */
  metadata: Array<MetadataItem>;
  /**
   * A single key from public metadata.
   *
   * Tip: Use GraphQL aliases to fetch multiple keys.
   */
  metafield: Maybe<Scalars['String']>;
  /** Public metadata. Use `keys` to control which fields you want to include. The default is to include everything. */
  metafields: Maybe<Scalars['Metadata']>;
  /** Name of an attribute displayed in the interface. */
  name: Maybe<Scalars['String']>;
  /** List of private metadata items. Requires staff permissions to access. */
  privateMetadata: Array<MetadataItem>;
  /**
   * A single key from private metadata. Requires staff permissions to access.
   *
   * Tip: Use GraphQL aliases to fetch multiple keys.
   */
  privateMetafield: Maybe<Scalars['String']>;
  /** Private metadata. Requires staff permissions to access. Use `keys` to control which fields you want to include. The default is to include everything. */
  privateMetafields: Maybe<Scalars['Metadata']>;
  /** A list of product types that use this attribute as a product attribute. */
  productTypes: ProductTypeCountableConnection;
  /** A list of product types that use this attribute as a product variant attribute. */
  productVariantTypes: ProductTypeCountableConnection;
  /**
   * The reference types (product or page type) that are used to narrow down the choices of reference objects.
   *
   * Added in Saleor 3.22.
   */
  referenceTypes: Maybe<Array<ReferenceType>>;
  /** Internal representation of an attribute name. */
  slug: Maybe<Scalars['String']>;
  /**
   * The position of the attribute in the storefront navigation (0 by default). Requires one of the following permissions: MANAGE_PAGES, MANAGE_PAGE_TYPES_AND_ATTRIBUTES, MANAGE_PRODUCTS, MANAGE_PRODUCT_TYPES_AND_ATTRIBUTES.
   * @deprecated Field no longer supported
   */
  storefrontSearchPosition: Scalars['Int'];
  /** Returns translated attribute fields for the given language code. */
  translation: Maybe<AttributeTranslation>;
  /** The attribute type. */
  type: Maybe<AttributeTypeEnum>;
  /** The unit of attribute values. */
  unit: Maybe<MeasurementUnitsEnum>;
  /** Whether the attribute requires values to be passed or not. Requires one of the following permissions: MANAGE_PAGES, MANAGE_PAGE_TYPES_AND_ATTRIBUTES, MANAGE_PRODUCTS, MANAGE_PRODUCT_TYPES_AND_ATTRIBUTES. */
  valueRequired: Scalars['Boolean'];
  /** Whether the attribute should be visible or not in storefront. Requires one of the following permissions: MANAGE_PAGES, MANAGE_PAGE_TYPES_AND_ATTRIBUTES, MANAGE_PRODUCTS, MANAGE_PRODUCT_TYPES_AND_ATTRIBUTES. */
  visibleInStorefront: Scalars['Boolean'];
  /** Flag indicating that attribute has predefined choices. */
  withChoices: Scalars['Boolean'];
};


/** Custom attribute of a product. Attributes can be assigned to products and variants at the product type level. */
export type AttributeChoicesArgs = {
  after: InputMaybe<Scalars['String']>;
  before: InputMaybe<Scalars['String']>;
  filter: InputMaybe<AttributeValueFilterInput>;
  first: InputMaybe<Scalars['Int']>;
  last: InputMaybe<Scalars['Int']>;
  search: InputMaybe<Scalars['String']>;
  sortBy: InputMaybe<AttributeChoicesSortingInput>;
  where: InputMaybe<AttributeValueWhereInput>;
};


/** Custom attribute of a product. Attributes can be assigned to products and variants at the product type level. */
export type AttributeMetafieldArgs = {
  key: Scalars['String'];
};


/** Custom attribute of a product. Attributes can be assigned to products and variants at the product type level. */
export type AttributeMetafieldsArgs = {
  keys: InputMaybe<Array<Scalars['String']>>;
};


/** Custom attribute of a product. Attributes can be assigned to products and variants at the product type level. */
export type AttributePrivateMetafieldArgs = {
  key: Scalars['String'];
};


/** Custom attribute of a product. Attributes can be assigned to products and variants at the product type level. */
export type AttributePrivateMetafieldsArgs = {
  keys: InputMaybe<Array<Scalars['String']>>;
};


/** Custom attribute of a product. Attributes can be assigned to products and variants at the product type level. */
export type AttributeProductTypesArgs = {
  after: InputMaybe<Scalars['String']>;
  before: InputMaybe<Scalars['String']>;
  first: InputMaybe<Scalars['Int']>;
  last: InputMaybe<Scalars['Int']>;
};


/** Custom attribute of a product. Attributes can be assigned to products and variants at the product type level. */
export type AttributeProductVariantTypesArgs = {
  after: InputMaybe<Scalars['String']>;
  before: InputMaybe<Scalars['String']>;
  first: InputMaybe<Scalars['Int']>;
  last: InputMaybe<Scalars['Int']>;
};


/** Custom attribute of a product. Attributes can be assigned to products and variants at the product type level. */
export type AttributeReferenceTypesArgs = {
  limit?: InputMaybe<Scalars['PositiveInt']>;
};


/** Custom attribute of a product. Attributes can be assigned to products and variants at the product type level. */
export type AttributeTranslationArgs = {
  languageCode: LanguageCodeEnum;
};

/**
 * Creates attributes.
 *
 * Triggers the following webhook events:
 * - ATTRIBUTE_CREATED (async): An attribute was created.
 */
export type AttributeBulkCreate = {
  __typename: 'AttributeBulkCreate';
  /** Returns how many objects were created. */
  count: Scalars['Int'];
  errors: Array<AttributeBulkCreateError>;
  /** List of the created attributes. */
  results: Array<AttributeBulkCreateResult>;
};

export type AttributeBulkCreateError = {
  __typename: 'AttributeBulkCreateError';
  /** The error code. */
  code: AttributeBulkCreateErrorCode;
  /** The error message. */
  message: Maybe<Scalars['String']>;
  /** Path to field that caused the error. A value of `null` indicates that the error isn't associated with a particular field. */
  path: Maybe<Scalars['String']>;
};

export type AttributeBulkCreateErrorCode =
  | 'ALREADY_EXISTS'
  | 'BLANK'
  | 'DUPLICATED_INPUT_ITEM'
  | 'GRAPHQL_ERROR'
  | 'INVALID'
  | 'MAX_LENGTH'
  | 'NOT_FOUND'
  | 'REQUIRED'
  | 'UNIQUE';

export type AttributeBulkCreateResult = {
  __typename: 'AttributeBulkCreateResult';
  /** Attribute data. */
  attribute: Maybe<Attribute>;
  /** List of errors occurred on create attempt. */
  errors: Maybe<Array<AttributeBulkCreateError>>;
};

/**
 * Deletes attributes.
 *
 * Requires one of the following permissions: MANAGE_PAGE_TYPES_AND_ATTRIBUTES.
 *
 * Triggers the following webhook events:
 * - ATTRIBUTE_DELETED (async): An attribute was deleted.
 */
export type AttributeBulkDelete = {
  __typename: 'AttributeBulkDelete';
  /** @deprecated Use `errors` field instead. */
  attributeErrors: Array<AttributeError>;
  /** Returns how many objects were affected. */
  count: Scalars['Int'];
  errors: Array<AttributeError>;
};

/**
 * Creates/updates translations for attributes.
 *
 * Requires one of the following permissions: MANAGE_TRANSLATIONS.
 */
export type AttributeBulkTranslate = {
  __typename: 'AttributeBulkTranslate';
  /** Returns how many translations were created/updated. */
  count: Scalars['Int'];
  errors: Array<AttributeBulkTranslateError>;
  /** List of the translations. */
  results: Array<AttributeBulkTranslateResult>;
};

export type AttributeBulkTranslateError = {
  __typename: 'AttributeBulkTranslateError';
  /** The error code. */
  code: AttributeTranslateErrorCode;
  /** The error message. */
  message: Maybe<Scalars['String']>;
  /** Path to field that caused the error. A value of `null` indicates that the error isn't associated with a particular field. */
  path: Maybe<Scalars['String']>;
};

export type AttributeBulkTranslateInput = {
  /** External reference of an attribute. */
  externalReference: InputMaybe<Scalars['String']>;
  /** Attribute ID. */
  id: InputMaybe<Scalars['ID']>;
  /** Translation language code. */
  languageCode: LanguageCodeEnum;
  /** Translation fields. */
  translationFields: NameTranslationInput;
};

export type AttributeBulkTranslateResult = {
  __typename: 'AttributeBulkTranslateResult';
  /** List of errors occurred on translation attempt. */
  errors: Maybe<Array<AttributeBulkTranslateError>>;
  /** Attribute translation data. */
  translation: Maybe<AttributeTranslation>;
};

/**
 * Updates attributes.
 *
 * Triggers the following webhook events:
 * - ATTRIBUTE_UPDATED (async): An attribute was updated. Optionally called when new attribute value was created or deleted.
 * - ATTRIBUTE_VALUE_CREATED (async): Called optionally when an attribute value was created.
 * - ATTRIBUTE_VALUE_DELETED (async): Called optionally when an attribute value was deleted.
 */
export type AttributeBulkUpdate = {
  __typename: 'AttributeBulkUpdate';
  /** Returns how many objects were updated. */
  count: Scalars['Int'];
  errors: Array<AttributeBulkUpdateError>;
  /** List of the updated attributes. */
  results: Array<AttributeBulkUpdateResult>;
};

export type AttributeBulkUpdateError = {
  __typename: 'AttributeBulkUpdateError';
  /** The error code. */
  code: AttributeBulkUpdateErrorCode;
  /** The error message. */
  message: Maybe<Scalars['String']>;
  /** Path to field that caused the error. A value of `null` indicates that the error isn't associated with a particular field. */
  path: Maybe<Scalars['String']>;
};

export type AttributeBulkUpdateErrorCode =
  | 'ALREADY_EXISTS'
  | 'BLANK'
  | 'DUPLICATED_INPUT_ITEM'
  | 'GRAPHQL_ERROR'
  | 'INVALID'
  | 'MAX_LENGTH'
  | 'NOT_FOUND'
  | 'REQUIRED'
  | 'UNIQUE';

export type AttributeBulkUpdateInput = {
  /** External ID of this attribute. */
  externalReference: InputMaybe<Scalars['String']>;
  /** Fields to update. */
  fields: AttributeUpdateInput;
  /** ID of an attribute to update. */
  id: InputMaybe<Scalars['ID']>;
};

export type AttributeBulkUpdateResult = {
  __typename: 'AttributeBulkUpdateResult';
  /** Attribute data. */
  attribute: Maybe<Attribute>;
  /** List of errors occurred on update attempt. */
  errors: Maybe<Array<AttributeBulkUpdateError>>;
};

export type AttributeChoicesSortField =
  /** Sort attribute choice by name. */
  | 'NAME'
  /** Sort attribute choice by slug. */
  | 'SLUG';

export type AttributeChoicesSortingInput = {
  /** Specifies the direction in which to sort attribute choices. */
  direction: OrderDirection;
  /** Sort attribute choices by the selected field. */
  field: AttributeChoicesSortField;
};

export type AttributeCountableConnection = {
  __typename: 'AttributeCountableConnection';
  edges: Array<AttributeCountableEdge>;
  /** Pagination data for this connection. */
  pageInfo: PageInfo;
  /** A total count of items in the collection. */
  totalCount: Maybe<Scalars['Int']>;
};

export type AttributeCountableEdge = {
  __typename: 'AttributeCountableEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node: Attribute;
};

/**
 * Creates an attribute.
 *
 * Triggers the following webhook events:
 * - ATTRIBUTE_CREATED (async): An attribute was created.
 */
export type AttributeCreate = {
  __typename: 'AttributeCreate';
  /** The created attribute. */
  attribute: Maybe<Attribute>;
  /** @deprecated Use `errors` field instead. */
  attributeErrors: Array<AttributeError>;
  errors: Array<AttributeError>;
};

/**
 * Represents an input for create of attribute.
 *
 * NOTE: Deprecated fields `filterableInStorefront`, `storefrontSearchPosition` and `availableInGrid` are not supported in bulk mutations: `attributeBulkCreate`, `attributeBulkUpdate`.
 */
export type AttributeCreateInput = {
  /**
   * Whether the attribute can be displayed in the admin product list.
   * @deprecated Field no longer supported
   */
  availableInGrid: InputMaybe<Scalars['Boolean']>;
  /** The entity type which can be used as a reference. */
  entityType: InputMaybe<AttributeEntityTypeEnum>;
  /** External ID of this attribute. */
  externalReference: InputMaybe<Scalars['String']>;
  /** Whether the attribute can be filtered in dashboard. */
  filterableInDashboard: InputMaybe<Scalars['Boolean']>;
  /**
   * Whether the attribute can be filtered in storefront.
   * @deprecated Field no longer supported
   */
  filterableInStorefront: InputMaybe<Scalars['Boolean']>;
  /** The input type to use for entering attribute values in the dashboard. */
  inputType: InputMaybe<AttributeInputTypeEnum>;
  /** Whether the attribute is for variants only. */
  isVariantOnly: InputMaybe<Scalars['Boolean']>;
  /** Name of an attribute displayed in the interface. */
  name: Scalars['String'];
  /**
   * Specifies reference types to narrow down the choices of reference objects. Applicable only for `REFERENCE` and `SINGLE_REFERENCE` attributes with `PRODUCT`, `PRODUCT_VARIANT` and `PAGE` entity types. Accepts `ProductType` IDs for `PRODUCT` and `PRODUCT_VARIANT` entity types, and `PageType` IDs for `PAGE` entity type. If omitted, all objects of the selected entity type are available as attribute values.
   *
   * A maximum of 100 reference types can be specified.
   *
   * Added in Saleor 3.22.
   */
  referenceTypes: InputMaybe<Array<Scalars['ID']>>;
  /** Internal representation of an attribute name. */
  slug: InputMaybe<Scalars['String']>;
  /**
   * The position of the attribute in the storefront navigation (0 by default).
   * @deprecated Field no longer supported
   */
  storefrontSearchPosition: InputMaybe<Scalars['Int']>;
  /** The attribute type. */
  type: AttributeTypeEnum;
  /** The unit of attribute values. */
  unit: InputMaybe<MeasurementUnitsEnum>;
  /** Whether the attribute requires values to be passed or not. */
  valueRequired: InputMaybe<Scalars['Boolean']>;
  /** List of attribute's values. */
  values: InputMaybe<Array<AttributeValueCreateInput>>;
  /** Whether the attribute should be visible or not in storefront. */
  visibleInStorefront: InputMaybe<Scalars['Boolean']>;
};

/** Event sent when new attribute is created. */
export type AttributeCreated = Event & {
  __typename: 'AttributeCreated';
  /** The attribute the event relates to. */
  attribute: Maybe<Attribute>;
  /** Time of the event. */
  issuedAt: Maybe<Scalars['DateTime']>;
  /** The user or application that triggered the event. */
  issuingPrincipal: Maybe<IssuingPrincipal>;
  /** The application receiving the webhook. */
  recipient: Maybe<App>;
  /** Saleor version that triggered the event. */
  version: Maybe<Scalars['String']>;
};

/**
 * Deletes an attribute.
 *
 * Requires one of the following permissions: MANAGE_PRODUCT_TYPES_AND_ATTRIBUTES.
 *
 * Triggers the following webhook events:
 * - ATTRIBUTE_DELETED (async): An attribute was deleted.
 */
export type AttributeDelete = {
  __typename: 'AttributeDelete';
  attribute: Maybe<Attribute>;
  /** @deprecated Use `errors` field instead. */
  attributeErrors: Array<AttributeError>;
  errors: Array<AttributeError>;
};

/** Event sent when attribute is deleted. */
export type AttributeDeleted = Event & {
  __typename: 'AttributeDeleted';
  /** The attribute the event relates to. */
  attribute: Maybe<Attribute>;
  /** Time of the event. */
  issuedAt: Maybe<Scalars['DateTime']>;
  /** The user or application that triggered the event. */
  issuingPrincipal: Maybe<IssuingPrincipal>;
  /** The application receiving the webhook. */
  recipient: Maybe<App>;
  /** Saleor version that triggered the event. */
  version: Maybe<Scalars['String']>;
};

export type AttributeEntityTypeEnum =
  | 'CATEGORY'
  | 'COLLECTION'
  | 'PAGE'
  | 'PRODUCT'
  | 'PRODUCT_VARIANT';

export type AttributeEntityTypeEnumFilterInput = {
  /** The value equal to. */
  eq: InputMaybe<AttributeEntityTypeEnum>;
  /** The value included in. */
  oneOf: InputMaybe<Array<AttributeEntityTypeEnum>>;
};

export type AttributeError = {
  __typename: 'AttributeError';
  /** The error code. */
  code: AttributeErrorCode;
  /** Name of a field that caused the error. A value of `null` indicates that the error isn't associated with a particular field. */
  field: Maybe<Scalars['String']>;
  /** The error message. */
  message: Maybe<Scalars['String']>;
};

export type AttributeErrorCode =
  | 'ALREADY_EXISTS'
  | 'GRAPHQL_ERROR'
  | 'INVALID'
  | 'NOT_FOUND'
  | 'REQUIRED'
  | 'UNIQUE';

export type AttributeFilterInput = {
  availableInGrid: InputMaybe<Scalars['Boolean']>;
  /**
   * Specifies the channel by which the data should be filtered.
   * @deprecated Use root-level channel argument instead.
   */
  channel: InputMaybe<Scalars['String']>;
  filterableInDashboard: InputMaybe<Scalars['Boolean']>;
  filterableInStorefront: InputMaybe<Scalars['Boolean']>;
  ids: InputMaybe<Array<Scalars['ID']>>;
  inCategory: InputMaybe<Scalars['ID']>;
  inCollection: InputMaybe<Scalars['ID']>;
  isVariantOnly: InputMaybe<Scalars['Boolean']>;
  metadata: InputMaybe<Array<MetadataFilter>>;
  search: InputMaybe<Scalars['String']>;
  slugs: InputMaybe<Array<Scalars['String']>>;
  type: InputMaybe<AttributeTypeEnum>;
  valueRequired: InputMaybe<Scalars['Boolean']>;
  visibleInStorefront: InputMaybe<Scalars['Boolean']>;
};

export type AttributeInput = {
  /**
   * The boolean value of the attribute. Requires `slug` to be provided.
   * @deprecated Use `value` instead.
   */
  boolean: InputMaybe<Scalars['Boolean']>;
  /**
   * The date range that the returned values should be in. In case of date/time attributes, the UTC midnight of the given date is used. Requires `slug` to be provided.
   * @deprecated Use `value` instead.
   */
  date: InputMaybe<DateRangeInput>;
  /**
   * The date/time range that the returned values should be in. Requires `slug` to be provided.
   * @deprecated Use `value` instead.
   */
  dateTime: InputMaybe<DateTimeRangeInput>;
  /** Internal representation of an attribute name. */
  slug: InputMaybe<Scalars['String']>;
  /** Filter by value of the attribute. Only one value input field is allowed. If provided more than one, the error will be raised. Cannot be combined with deprecated fields of `AttributeInput`. */
  value: InputMaybe<AssignedAttributeValueInput>;
  /**
   * Slugs identifying the attributeValues associated with the Attribute. When specified, it filters the results to include only records with one of the matching values. Requires `slug` to be provided.
   * @deprecated Use `value` instead.
   */
  values: InputMaybe<Array<Scalars['String']>>;
  /**
   * The range that the returned values should be in. Requires `slug` to be provided.
   * @deprecated Use `value` instead.
   */
  valuesRange: InputMaybe<IntRangeInput>;
};

export type AttributeInputTypeEnum =
  | 'BOOLEAN'
  | 'DATE'
  | 'DATE_TIME'
  | 'DROPDOWN'
  | 'FILE'
  | 'MULTISELECT'
  | 'NUMERIC'
  | 'PLAIN_TEXT'
  | 'REFERENCE'
  | 'RICH_TEXT'
  | 'SINGLE_REFERENCE'
  | 'SWATCH';

export type AttributeInputTypeEnumFilterInput = {
  /** The value equal to. */
  eq: InputMaybe<AttributeInputTypeEnum>;
  /** The value included in. */
  oneOf: InputMaybe<Array<AttributeInputTypeEnum>>;
};

/**
 * Reorder the values of an attribute.
 *
 * Requires one of the following permissions: MANAGE_PRODUCT_TYPES_AND_ATTRIBUTES.
 *
 * Triggers the following webhook events:
 * - ATTRIBUTE_VALUE_UPDATED (async): An attribute value was updated.
 * - ATTRIBUTE_UPDATED (async): An attribute was updated.
 */
export type AttributeReorderValues = {
  __typename: 'AttributeReorderValues';
  /** Attribute from which values are reordered. */
  attribute: Maybe<Attribute>;
  /** @deprecated Use `errors` field instead. */
  attributeErrors: Array<AttributeError>;
  errors: Array<AttributeError>;
};

export type AttributeSortField =
  /** Sort attributes based on whether they can be displayed or not in a product grid. */
  | 'AVAILABLE_IN_GRID'
  /** Sort attributes by the filterable in dashboard flag */
  | 'FILTERABLE_IN_DASHBOARD'
  /** Sort attributes by the filterable in storefront flag */
  | 'FILTERABLE_IN_STOREFRONT'
  /** Sort attributes by the variant only flag */
  | 'IS_VARIANT_ONLY'
  /** Sort attributes by name */
  | 'NAME'
  /** Sort attributes by slug */
  | 'SLUG'
  /** Sort attributes by their position in storefront */
  | 'STOREFRONT_SEARCH_POSITION'
  /** Sort attributes by the value required flag */
  | 'VALUE_REQUIRED'
  /** Sort attributes by visibility in the storefront */
  | 'VISIBLE_IN_STOREFRONT';

export type AttributeSortingInput = {
  /** Specifies the direction in which to sort attributes. */
  direction: OrderDirection;
  /** Sort attributes by the selected field. */
  field: AttributeSortField;
};

/** Represents attribute's original translatable fields and related translations. */
export type AttributeTranslatableContent = Node & {
  __typename: 'AttributeTranslatableContent';
  /**
   * Custom attribute of a product.
   * @deprecated Get model fields from the root level queries.
   */
  attribute: Maybe<Attribute>;
  /** The ID of the attribute to translate. */
  attributeId: Scalars['ID'];
  /** The ID of the attribute translatable content. */
  id: Scalars['ID'];
  /** Name of the attribute to translate. */
  name: Scalars['String'];
  /** Returns translated attribute fields for the given language code. */
  translation: Maybe<AttributeTranslation>;
};


/** Represents attribute's original translatable fields and related translations. */
export type AttributeTranslatableContentTranslationArgs = {
  languageCode: LanguageCodeEnum;
};

/**
 * Creates/updates translations for an attribute.
 *
 * Requires one of the following permissions: MANAGE_TRANSLATIONS.
 */
export type AttributeTranslate = {
  __typename: 'AttributeTranslate';
  attribute: Maybe<Attribute>;
  errors: Array<TranslationError>;
  /** @deprecated Use `errors` field instead. */
  translationErrors: Array<TranslationError>;
};

export type AttributeTranslateErrorCode =
  | 'GRAPHQL_ERROR'
  | 'INVALID'
  | 'NOT_FOUND'
  | 'REQUIRED';

/** Represents attribute translations. */
export type AttributeTranslation = Node & {
  __typename: 'AttributeTranslation';
  /** The ID of the attribute translation. */
  id: Scalars['ID'];
  /** Translation language. */
  language: LanguageDisplay;
  /** Translated attribute name. */
  name: Scalars['String'];
  /** Represents the attribute fields to translate. */
  translatableContent: Maybe<AttributeTranslatableContent>;
};

export type AttributeTypeEnum =
  | 'PAGE_TYPE'
  | 'PRODUCT_TYPE';

export type AttributeTypeEnumFilterInput = {
  /** The value equal to. */
  eq: InputMaybe<AttributeTypeEnum>;
  /** The value included in. */
  oneOf: InputMaybe<Array<AttributeTypeEnum>>;
};

/**
 * Updates attribute.
 *
 * Requires one of the following permissions: MANAGE_PRODUCT_TYPES_AND_ATTRIBUTES.
 *
 * Triggers the following webhook events:
 * - ATTRIBUTE_UPDATED (async): An attribute was updated.
 */
export type AttributeUpdate = {
  __typename: 'AttributeUpdate';
  /** The updated attribute. */
  attribute: Maybe<Attribute>;
  /** @deprecated Use `errors` field instead. */
  attributeErrors: Array<AttributeError>;
  errors: Array<AttributeError>;
};

/**
 * Represents an input for update of attribute.
 *
 * NOTE: Deprecated fields `filterableInStorefront`, `storefrontSearchPosition` and `availableInGrid` are not supported in bulk mutations: `attributeBulkCreate`, `attributeBulkUpdate`.
 */
export type AttributeUpdateInput = {
  /** New values to be created for this attribute. */
  addValues: InputMaybe<Array<AttributeValueUpdateInput>>;
  /**
   * Whether the attribute can be displayed in the admin product list.
   * @deprecated Field no longer supported
   */
  availableInGrid: InputMaybe<Scalars['Boolean']>;
  /** External ID of this product. */
  externalReference: InputMaybe<Scalars['String']>;
  /** Whether the attribute can be filtered in dashboard. */
  filterableInDashboard: InputMaybe<Scalars['Boolean']>;
  /**
   * Whether the attribute can be filtered in storefront.
   * @deprecated Field no longer supported
   */
  filterableInStorefront: InputMaybe<Scalars['Boolean']>;
  /** Whether the attribute is for variants only. */
  isVariantOnly: InputMaybe<Scalars['Boolean']>;
  /** Name of an attribute displayed in the interface. */
  name: InputMaybe<Scalars['String']>;
  /**
   * Specifies reference types to narrow down the choices of reference objects. Applicable only for `REFERENCE` and `SINGLE_REFERENCE` attributes with `PRODUCT`, `PRODUCT_VARIANT` and `PAGE` entity types. Accepts `ProductType` IDs for `PRODUCT` and `PRODUCT_VARIANT` entity types, and `PageType` IDs for `PAGE` entity type. If omitted, all objects of the selected entity type are available as attribute values.
   *
   * A maximum of 100 reference types can be specified.
   *
   * Added in Saleor 3.22.
   */
  referenceTypes: InputMaybe<Array<Scalars['ID']>>;
  /** IDs of values to be removed from this attribute. */
  removeValues: InputMaybe<Array<Scalars['ID']>>;
  /** Internal representation of an attribute name. */
  slug: InputMaybe<Scalars['String']>;
  /**
   * The position of the attribute in the storefront navigation (0 by default).
   * @deprecated Field no longer supported
   */
  storefrontSearchPosition: InputMaybe<Scalars['Int']>;
  /** The unit of attribute values. */
  unit: InputMaybe<MeasurementUnitsEnum>;
  /** Whether the attribute requires values to be passed or not. */
  valueRequired: InputMaybe<Scalars['Boolean']>;
  /** Whether the attribute should be visible or not in storefront. */
  visibleInStorefront: InputMaybe<Scalars['Boolean']>;
};

/** Event sent when attribute is updated. */
export type AttributeUpdated = Event & {
  __typename: 'AttributeUpdated';
  /** The attribute the event relates to. */
  attribute: Maybe<Attribute>;
  /** Time of the event. */
  issuedAt: Maybe<Scalars['DateTime']>;
  /** The user or application that triggered the event. */
  issuingPrincipal: Maybe<IssuingPrincipal>;
  /** The application receiving the webhook. */
  recipient: Maybe<App>;
  /** Saleor version that triggered the event. */
  version: Maybe<Scalars['String']>;
};

/** Represents a value of an attribute. */
export type AttributeValue = Node & {
  __typename: 'AttributeValue';
  /** Represents the boolean value of the attribute value. */
  boolean: Maybe<Scalars['Boolean']>;
  /** Represents the date value of the attribute value. */
  date: Maybe<Scalars['Date']>;
  /** Represents the date/time value of the attribute value. */
  dateTime: Maybe<Scalars['DateTime']>;
  /** External ID of this attribute value. */
  externalReference: Maybe<Scalars['String']>;
  /** Represents file URL and content type (if attribute value is a file). */
  file: Maybe<File>;
  /** The ID of the attribute value. */
  id: Scalars['ID'];
  /** The input type to use for entering attribute values in the dashboard. */
  inputType: Maybe<AttributeInputTypeEnum>;
  /** Name of a value displayed in the interface. */
  name: Maybe<Scalars['String']>;
  /** Represents the text of the attribute value, plain text without formatting. */
  plainText: Maybe<Scalars['String']>;
  /** The ID of the referenced object. */
  reference: Maybe<Scalars['ID']>;
  /**
   * Represents the text of the attribute value, includes formatting.
   *
   * Rich text format. For reference see https://editorjs.io/
   */
  richText: Maybe<Scalars['JSONString']>;
  /** Internal representation of a value (unique per attribute). */
  slug: Maybe<Scalars['String']>;
  /** Returns translated attribute value fields for the given language code. */
  translation: Maybe<AttributeValueTranslation>;
  /** Represent value of the attribute value (e.g. color values for swatch attributes). */
  value: Maybe<Scalars['String']>;
};


/** Represents a value of an attribute. */
export type AttributeValueTranslationArgs = {
  languageCode: LanguageCodeEnum;
};

/**
 * Deletes values of attributes.
 *
 * Requires one of the following permissions: MANAGE_PAGE_TYPES_AND_ATTRIBUTES.
 *
 * Triggers the following webhook events:
 * - ATTRIBUTE_VALUE_DELETED (async): An attribute value was deleted.
 * - ATTRIBUTE_UPDATED (async): An attribute was updated.
 */
export type AttributeValueBulkDelete = {
  __typename: 'AttributeValueBulkDelete';
  /** @deprecated Use `errors` field instead. */
  attributeErrors: Array<AttributeError>;
  /** Returns how many objects were affected. */
  count: Scalars['Int'];
  errors: Array<AttributeError>;
};

/**
 * Creates/updates translations for attribute values.
 *
 * Requires one of the following permissions: MANAGE_TRANSLATIONS.
 */
export type AttributeValueBulkTranslate = {
  __typename: 'AttributeValueBulkTranslate';
  /** Returns how many translations were created/updated. */
  count: Scalars['Int'];
  errors: Array<AttributeValueBulkTranslateError>;
  /** List of the translations. */
  results: Array<AttributeValueBulkTranslateResult>;
};

export type AttributeValueBulkTranslateError = {
  __typename: 'AttributeValueBulkTranslateError';
  /** The error code. */
  code: AttributeValueTranslateErrorCode;
  /** The error message. */
  message: Maybe<Scalars['String']>;
  /** Path to field that caused the error. A value of `null` indicates that the error isn't associated with a particular field. */
  path: Maybe<Scalars['String']>;
};

export type AttributeValueBulkTranslateInput = {
  /** External reference of an attribute value. */
  externalReference: InputMaybe<Scalars['String']>;
  /** Attribute value ID. */
  id: InputMaybe<Scalars['ID']>;
  /** Translation language code. */
  languageCode: LanguageCodeEnum;
  /** Translation fields. */
  translationFields: AttributeValueTranslationInput;
};

export type AttributeValueBulkTranslateResult = {
  __typename: 'AttributeValueBulkTranslateResult';
  /** List of errors occurred on translation attempt. */
  errors: Maybe<Array<AttributeValueBulkTranslateError>>;
  /** Attribute value translation data. */
  translation: Maybe<AttributeValueTranslation>;
};

export type AttributeValueCountableConnection = {
  __typename: 'AttributeValueCountableConnection';
  edges: Array<AttributeValueCountableEdge>;
  /** Pagination data for this connection. */
  pageInfo: PageInfo;
  /** A total count of items in the collection. */
  totalCount: Maybe<Scalars['Int']>;
};

export type AttributeValueCountableEdge = {
  __typename: 'AttributeValueCountableEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node: AttributeValue;
};

/**
 * Creates a value for an attribute.
 *
 * Requires one of the following permissions: MANAGE_PRODUCTS.
 *
 * Triggers the following webhook events:
 * - ATTRIBUTE_VALUE_CREATED (async): An attribute value was created.
 * - ATTRIBUTE_UPDATED (async): An attribute was updated.
 */
export type AttributeValueCreate = {
  __typename: 'AttributeValueCreate';
  /** The updated attribute. */
  attribute: Maybe<Attribute>;
  /** @deprecated Use `errors` field instead. */
  attributeErrors: Array<AttributeError>;
  attributeValue: Maybe<AttributeValue>;
  errors: Array<AttributeError>;
};

export type AttributeValueCreateInput = {
  /** File content type. */
  contentType: InputMaybe<Scalars['String']>;
  /** External ID of this attribute value. */
  externalReference: InputMaybe<Scalars['String']>;
  /** URL of the file attribute. Every time, a new value is created. */
  fileUrl: InputMaybe<Scalars['String']>;
  /** Name of a value displayed in the interface. */
  name: Scalars['String'];
  /**
   * Represents the text of the attribute value, plain text without formatting.
   * @deprecated The plain text attribute hasn't got predefined value, so can be specified only from instance that supports the given attribute.
   */
  plainText: InputMaybe<Scalars['String']>;
  /**
   * Represents the text of the attribute value, includes formatting.
   *
   * Rich text format. For reference see https://editorjs.io/
   * @deprecated The rich text attribute hasn't got predefined value, so can be specified only from instance that supports the given attribute.
   */
  richText: InputMaybe<Scalars['JSONString']>;
  /** Represent value of the attribute value (e.g. color values for swatch attributes). */
  value: InputMaybe<Scalars['String']>;
};

/** Event sent when new attribute value is created. */
export type AttributeValueCreated = Event & {
  __typename: 'AttributeValueCreated';
  /** The attribute value the event relates to. */
  attributeValue: Maybe<AttributeValue>;
  /** Time of the event. */
  issuedAt: Maybe<Scalars['DateTime']>;
  /** The user or application that triggered the event. */
  issuingPrincipal: Maybe<IssuingPrincipal>;
  /** The application receiving the webhook. */
  recipient: Maybe<App>;
  /** Saleor version that triggered the event. */
  version: Maybe<Scalars['String']>;
};

/**
 * Deletes a value of an attribute.
 *
 * Requires one of the following permissions: MANAGE_PRODUCT_TYPES_AND_ATTRIBUTES.
 *
 * Triggers the following webhook events:
 * - ATTRIBUTE_VALUE_DELETED (async): An attribute value was deleted.
 * - ATTRIBUTE_UPDATED (async): An attribute was updated.
 */
export type AttributeValueDelete = {
  __typename: 'AttributeValueDelete';
  /** The updated attribute. */
  attribute: Maybe<Attribute>;
  /** @deprecated Use `errors` field instead. */
  attributeErrors: Array<AttributeError>;
  attributeValue: Maybe<AttributeValue>;
  errors: Array<AttributeError>;
};

/** Event sent when attribute value is deleted. */
export type AttributeValueDeleted = Event & {
  __typename: 'AttributeValueDeleted';
  /** The attribute value the event relates to. */
  attributeValue: Maybe<AttributeValue>;
  /** Time of the event. */
  issuedAt: Maybe<Scalars['DateTime']>;
  /** The user or application that triggered the event. */
  issuingPrincipal: Maybe<IssuingPrincipal>;
  /** The application receiving the webhook. */
  recipient: Maybe<App>;
  /** Saleor version that triggered the event. */
  version: Maybe<Scalars['String']>;
};

export type AttributeValueFilterInput = {
  ids: InputMaybe<Array<Scalars['ID']>>;
  search: InputMaybe<Scalars['String']>;
  slugs: InputMaybe<Array<Scalars['String']>>;
};

export type AttributeValueInput = {
  /** Represents the boolean value of the attribute value. */
  boolean: InputMaybe<Scalars['Boolean']>;
  /** File content type. */
  contentType: InputMaybe<Scalars['String']>;
  /** Represents the date value of the attribute value. */
  date: InputMaybe<Scalars['Date']>;
  /** Represents the date/time value of the attribute value. */
  dateTime: InputMaybe<Scalars['DateTime']>;
  /** Attribute value ID or external reference. */
  dropdown: InputMaybe<AttributeValueSelectableTypeInput>;
  /** External ID of this attribute. */
  externalReference: InputMaybe<Scalars['String']>;
  /** URL of the file attribute. Every time, a new value is created. */
  file: InputMaybe<Scalars['String']>;
  /** ID of the selected attribute. */
  id: InputMaybe<Scalars['ID']>;
  /** List of attribute value IDs or external references. */
  multiselect: InputMaybe<Array<AttributeValueSelectableTypeInput>>;
  /** Numeric value of an attribute. */
  numeric: InputMaybe<Scalars['String']>;
  /** Plain text content. */
  plainText: InputMaybe<Scalars['String']>;
  /**
   * ID of the referenced entity for single reference attribute.
   *
   * Added in Saleor 3.22.
   */
  reference: InputMaybe<Scalars['ID']>;
  /** List of entity IDs that will be used as references. */
  references: InputMaybe<Array<Scalars['ID']>>;
  /** Text content in JSON format. */
  richText: InputMaybe<Scalars['JSONString']>;
  /** Attribute value ID or external reference. */
  swatch: InputMaybe<AttributeValueSelectableTypeInput>;
  /**
   * The value or slug of an attribute to resolve. If the passed value is non-existent, it will be created.
   * @deprecated Field no longer supported
   */
  values: InputMaybe<Array<Scalars['String']>>;
};

/**
 * Represents attribute value.
 * 1. If ID is provided, then attribute value will be resolved by ID.
 * 2. If externalReference is provided, then attribute value will be resolved by external reference.
 * 3. If value is provided, then attribute value will be resolved by value. If this attribute value doesn't exist, then it will be created.
 * 4. If externalReference and value is provided then new attribute value will be created.
 */
export type AttributeValueSelectableTypeInput = {
  /** External reference of an attribute value. */
  externalReference: InputMaybe<Scalars['String']>;
  /** ID of an attribute value. */
  id: InputMaybe<Scalars['ID']>;
  /** The value or slug of an attribute to resolve. If the passed value is non-existent, it will be created. */
  value: InputMaybe<Scalars['String']>;
};

/** Represents attribute value's original translatable fields and related translations. */
export type AttributeValueTranslatableContent = Node & {
  __typename: 'AttributeValueTranslatableContent';
  /** Associated attribute that can be translated. */
  attribute: Maybe<AttributeTranslatableContent>;
  /**
   * Represents a value of an attribute.
   * @deprecated Get model fields from the root level queries.
   */
  attributeValue: Maybe<AttributeValue>;
  /** The ID of the attribute value to translate. */
  attributeValueId: Scalars['ID'];
  /** The ID of the attribute value translatable content. */
  id: Scalars['ID'];
  /** Name of the attribute value to translate. */
  name: Scalars['String'];
  /** Attribute plain text value. */
  plainText: Maybe<Scalars['String']>;
  /**
   * Attribute value.
   *
   * Rich text format. For reference see https://editorjs.io/
   */
  richText: Maybe<Scalars['JSONString']>;
  /** Returns translated attribute value fields for the given language code. */
  translation: Maybe<AttributeValueTranslation>;
};


/** Represents attribute value's original translatable fields and related translations. */
export type AttributeValueTranslatableContentTranslationArgs = {
  languageCode: LanguageCodeEnum;
};

/**
 * Creates/updates translations for an attribute value.
 *
 * Requires one of the following permissions: MANAGE_TRANSLATIONS.
 */
export type AttributeValueTranslate = {
  __typename: 'AttributeValueTranslate';
  attributeValue: Maybe<AttributeValue>;
  errors: Array<TranslationError>;
  /** @deprecated Use `errors` field instead. */
  translationErrors: Array<TranslationError>;
};

export type AttributeValueTranslateErrorCode =
  | 'GRAPHQL_ERROR'
  | 'INVALID'
  | 'NOT_FOUND'
  | 'REQUIRED';

/** Represents attribute value translations. */
export type AttributeValueTranslation = Node & {
  __typename: 'AttributeValueTranslation';
  /** The ID of the attribute value translation. */
  id: Scalars['ID'];
  /** Translation language. */
  language: LanguageDisplay;
  /** Translated attribute value name. */
  name: Scalars['String'];
  /** Translated plain text attribute value . */
  plainText: Maybe<Scalars['String']>;
  /**
   * Translated rich-text attribute value.
   *
   * Rich text format. For reference see https://editorjs.io/
   */
  richText: Maybe<Scalars['JSONString']>;
  /** Represents the attribute value fields to translate. */
  translatableContent: Maybe<AttributeValueTranslatableContent>;
};

export type AttributeValueTranslationInput = {
  name: InputMaybe<Scalars['String']>;
  /** Translated text. */
  plainText: InputMaybe<Scalars['String']>;
  /**
   * Translated text.
   *
   * Rich text format. For reference see https://editorjs.io/
   */
  richText: InputMaybe<Scalars['JSONString']>;
};

/**
 * Updates value of an attribute.
 *
 * Requires one of the following permissions: MANAGE_PRODUCT_TYPES_AND_ATTRIBUTES.
 *
 * Triggers the following webhook events:
 * - ATTRIBUTE_VALUE_UPDATED (async): An attribute value was updated.
 * - ATTRIBUTE_UPDATED (async): An attribute was updated.
 */
export type AttributeValueUpdate = {
  __typename: 'AttributeValueUpdate';
  /** The updated attribute. */
  attribute: Maybe<Attribute>;
  /** @deprecated Use `errors` field instead. */
  attributeErrors: Array<AttributeError>;
  attributeValue: Maybe<AttributeValue>;
  errors: Array<AttributeError>;
};

export type AttributeValueUpdateInput = {
  /** File content type. */
  contentType: InputMaybe<Scalars['String']>;
  /** External ID of this attribute value. */
  externalReference: InputMaybe<Scalars['String']>;
  /** URL of the file attribute. Every time, a new value is created. */
  fileUrl: InputMaybe<Scalars['String']>;
  /** Name of a value displayed in the interface. */
  name: InputMaybe<Scalars['String']>;
  /**
   * Represents the text of the attribute value, plain text without formatting.
   * @deprecated The plain text attribute hasn't got predefined value, so can be specified only from instance that supports the given attribute.
   */
  plainText: InputMaybe<Scalars['String']>;
  /**
   * Represents the text of the attribute value, includes formatting.
   *
   * Rich text format. For reference see https://editorjs.io/
   * @deprecated The rich text attribute hasn't got predefined value, so can be specified only from instance that supports the given attribute.
   */
  richText: InputMaybe<Scalars['JSONString']>;
  /** Represent value of the attribute value (e.g. color values for swatch attributes). */
  value: InputMaybe<Scalars['String']>;
};

/** Event sent when attribute value is updated. */
export type AttributeValueUpdated = Event & {
  __typename: 'AttributeValueUpdated';
  /** The attribute value the event relates to. */
  attributeValue: Maybe<AttributeValue>;
  /** Time of the event. */
  issuedAt: Maybe<Scalars['DateTime']>;
  /** The user or application that triggered the event. */
  issuingPrincipal: Maybe<IssuingPrincipal>;
  /** The application receiving the webhook. */
  recipient: Maybe<App>;
  /** Saleor version that triggered the event. */
  version: Maybe<Scalars['String']>;
};

/** Where filtering options for attribute values. */
export type AttributeValueWhereInput = {
  /** List of conditions that must be met. */
  AND: InputMaybe<Array<AttributeValueWhereInput>>;
  /** A list of conditions of which at least one must be met. */
  OR: InputMaybe<Array<AttributeValueWhereInput>>;
  ids: InputMaybe<Array<Scalars['ID']>>;
  name: InputMaybe<StringFilterInput>;
  slug: InputMaybe<StringFilterInput>;
};

/** Where filtering options. */
export type AttributeWhereInput = {
  /** List of conditions that must be met. */
  AND: InputMaybe<Array<AttributeWhereInput>>;
  /** A list of conditions of which at least one must be met. */
  OR: InputMaybe<Array<AttributeWhereInput>>;
  entityType: InputMaybe<AttributeEntityTypeEnumFilterInput>;
  filterableInDashboard: InputMaybe<Scalars['Boolean']>;
  ids: InputMaybe<Array<Scalars['ID']>>;
  inCategory: InputMaybe<Scalars['ID']>;
  inCollection: InputMaybe<Scalars['ID']>;
  inputType: InputMaybe<AttributeInputTypeEnumFilterInput>;
  metadata: InputMaybe<Array<MetadataFilter>>;
  name: InputMaybe<StringFilterInput>;
  slug: InputMaybe<StringFilterInput>;
  type: InputMaybe<AttributeTypeEnumFilterInput>;
  unit: InputMaybe<MeasurementUnitsEnumFilterInput>;
  valueRequired: InputMaybe<Scalars['Boolean']>;
  visibleInStorefront: InputMaybe<Scalars['Boolean']>;
  withChoices: InputMaybe<Scalars['Boolean']>;
};

export type BulkAttributeValueInput = {
  /** The boolean value of an attribute to resolve. If the passed value is non-existent, it will be created. */
  boolean: InputMaybe<Scalars['Boolean']>;
  /** File content type. */
  contentType: InputMaybe<Scalars['String']>;
  /** Represents the date value of the attribute value. */
  date: InputMaybe<Scalars['Date']>;
  /** Represents the date/time value of the attribute value. */
  dateTime: InputMaybe<Scalars['DateTime']>;
  /** Attribute value ID. */
  dropdown: InputMaybe<AttributeValueSelectableTypeInput>;
  /** External ID of this attribute. */
  externalReference: InputMaybe<Scalars['String']>;
  /** URL of the file attribute. Every time, a new value is created. */
  file: InputMaybe<Scalars['String']>;
  /** ID of the selected attribute. */
  id: InputMaybe<Scalars['ID']>;
  /** List of attribute value IDs. */
  multiselect: InputMaybe<Array<AttributeValueSelectableTypeInput>>;
  /** Numeric value of an attribute. */
  numeric: InputMaybe<Scalars['String']>;
  /** Plain text content. */
  plainText: InputMaybe<Scalars['String']>;
  /**
   * ID of the referenced entity for single reference attribute.
   *
   * Added in Saleor 3.22.
   */
  reference: InputMaybe<Scalars['ID']>;
  /** List of entity IDs that will be used as references. */
  references: InputMaybe<Array<Scalars['ID']>>;
  /** Text content in JSON format. */
  richText: InputMaybe<Scalars['JSONString']>;
  /** Attribute value ID. */
  swatch: InputMaybe<AttributeValueSelectableTypeInput>;
  /**
   * The value or slug of an attribute to resolve. If the passed value is non-existent, it will be created.
   * @deprecated Field no longer supported
   */
  values: InputMaybe<Array<Scalars['String']>>;
};

export type BulkProductError = {
  __typename: 'BulkProductError';
  /** List of attributes IDs which causes the error. */
  attributes: Maybe<Array<Scalars['ID']>>;
  /** List of channel IDs which causes the error. */
  channels: Maybe<Array<Scalars['ID']>>;
  /** The error code. */
  code: ProductErrorCode;
  /** Name of a field that caused the error. A value of `null` indicates that the error isn't associated with a particular field. */
  field: Maybe<Scalars['String']>;
  /** Index of an input list item that caused the error. */
  index: Maybe<Scalars['Int']>;
  /** The error message. */
  message: Maybe<Scalars['String']>;
  /** List of attribute values IDs which causes the error. */
  values: Maybe<Array<Scalars['ID']>>;
  /** List of warehouse IDs which causes the error. */
  warehouses: Maybe<Array<Scalars['ID']>>;
};

export type BulkStockError = {
  __typename: 'BulkStockError';
  /** List of attributes IDs which causes the error. */
  attributes: Maybe<Array<Scalars['ID']>>;
  /** The error code. */
  code: ProductErrorCode;
  /** Name of a field that caused the error. A value of `null` indicates that the error isn't associated with a particular field. */
  field: Maybe<Scalars['String']>;
  /** Index of an input list item that caused the error. */
  index: Maybe<Scalars['Int']>;
  /** The error message. */
  message: Maybe<Scalars['String']>;
  /** List of attribute values IDs which causes the error. */
  values: Maybe<Array<Scalars['ID']>>;
};

/** Synchronous webhook for calculating checkout/order taxes. */
export type CalculateTaxes = Event & {
  __typename: 'CalculateTaxes';
  /** Time of the event. */
  issuedAt: Maybe<Scalars['DateTime']>;
  /** The user or application that triggered the event. */
  issuingPrincipal: Maybe<IssuingPrincipal>;
  /** The application receiving the webhook. */
  recipient: Maybe<App>;
  taxBase: TaxableObject;
  /** Saleor version that triggered the event. */
  version: Maybe<Scalars['String']>;
};

export type CardInput = {
  /** Payment method nonce, a token returned by the appropriate provider's SDK. */
  code: Scalars['String'];
  /** Card security code. */
  cvc: InputMaybe<Scalars['String']>;
  /** Information about currency and amount. */
  money: MoneyInput;
};

/**
 * Represents a card payment method used for a transaction.
 *
 * Added in Saleor 3.22.
 */
export type CardPaymentMethodDetails = PaymentMethodDetails & {
  __typename: 'CardPaymentMethodDetails';
  /** Card brand. */
  brand: Maybe<Scalars['String']>;
  /** Two-digit number representing the cards expiration month. */
  expMonth: Maybe<Scalars['Int']>;
  /** Four-digit number representing the cards expiration year. */
  expYear: Maybe<Scalars['Int']>;
  /** First 4 digits of the card number. */
  firstDigits: Maybe<Scalars['String']>;
  /** Last 4 digits of the card number. */
  lastDigits: Maybe<Scalars['String']>;
  /** Name of the payment method. */
  name: Scalars['String'];
};

export type CardPaymentMethodDetailsInput = {
  /** Brand of the payment method used for the transaction. Max length is 40 characters. */
  brand: InputMaybe<Scalars['String']>;
  /** Expiration month of the card used for the transaction. Value must be between 1 and 12. */
  expMonth: InputMaybe<Scalars['Int']>;
  /** Expiration year of the card used for the transaction. Value must be between 2000 and 9999. */
  expYear: InputMaybe<Scalars['Int']>;
  /** First digits of the card used for the transaction. Max length is 4 characters. */
  firstDigits: InputMaybe<Scalars['String']>;
  /** Last digits of the card used for the transaction. Max length is 4 characters. */
  lastDigits: InputMaybe<Scalars['String']>;
  /** Name of the payment method used for the transaction. Max length is 256 characters. */
  name: Scalars['String'];
};

export type CatalogueInput = {
  /** Categories related to the discount. */
  categories: InputMaybe<Array<Scalars['ID']>>;
  /** Collections related to the discount. */
  collections: InputMaybe<Array<Scalars['ID']>>;
  /** Products related to the discount. */
  products: InputMaybe<Array<Scalars['ID']>>;
  /** Product variant related to the discount. */
  variants: InputMaybe<Array<Scalars['ID']>>;
};

export type CataloguePredicateInput = {
  /** List of conditions that must be met. */
  AND: InputMaybe<Array<CataloguePredicateInput>>;
  /** A list of conditions of which at least one must be met. */
  OR: InputMaybe<Array<CataloguePredicateInput>>;
  /** Defines the category conditions to be met. */
  categoryPredicate: InputMaybe<CategoryWhereInput>;
  /** Defines the collection conditions to be met. */
  collectionPredicate: InputMaybe<CollectionWhereInput>;
  /** Defines the product conditions to be met. */
  productPredicate: InputMaybe<ProductWhereInput>;
  /** Defines the product variant conditions to be met. */
  variantPredicate: InputMaybe<ProductVariantWhereInput>;
};

/** Represents a single category of products. Categories allow to organize products in a tree-hierarchies which can be used for navigation in the storefront. */
export type Category = Node & ObjectWithMetadata & {
  __typename: 'Category';
  /** List of ancestors of the category. */
  ancestors: Maybe<CategoryCountableConnection>;
  /** Background image of the category. */
  backgroundImage: Maybe<Image>;
  /** List of children of the category. */
  children: Maybe<CategoryCountableConnection>;
  /**
   * Description of the category.
   *
   * Rich text format. For reference see https://editorjs.io/
   */
  description: Maybe<Scalars['JSONString']>;
  /**
   * Description of the category.
   *
   * Rich text format. For reference see https://editorjs.io/
   * @deprecated Use the `description` field instead.
   */
  descriptionJson: Maybe<Scalars['JSONString']>;
  /** The ID of the category. */
  id: Scalars['ID'];
  /** Level of the category. */
  level: Scalars['Int'];
  /** List of public metadata items. Can be accessed without permissions. */
  metadata: Array<MetadataItem>;
  /**
   * A single key from public metadata.
   *
   * Tip: Use GraphQL aliases to fetch multiple keys.
   */
  metafield: Maybe<Scalars['String']>;
  /** Public metadata. Use `keys` to control which fields you want to include. The default is to include everything. */
  metafields: Maybe<Scalars['Metadata']>;
  /** Name of category */
  name: Scalars['String'];
  /** Parent category. */
  parent: Maybe<Category>;
  /** List of private metadata items. Requires staff permissions to access. */
  privateMetadata: Array<MetadataItem>;
  /**
   * A single key from private metadata. Requires staff permissions to access.
   *
   * Tip: Use GraphQL aliases to fetch multiple keys.
   */
  privateMetafield: Maybe<Scalars['String']>;
  /** Private metadata. Requires staff permissions to access. Use `keys` to control which fields you want to include. The default is to include everything. */
  privateMetafields: Maybe<Scalars['Metadata']>;
  /** List of products in the category. Requires the following permissions to include the unpublished items: MANAGE_ORDERS, MANAGE_DISCOUNTS, MANAGE_PRODUCTS. */
  products: Maybe<ProductCountableConnection>;
  /** SEO description of category. */
  seoDescription: Maybe<Scalars['String']>;
  /** SEO title of category. */
  seoTitle: Maybe<Scalars['String']>;
  /** Slug of the category. */
  slug: Scalars['String'];
  /** Returns translated category fields for the given language code. */
  translation: Maybe<CategoryTranslation>;
  /** The date and time when the category was last updated. */
  updatedAt: Scalars['DateTime'];
};


/** Represents a single category of products. Categories allow to organize products in a tree-hierarchies which can be used for navigation in the storefront. */
export type CategoryAncestorsArgs = {
  after: InputMaybe<Scalars['String']>;
  before: InputMaybe<Scalars['String']>;
  first: InputMaybe<Scalars['Int']>;
  last: InputMaybe<Scalars['Int']>;
};


/** Represents a single category of products. Categories allow to organize products in a tree-hierarchies which can be used for navigation in the storefront. */
export type CategoryBackgroundImageArgs = {
  format?: InputMaybe<ThumbnailFormatEnum>;
  size: InputMaybe<Scalars['Int']>;
};


/** Represents a single category of products. Categories allow to organize products in a tree-hierarchies which can be used for navigation in the storefront. */
export type CategoryChildrenArgs = {
  after: InputMaybe<Scalars['String']>;
  before: InputMaybe<Scalars['String']>;
  first: InputMaybe<Scalars['Int']>;
  last: InputMaybe<Scalars['Int']>;
};


/** Represents a single category of products. Categories allow to organize products in a tree-hierarchies which can be used for navigation in the storefront. */
export type CategoryMetafieldArgs = {
  key: Scalars['String'];
};


/** Represents a single category of products. Categories allow to organize products in a tree-hierarchies which can be used for navigation in the storefront. */
export type CategoryMetafieldsArgs = {
  keys: InputMaybe<Array<Scalars['String']>>;
};


/** Represents a single category of products. Categories allow to organize products in a tree-hierarchies which can be used for navigation in the storefront. */
export type CategoryPrivateMetafieldArgs = {
  key: Scalars['String'];
};


/** Represents a single category of products. Categories allow to organize products in a tree-hierarchies which can be used for navigation in the storefront. */
export type CategoryPrivateMetafieldsArgs = {
  keys: InputMaybe<Array<Scalars['String']>>;
};


/** Represents a single category of products. Categories allow to organize products in a tree-hierarchies which can be used for navigation in the storefront. */
export type CategoryProductsArgs = {
  after: InputMaybe<Scalars['String']>;
  before: InputMaybe<Scalars['String']>;
  channel: InputMaybe<Scalars['String']>;
  filter: InputMaybe<ProductFilterInput>;
  first: InputMaybe<Scalars['Int']>;
  last: InputMaybe<Scalars['Int']>;
  search: InputMaybe<Scalars['String']>;
  sortBy: InputMaybe<ProductOrder>;
  where: InputMaybe<ProductWhereInput>;
};


/** Represents a single category of products. Categories allow to organize products in a tree-hierarchies which can be used for navigation in the storefront. */
export type CategoryTranslationArgs = {
  languageCode: LanguageCodeEnum;
};

/**
 * Deletes categories.
 *
 * Requires one of the following permissions: MANAGE_PRODUCTS.
 */
export type CategoryBulkDelete = {
  __typename: 'CategoryBulkDelete';
  /** Returns how many objects were affected. */
  count: Scalars['Int'];
  errors: Array<ProductError>;
  /** @deprecated Use `errors` field instead. */
  productErrors: Array<ProductError>;
};

export type CategoryCountableConnection = {
  __typename: 'CategoryCountableConnection';
  edges: Array<CategoryCountableEdge>;
  /** Pagination data for this connection. */
  pageInfo: PageInfo;
  /** A total count of items in the collection. */
  totalCount: Maybe<Scalars['Int']>;
};

export type CategoryCountableEdge = {
  __typename: 'CategoryCountableEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node: Category;
};

/**
 * Creates a new category.
 *
 * Requires one of the following permissions: MANAGE_PRODUCTS.
 */
export type CategoryCreate = {
  __typename: 'CategoryCreate';
  category: Maybe<Category>;
  errors: Array<ProductError>;
  /** @deprecated Use `errors` field instead. */
  productErrors: Array<ProductError>;
};

/** Event sent when new category is created. */
export type CategoryCreated = Event & {
  __typename: 'CategoryCreated';
  /** The category the event relates to. */
  category: Maybe<Category>;
  /** Time of the event. */
  issuedAt: Maybe<Scalars['DateTime']>;
  /** The user or application that triggered the event. */
  issuingPrincipal: Maybe<IssuingPrincipal>;
  /** The application receiving the webhook. */
  recipient: Maybe<App>;
  /** Saleor version that triggered the event. */
  version: Maybe<Scalars['String']>;
};

/**
 * Deletes a category.
 *
 * Requires one of the following permissions: MANAGE_PRODUCTS.
 */
export type CategoryDelete = {
  __typename: 'CategoryDelete';
  category: Maybe<Category>;
  errors: Array<ProductError>;
  /** @deprecated Use `errors` field instead. */
  productErrors: Array<ProductError>;
};

/** Event sent when category is deleted. */
export type CategoryDeleted = Event & {
  __typename: 'CategoryDeleted';
  /** The category the event relates to. */
  category: Maybe<Category>;
  /** Time of the event. */
  issuedAt: Maybe<Scalars['DateTime']>;
  /** The user or application that triggered the event. */
  issuingPrincipal: Maybe<IssuingPrincipal>;
  /** The application receiving the webhook. */
  recipient: Maybe<App>;
  /** Saleor version that triggered the event. */
  version: Maybe<Scalars['String']>;
};

export type CategoryFilterInput = {
  ids: InputMaybe<Array<Scalars['ID']>>;
  metadata: InputMaybe<Array<MetadataFilter>>;
  search: InputMaybe<Scalars['String']>;
  slugs: InputMaybe<Array<Scalars['String']>>;
  /** Filter by when was the most recent update. */
  updatedAt: InputMaybe<DateTimeRangeInput>;
};

export type CategoryInput = {
  /** Background image file. */
  backgroundImage: InputMaybe<Scalars['Upload']>;
  /** Alt text for a product media. */
  backgroundImageAlt: InputMaybe<Scalars['String']>;
  /**
   * Category description.
   *
   * Rich text format. For reference see https://editorjs.io/
   */
  description: InputMaybe<Scalars['JSONString']>;
  /**
   * Fields required to update the category metadata. Can be read by any API client authorized to read the object it's attached to.
   *
   * Warning: never store sensitive information, including financial data such as credit card details.
   */
  metadata: InputMaybe<Array<MetadataInput>>;
  /** Category name. */
  name: InputMaybe<Scalars['String']>;
  /**
   * Fields required to update the category private metadata. Requires permissions to modify and to read the metadata of the object it's attached to.
   *
   * Warning: never store sensitive information, including financial data such as credit card details.
   */
  privateMetadata: InputMaybe<Array<MetadataInput>>;
  /** Search engine optimization fields. */
  seo: InputMaybe<SeoInput>;
  /** Category slug. */
  slug: InputMaybe<Scalars['String']>;
};

export type CategorySortField =
  /** Sort categories by name. */
  | 'NAME'
  /** Sort categories by product count. */
  | 'PRODUCT_COUNT'
  /** Sort categories by subcategory count. */
  | 'SUBCATEGORY_COUNT';

export type CategorySortingInput = {
  /**
   * Specifies the channel in which to sort the data.
   * @deprecated Use root-level channel argument instead.
   */
  channel: InputMaybe<Scalars['String']>;
  /** Specifies the direction in which to sort categories. */
  direction: OrderDirection;
  /** Sort categories by the selected field. */
  field: CategorySortField;
};

/** Represents category original translatable fields and related translations. */
export type CategoryTranslatableContent = Node & {
  __typename: 'CategoryTranslatableContent';
  /**
   * Represents a single category of products.
   * @deprecated Get model fields from the root level queries.
   */
  category: Maybe<Category>;
  /** The ID of the category to translate. */
  categoryId: Scalars['ID'];
  /**
   * Category description to translate.
   *
   * Rich text format. For reference see https://editorjs.io/
   */
  description: Maybe<Scalars['JSONString']>;
  /**
   * Description of the category.
   *
   * Rich text format. For reference see https://editorjs.io/
   * @deprecated Use the `description` field instead.
   */
  descriptionJson: Maybe<Scalars['JSONString']>;
  /** The ID of the category translatable content. */
  id: Scalars['ID'];
  /** Name of the category translatable content. */
  name: Scalars['String'];
  /** SEO description to translate. */
  seoDescription: Maybe<Scalars['String']>;
  /** SEO title to translate. */
  seoTitle: Maybe<Scalars['String']>;
  /**
   * Slug to translate.
   *
   * Added in Saleor 3.21.
   */
  slug: Maybe<Scalars['String']>;
  /** Returns translated category fields for the given language code. */
  translation: Maybe<CategoryTranslation>;
};


/** Represents category original translatable fields and related translations. */
export type CategoryTranslatableContentTranslationArgs = {
  languageCode: LanguageCodeEnum;
};

/**
 * Creates/updates translations for a category.
 *
 * Requires one of the following permissions: MANAGE_TRANSLATIONS.
 */
export type CategoryTranslate = {
  __typename: 'CategoryTranslate';
  category: Maybe<Category>;
  errors: Array<TranslationError>;
  /** @deprecated Use `errors` field instead. */
  translationErrors: Array<TranslationError>;
};

/** Represents category translations. */
export type CategoryTranslation = Node & {
  __typename: 'CategoryTranslation';
  /**
   * Translated description of the category.
   *
   * Rich text format. For reference see https://editorjs.io/
   */
  description: Maybe<Scalars['JSONString']>;
  /**
   * Translated description of the category.
   *
   * Rich text format. For reference see https://editorjs.io/
   * @deprecated Use the `description` field instead.
   */
  descriptionJson: Maybe<Scalars['JSONString']>;
  /** The ID of the category translation. */
  id: Scalars['ID'];
  /** Translation language. */
  language: LanguageDisplay;
  /** Translated category name. */
  name: Maybe<Scalars['String']>;
  /** Translated SEO description. */
  seoDescription: Maybe<Scalars['String']>;
  /** Translated SEO title. */
  seoTitle: Maybe<Scalars['String']>;
  /**
   * Translated category slug.
   *
   * Added in Saleor 3.21.
   */
  slug: Maybe<Scalars['String']>;
  /** Represents the category fields to translate. */
  translatableContent: Maybe<CategoryTranslatableContent>;
};

/**
 * Updates a category.
 *
 * Requires one of the following permissions: MANAGE_PRODUCTS.
 */
export type CategoryUpdate = {
  __typename: 'CategoryUpdate';
  category: Maybe<Category>;
  errors: Array<ProductError>;
  /** @deprecated Use `errors` field instead. */
  productErrors: Array<ProductError>;
};

/** Event sent when category is updated. */
export type CategoryUpdated = Event & {
  __typename: 'CategoryUpdated';
  /** The category the event relates to. */
  category: Maybe<Category>;
  /** Time of the event. */
  issuedAt: Maybe<Scalars['DateTime']>;
  /** The user or application that triggered the event. */
  issuingPrincipal: Maybe<IssuingPrincipal>;
  /** The application receiving the webhook. */
  recipient: Maybe<App>;
  /** Saleor version that triggered the event. */
  version: Maybe<Scalars['String']>;
};

export type CategoryWhereInput = {
  /** List of conditions that must be met. */
  AND: InputMaybe<Array<CategoryWhereInput>>;
  /** A list of conditions of which at least one must be met. */
  OR: InputMaybe<Array<CategoryWhereInput>>;
  ids: InputMaybe<Array<Scalars['ID']>>;
  metadata: InputMaybe<Array<MetadataFilter>>;
};

/** Represents channel. */
export type Channel = Node & ObjectWithMetadata & {
  __typename: 'Channel';
  /** Shipping methods that are available for the channel. */
  availableShippingMethodsPerCountry: Maybe<Array<ShippingMethodsPerCountry>>;
  /**
   * Channel-specific checkout settings.
   *
   * Requires one of the following permissions: MANAGE_CHANNELS, MANAGE_CHECKOUTS.
   */
  checkoutSettings: CheckoutSettings;
  /** List of shippable countries for the channel. */
  countries: Maybe<Array<CountryDisplay>>;
  /**
   * A currency that is assigned to the channel.
   *
   * Requires one of the following permissions: AUTHENTICATED_APP, AUTHENTICATED_STAFF_USER.
   */
  currencyCode: Scalars['String'];
  /**
   * Default country for the channel. Default country can be used in checkout to determine the stock quantities or calculate taxes when the country was not explicitly provided.
   *
   * Requires one of the following permissions: AUTHENTICATED_APP, AUTHENTICATED_STAFF_USER.
   */
  defaultCountry: CountryDisplay;
  /**
   * Whether a channel has associated orders.
   *
   * Requires one of the following permissions: MANAGE_CHANNELS.
   */
  hasOrders: Scalars['Boolean'];
  /** The ID of the channel. */
  id: Scalars['ID'];
  /**
   * Whether the channel is active.
   *
   * Requires one of the following permissions: AUTHENTICATED_APP, AUTHENTICATED_STAFF_USER.
   */
  isActive: Scalars['Boolean'];
  /** List of public metadata items. Can be accessed without permissions. */
  metadata: Array<MetadataItem>;
  /**
   * A single key from public metadata.
   *
   * Tip: Use GraphQL aliases to fetch multiple keys.
   */
  metafield: Maybe<Scalars['String']>;
  /** Public metadata. Use `keys` to control which fields you want to include. The default is to include everything. */
  metafields: Maybe<Scalars['Metadata']>;
  /**
   * Name of the channel.
   *
   * Requires one of the following permissions: AUTHENTICATED_APP, AUTHENTICATED_STAFF_USER.
   */
  name: Scalars['String'];
  /**
   * Channel-specific order settings.
   *
   * Requires one of the following permissions: MANAGE_CHANNELS, MANAGE_ORDERS.
   */
  orderSettings: OrderSettings;
  /**
   * Channel-specific payment settings.
   *
   * Requires one of the following permissions: MANAGE_CHANNELS, HANDLE_PAYMENTS.
   */
  paymentSettings: PaymentSettings;
  /** List of private metadata items. Requires staff permissions to access. */
  privateMetadata: Array<MetadataItem>;
  /**
   * A single key from private metadata. Requires staff permissions to access.
   *
   * Tip: Use GraphQL aliases to fetch multiple keys.
   */
  privateMetafield: Maybe<Scalars['String']>;
  /** Private metadata. Requires staff permissions to access. Use `keys` to control which fields you want to include. The default is to include everything. */
  privateMetafields: Maybe<Scalars['Metadata']>;
  /** Slug of the channel. */
  slug: Scalars['String'];
  /**
   * Define the stock setting for this channel.
   *
   * Requires one of the following permissions: AUTHENTICATED_APP, AUTHENTICATED_STAFF_USER.
   */
  stockSettings: StockSettings;
  /**
   * Channel specific tax configuration.
   *
   * Added in Saleor 3.20.
   *
   * Requires one of the following permissions: AUTHENTICATED_STAFF_USER, AUTHENTICATED_APP.
   */
  taxConfiguration: TaxConfiguration;
  /**
   * List of warehouses assigned to this channel.
   *
   * Requires one of the following permissions: AUTHENTICATED_APP, AUTHENTICATED_STAFF_USER.
   */
  warehouses: Array<Warehouse>;
};


/** Represents channel. */
export type ChannelAvailableShippingMethodsPerCountryArgs = {
  countries: InputMaybe<Array<CountryCode>>;
};


/** Represents channel. */
export type ChannelMetafieldArgs = {
  key: Scalars['String'];
};


/** Represents channel. */
export type ChannelMetafieldsArgs = {
  keys: InputMaybe<Array<Scalars['String']>>;
};


/** Represents channel. */
export type ChannelPrivateMetafieldArgs = {
  key: Scalars['String'];
};


/** Represents channel. */
export type ChannelPrivateMetafieldsArgs = {
  keys: InputMaybe<Array<Scalars['String']>>;
};

/**
 * Activate a channel.
 *
 * Requires one of the following permissions: MANAGE_CHANNELS.
 *
 * Triggers the following webhook events:
 * - CHANNEL_STATUS_CHANGED (async): A channel was activated.
 */
export type ChannelActivate = {
  __typename: 'ChannelActivate';
  /** Activated channel. */
  channel: Maybe<Channel>;
  /** @deprecated Use `errors` field instead. */
  channelErrors: Array<ChannelError>;
  errors: Array<ChannelError>;
};

/**
 * Creates a new channel.
 *
 * Requires one of the following permissions: MANAGE_CHANNELS.
 *
 * Triggers the following webhook events:
 * - CHANNEL_CREATED (async): A channel was created.
 */
export type ChannelCreate = {
  __typename: 'ChannelCreate';
  channel: Maybe<Channel>;
  /** @deprecated Use `errors` field instead. */
  channelErrors: Array<ChannelError>;
  errors: Array<ChannelError>;
};

export type ChannelCreateInput = {
  /** List of shipping zones to assign to the channel. */
  addShippingZones: InputMaybe<Array<Scalars['ID']>>;
  /** List of warehouses to assign to the channel. */
  addWarehouses: InputMaybe<Array<Scalars['ID']>>;
  /** The channel checkout settings */
  checkoutSettings: InputMaybe<CheckoutSettingsInput>;
  /** Currency of the channel. */
  currencyCode: Scalars['String'];
  /** Default country for the channel. Default country can be used in checkout to determine the stock quantities or calculate taxes when the country was not explicitly provided. */
  defaultCountry: CountryCode;
  /** Determine if channel will be set active or not. */
  isActive: InputMaybe<Scalars['Boolean']>;
  /**
   * Channel public metadata. Can be read by any API client authorized to read the object it's attached to.
   *
   * Warning: never store sensitive information, including financial data such as credit card details.
   */
  metadata: InputMaybe<Array<MetadataInput>>;
  /** Name of the channel. */
  name: Scalars['String'];
  /** The channel order settings */
  orderSettings: InputMaybe<OrderSettingsInput>;
  /** The channel payment settings */
  paymentSettings: InputMaybe<PaymentSettingsInput>;
  /**
   * Channel private metadata. Requires permissions to modify and to read the metadata of the object it's attached to.
   *
   * Warning: never store sensitive information, including financial data such as credit card details.
   */
  privateMetadata: InputMaybe<Array<MetadataInput>>;
  /** Slug of the channel. */
  slug: Scalars['String'];
  /** The channel stock settings. */
  stockSettings: InputMaybe<StockSettingsInput>;
};

/** Event sent when new channel is created. */
export type ChannelCreated = Event & {
  __typename: 'ChannelCreated';
  /** The channel the event relates to. */
  channel: Maybe<Channel>;
  /** Time of the event. */
  issuedAt: Maybe<Scalars['DateTime']>;
  /** The user or application that triggered the event. */
  issuingPrincipal: Maybe<IssuingPrincipal>;
  /** The application receiving the webhook. */
  recipient: Maybe<App>;
  /** Saleor version that triggered the event. */
  version: Maybe<Scalars['String']>;
};

/**
 * Deactivate a channel.
 *
 * Requires one of the following permissions: MANAGE_CHANNELS.
 *
 * Triggers the following webhook events:
 * - CHANNEL_STATUS_CHANGED (async): A channel was deactivated.
 */
export type ChannelDeactivate = {
  __typename: 'ChannelDeactivate';
  /** Deactivated channel. */
  channel: Maybe<Channel>;
  /** @deprecated Use `errors` field instead. */
  channelErrors: Array<ChannelError>;
  errors: Array<ChannelError>;
};

/**
 * Deletes a channel. Orders associated with the deleted channel will be moved to the target channel. Checkouts, product availability, and pricing will be removed.
 *
 * Requires one of the following permissions: MANAGE_CHANNELS.
 *
 * Triggers the following webhook events:
 * - CHANNEL_DELETED (async): A channel was deleted.
 */
export type ChannelDelete = {
  __typename: 'ChannelDelete';
  channel: Maybe<Channel>;
  /** @deprecated Use `errors` field instead. */
  channelErrors: Array<ChannelError>;
  errors: Array<ChannelError>;
};

export type ChannelDeleteInput = {
  /** ID of a channel to migrate orders from the origin channel. Target channel has to have the same currency as the origin. */
  channelId: Scalars['ID'];
};

/** Event sent when channel is deleted. */
export type ChannelDeleted = Event & {
  __typename: 'ChannelDeleted';
  /** The channel the event relates to. */
  channel: Maybe<Channel>;
  /** Time of the event. */
  issuedAt: Maybe<Scalars['DateTime']>;
  /** The user or application that triggered the event. */
  issuingPrincipal: Maybe<IssuingPrincipal>;
  /** The application receiving the webhook. */
  recipient: Maybe<App>;
  /** Saleor version that triggered the event. */
  version: Maybe<Scalars['String']>;
};

export type ChannelError = {
  __typename: 'ChannelError';
  /** The error code. */
  code: ChannelErrorCode;
  /** Name of a field that caused the error. A value of `null` indicates that the error isn't associated with a particular field. */
  field: Maybe<Scalars['String']>;
  /** The error message. */
  message: Maybe<Scalars['String']>;
  /** List of shipping zone IDs which causes the error. */
  shippingZones: Maybe<Array<Scalars['ID']>>;
  /** List of warehouses IDs which causes the error. */
  warehouses: Maybe<Array<Scalars['ID']>>;
};

export type ChannelErrorCode =
  | 'ALREADY_EXISTS'
  | 'CHANNELS_CURRENCY_MUST_BE_THE_SAME'
  | 'CHANNEL_WITH_ORDERS'
  | 'DUPLICATED_INPUT_ITEM'
  | 'GRAPHQL_ERROR'
  | 'INVALID'
  | 'NOT_FOUND'
  | 'REQUIRED'
  | 'UNIQUE';

export type ChannelListingUpdateInput = {
  /** ID of a channel listing. */
  channelListing: Scalars['ID'];
  /** Cost price of the variant in channel. */
  costPrice: InputMaybe<Scalars['PositiveDecimal']>;
  /** The threshold for preorder variant in channel. */
  preorderThreshold: InputMaybe<Scalars['Int']>;
  /** Price of the particular variant in channel. */
  price: InputMaybe<Scalars['PositiveDecimal']>;
  /** Price of the variant before discount. */
  priorPrice: InputMaybe<Scalars['PositiveDecimal']>;
};

/** Event sent when channel metadata is updated. */
export type ChannelMetadataUpdated = Event & {
  __typename: 'ChannelMetadataUpdated';
  /** The channel the event relates to. */
  channel: Maybe<Channel>;
  /** Time of the event. */
  issuedAt: Maybe<Scalars['DateTime']>;
  /** The user or application that triggered the event. */
  issuingPrincipal: Maybe<IssuingPrincipal>;
  /** The application receiving the webhook. */
  recipient: Maybe<App>;
  /** Saleor version that triggered the event. */
  version: Maybe<Scalars['String']>;
};

/**
 * Reorder the warehouses of a channel.
 *
 * Requires one of the following permissions: MANAGE_CHANNELS.
 */
export type ChannelReorderWarehouses = {
  __typename: 'ChannelReorderWarehouses';
  /** Channel within the warehouses are reordered. */
  channel: Maybe<Channel>;
  errors: Array<ChannelError>;
};

/** Event sent when channel status has changed. */
export type ChannelStatusChanged = Event & {
  __typename: 'ChannelStatusChanged';
  /** The channel the event relates to. */
  channel: Maybe<Channel>;
  /** Time of the event. */
  issuedAt: Maybe<Scalars['DateTime']>;
  /** The user or application that triggered the event. */
  issuingPrincipal: Maybe<IssuingPrincipal>;
  /** The application receiving the webhook. */
  recipient: Maybe<App>;
  /** Saleor version that triggered the event. */
  version: Maybe<Scalars['String']>;
};

/**
 * Update a channel.
 *
 * Requires one of the following permissions: MANAGE_CHANNELS.
 * Requires one of the following permissions when updating only `orderSettings` field: `MANAGE_CHANNELS`, `MANAGE_ORDERS`.
 * Requires one of the following permissions when updating only `checkoutSettings` field: `MANAGE_CHANNELS`, `MANAGE_CHECKOUTS`.
 * Requires one of the following permissions when updating only `paymentSettings` field: `MANAGE_CHANNELS`, `HANDLE_PAYMENTS`.
 *
 * Triggers the following webhook events:
 * - CHANNEL_UPDATED (async): A channel was updated.
 * - CHANNEL_METADATA_UPDATED (async): Optionally triggered when public or private metadata is updated.
 */
export type ChannelUpdate = {
  __typename: 'ChannelUpdate';
  channel: Maybe<Channel>;
  /** @deprecated Use `errors` field instead. */
  channelErrors: Array<ChannelError>;
  errors: Array<ChannelError>;
};

export type ChannelUpdateInput = {
  /** List of shipping zones to assign to the channel. */
  addShippingZones: InputMaybe<Array<Scalars['ID']>>;
  /** List of warehouses to assign to the channel. */
  addWarehouses: InputMaybe<Array<Scalars['ID']>>;
  /** The channel checkout settings */
  checkoutSettings: InputMaybe<CheckoutSettingsInput>;
  /** Default country for the channel. Default country can be used in checkout to determine the stock quantities or calculate taxes when the country was not explicitly provided. */
  defaultCountry: InputMaybe<CountryCode>;
  /** Determine if channel will be set active or not. */
  isActive: InputMaybe<Scalars['Boolean']>;
  /**
   * Channel public metadata. Can be read by any API client authorized to read the object it's attached to.
   *
   * Warning: never store sensitive information, including financial data such as credit card details.
   */
  metadata: InputMaybe<Array<MetadataInput>>;
  /** Name of the channel. */
  name: InputMaybe<Scalars['String']>;
  /** The channel order settings */
  orderSettings: InputMaybe<OrderSettingsInput>;
  /** The channel payment settings */
  paymentSettings: InputMaybe<PaymentSettingsInput>;
  /**
   * Channel private metadata. Requires permissions to modify and to read the metadata of the object it's attached to.
   *
   * Warning: never store sensitive information, including financial data such as credit card details.
   */
  privateMetadata: InputMaybe<Array<MetadataInput>>;
  /** List of shipping zones to unassign from the channel. */
  removeShippingZones: InputMaybe<Array<Scalars['ID']>>;
  /** List of warehouses to unassign from the channel. */
  removeWarehouses: InputMaybe<Array<Scalars['ID']>>;
  /** Slug of the channel. */
  slug: InputMaybe<Scalars['String']>;
  /** The channel stock settings. */
  stockSettings: InputMaybe<StockSettingsInput>;
};

/** Event sent when channel is updated. */
export type ChannelUpdated = Event & {
  __typename: 'ChannelUpdated';
  /** The channel the event relates to. */
  channel: Maybe<Channel>;
  /** Time of the event. */
  issuedAt: Maybe<Scalars['DateTime']>;
  /** The user or application that triggered the event. */
  issuingPrincipal: Maybe<IssuingPrincipal>;
  /** The application receiving the webhook. */
  recipient: Maybe<App>;
  /** Saleor version that triggered the event. */
  version: Maybe<Scalars['String']>;
};

/** Checkout object. */
export type Checkout = Node & ObjectWithMetadata & {
  __typename: 'Checkout';
  /**
   * The authorize status of the checkout.
   *
   * Triggers the following webhook events:
   * - CHECKOUT_CALCULATE_TAXES (sync): Optionally triggered when checkout prices are expired.
   */
  authorizeStatus: CheckoutAuthorizeStatusEnum;
  /** Collection points that can be used for this order. */
  availableCollectionPoints: Array<Warehouse>;
  /**
   * List of available payment gateways.
   *
   * Triggers the following webhook events:
   * - PAYMENT_LIST_GATEWAYS (sync): Fetch payment gateways available for checkout.
   */
  availablePaymentGateways: Array<PaymentGateway>;
  /**
   * Shipping methods that can be used with this checkout.
   *
   * Triggers the following webhook events:
   * - SHIPPING_LIST_METHODS_FOR_CHECKOUT (sync): Optionally triggered when cached external shipping methods are invalid.
   * - CHECKOUT_FILTER_SHIPPING_METHODS (sync): Optionally triggered when cached filtered shipping methods are invalid.
   * @deprecated Use `shippingMethods` instead.
   */
  availableShippingMethods: Array<ShippingMethod>;
  /** The billing address of the checkout. */
  billingAddress: Maybe<Address>;
  /** The channel for which checkout was created. */
  channel: Channel;
  /**
   * The charge status of the checkout.
   *
   * Triggers the following webhook events:
   * - CHECKOUT_CALCULATE_TAXES (sync): Optionally triggered when checkout prices are expired.
   */
  chargeStatus: CheckoutChargeStatusEnum;
  /** The date and time when the checkout was created. */
  created: Scalars['DateTime'];
  /**
   * The customer note for the checkout.
   *
   * Added in Saleor 3.21.
   */
  customerNote: Scalars['String'];
  /**
   * The delivery method selected for this checkout.
   *
   * Triggers the following webhook events:
   * - SHIPPING_LIST_METHODS_FOR_CHECKOUT (sync): Optionally triggered when cached external shipping methods are invalid.
   * - CHECKOUT_FILTER_SHIPPING_METHODS (sync): Optionally triggered when cached filtered shipping methods are invalid.
   */
  deliveryMethod: Maybe<DeliveryMethod>;
  /** The total discount applied to the checkout. Note: Only discount created via voucher are included in this field. */
  discount: Maybe<Money>;
  /** The name of voucher assigned to the checkout. */
  discountName: Maybe<Scalars['String']>;
  /** Determines whether displayed prices should include taxes. */
  displayGrossPrices: Scalars['Boolean'];
  /** Email of a customer. */
  email: Maybe<Scalars['String']>;
  /** List of gift cards associated with this checkout. */
  giftCards: Array<GiftCard>;
  /** The ID of the checkout. */
  id: Scalars['ID'];
  /** Returns True, if checkout requires shipping. */
  isShippingRequired: Scalars['Boolean'];
  /** Checkout language code. */
  languageCode: LanguageCodeEnum;
  /** @deprecated Use `updatedAt` instead. */
  lastChange: Scalars['DateTime'];
  /** A list of checkout lines, each containing information about an item in the checkout. */
  lines: Array<CheckoutLine>;
  /** List of public metadata items. Can be accessed without permissions. */
  metadata: Array<MetadataItem>;
  /**
   * A single key from public metadata.
   *
   * Tip: Use GraphQL aliases to fetch multiple keys.
   */
  metafield: Maybe<Scalars['String']>;
  /** Public metadata. Use `keys` to control which fields you want to include. The default is to include everything. */
  metafields: Maybe<Scalars['Metadata']>;
  /**
   * The note for the checkout.
   * @deprecated Use `customerNote` instead.
   */
  note: Scalars['String'];
  /** List of private metadata items. Requires staff permissions to access. */
  privateMetadata: Array<MetadataItem>;
  /**
   * A single key from private metadata. Requires staff permissions to access.
   *
   * Tip: Use GraphQL aliases to fetch multiple keys.
   */
  privateMetafield: Maybe<Scalars['String']>;
  /** Private metadata. Requires staff permissions to access. Use `keys` to control which fields you want to include. The default is to include everything. */
  privateMetafields: Maybe<Scalars['Metadata']>;
  /** List of problems with the checkout. */
  problems: Maybe<Array<CheckoutProblem>>;
  /** The number of items purchased. */
  quantity: Scalars['Int'];
  /** The shipping address of the checkout. */
  shippingAddress: Maybe<Address>;
  /**
   * The shipping method related with checkout.
   *
   * Triggers the following webhook events:
   * - SHIPPING_LIST_METHODS_FOR_CHECKOUT (sync): Optionally triggered when cached external shipping methods are invalid.
   * - CHECKOUT_FILTER_SHIPPING_METHODS (sync): Optionally triggered when cached filtered shipping methods are invalid.
   * @deprecated Use `deliveryMethod` instead.
   */
  shippingMethod: Maybe<ShippingMethod>;
  /**
   * Shipping methods that can be used with this checkout.
   *
   * Triggers the following webhook events:
   * - SHIPPING_LIST_METHODS_FOR_CHECKOUT (sync): Optionally triggered when cached external shipping methods are invalid.
   * - CHECKOUT_FILTER_SHIPPING_METHODS (sync): Optionally triggered when cached filtered shipping methods are invalid.
   */
  shippingMethods: Array<ShippingMethod>;
  /**
   * The price of the shipping, with all the taxes included. Set to 0 when no delivery method is selected.
   *
   * Triggers the following webhook events:
   * - CHECKOUT_CALCULATE_TAXES (sync): Optionally triggered when checkout prices are expired.
   */
  shippingPrice: TaxedMoney;
  /** Date when oldest stock reservation for this checkout expires or null if no stock is reserved. */
  stockReservationExpires: Maybe<Scalars['DateTime']>;
  /** List of user's stored payment methods that can be used in this checkout session. It uses the channel that the checkout was created in. When `amount` is not provided, `checkout.total` will be used as a default value. */
  storedPaymentMethods: Maybe<Array<StoredPaymentMethod>>;
  /**
   * The price of the checkout before shipping, with taxes included.
   *
   * Triggers the following webhook events:
   * - CHECKOUT_CALCULATE_TAXES (sync): Optionally triggered when checkout prices are expired.
   */
  subtotalPrice: TaxedMoney;
  /** Returns True if checkout has to be exempt from taxes. */
  taxExemption: Scalars['Boolean'];
  /** The checkout's token. */
  token: Scalars['UUID'];
  /**
   * The difference between the paid and the checkout total amount.
   *
   * Triggers the following webhook events:
   * - CHECKOUT_CALCULATE_TAXES (sync): Optionally triggered when checkout prices are expired.
   */
  totalBalance: Money;
  /**
   * The sum of the checkout line prices, with all the taxes,shipping costs, and discounts included.
   *
   * Triggers the following webhook events:
   * - CHECKOUT_CALCULATE_TAXES (sync): Optionally triggered when checkout prices are expired.
   */
  totalPrice: TaxedMoney;
  /** List of transactions for the checkout. Requires one of the following permissions: MANAGE_CHECKOUTS, HANDLE_PAYMENTS. */
  transactions: Maybe<Array<TransactionItem>>;
  /** Translation of the discountName field in the language set in Checkout.languageCode field.Note: this field is set automatically when Checkout.languageCode is defined; otherwise it's null */
  translatedDiscountName: Maybe<Scalars['String']>;
  /** Time of last modification of the given checkout. */
  updatedAt: Scalars['DateTime'];
  /** The user assigned to the checkout. Requires one of the following permissions: MANAGE_USERS, HANDLE_PAYMENTS, OWNER. */
  user: Maybe<User>;
  /**
   * The voucher assigned to the checkout.
   *
   * Added in Saleor 3.18.
   *
   * Requires one of the following permissions: MANAGE_DISCOUNTS.
   */
  voucher: Maybe<Voucher>;
  /** The code of voucher assigned to the checkout. */
  voucherCode: Maybe<Scalars['String']>;
};


/** Checkout object. */
export type CheckoutMetafieldArgs = {
  key: Scalars['String'];
};


/** Checkout object. */
export type CheckoutMetafieldsArgs = {
  keys: InputMaybe<Array<Scalars['String']>>;
};


/** Checkout object. */
export type CheckoutPrivateMetafieldArgs = {
  key: Scalars['String'];
};


/** Checkout object. */
export type CheckoutPrivateMetafieldsArgs = {
  keys: InputMaybe<Array<Scalars['String']>>;
};


/** Checkout object. */
export type CheckoutStoredPaymentMethodsArgs = {
  amount: InputMaybe<Scalars['PositiveDecimal']>;
};

/**
 * Adds a gift card or a voucher to a checkout.
 *
 * Triggers the following webhook events:
 * - CHECKOUT_UPDATED (async): A checkout was updated.
 */
export type CheckoutAddPromoCode = {
  __typename: 'CheckoutAddPromoCode';
  /** The checkout with the added gift card or voucher. */
  checkout: Maybe<Checkout>;
  /** @deprecated Use `errors` field instead. */
  checkoutErrors: Array<CheckoutError>;
  errors: Array<CheckoutError>;
};

export type CheckoutAddressValidationRules = {
  /** Determines if an error should be raised when the provided address doesn't match the expected format. Example: using letters for postal code when the numbers are expected. */
  checkFieldsFormat: InputMaybe<Scalars['Boolean']>;
  /** Determines if an error should be raised when the provided address doesn't have all the required fields. The list of required fields is dynamic and depends on the country code (use the `addressValidationRules` query to fetch them). Note: country code is mandatory for all addresses regardless of the rules provided in this input. */
  checkRequiredFields: InputMaybe<Scalars['Boolean']>;
  /** Determines if Saleor should apply normalization on address fields. Example: converting city field to uppercase letters. */
  enableFieldsNormalization: InputMaybe<Scalars['Boolean']>;
};

/**
 * Determine a current authorize status for checkout.
 *
 *     We treat the checkout as fully authorized when the sum of authorized and charged
 *     funds cover the checkout.total.
 *     We treat the checkout as partially authorized when the sum of authorized and charged
 *     funds covers only part of the checkout.total
 *     We treat the checkout as not authorized when the sum of authorized and charged funds
 *     is 0.
 *
 *     NONE - the funds are not authorized
 *     PARTIAL - the cover funds don't cover fully the checkout's total
 *     FULL - the cover funds covers the checkout's total
 */
export type CheckoutAuthorizeStatusEnum =
  | 'FULL'
  | 'NONE'
  | 'PARTIAL';

export type CheckoutAutoCompleteInput = {
  /** Specifies the earliest date on which fully paid checkouts can begin to be automatically completed. Fully paid checkouts dated before this cut-off will not be automatically completed. Must be less than the threshold of the oldest modified checkout eligible for automatic completion. Default is current date time. */
  cutOffDate: InputMaybe<Scalars['DateTime']>;
  /** The time in minutes after which the fully paid checkout will be automatically completed. Default is 30. Set to 0 for immediate completion. Should be less than the threshold for the oldest modified checkout eligible for automatic completion. */
  delay: InputMaybe<Scalars['Minute']>;
  /** Default `false`. Determines if the paid checkouts should be automatically completed. This setting applies only to checkouts where payment was processed through transactions.When enabled, the checkout will be automatically completed once the checkout `charge_status` reaches `FULL`. This occurs when the total sum of charged and authorized transaction amounts equals or exceeds the checkout's total amount. */
  enabled: Scalars['Boolean'];
};

/**
 * Updates billing address in the existing checkout.
 *
 * Triggers the following webhook events:
 * - CHECKOUT_UPDATED (async): A checkout was updated.
 */
export type CheckoutBillingAddressUpdate = {
  __typename: 'CheckoutBillingAddressUpdate';
  /** An updated checkout. */
  checkout: Maybe<Checkout>;
  /** @deprecated Use `errors` field instead. */
  checkoutErrors: Array<CheckoutError>;
  errors: Array<CheckoutError>;
};

/**
 * Determine the current charge status for the checkout.
 *
 *     The checkout is considered overcharged when the sum of the transactionItem's charge
 *     amounts exceeds the value of `checkout.total`.
 *     If the sum of the transactionItem's charge amounts equals
 *     `checkout.total`, we consider the checkout to be fully charged.
 *     If the sum of the transactionItem's charge amounts covers a part of the
 *     `checkout.total`, we treat the checkout as partially charged.
 *
 *
 *     NONE - the funds are not charged.
 *     PARTIAL - the funds that are charged don't cover the checkout's total
 *     FULL - the funds that are charged fully cover the checkout's total
 *     OVERCHARGED - the charged funds are bigger than checkout's total
 */
export type CheckoutChargeStatusEnum =
  | 'FULL'
  | 'NONE'
  | 'OVERCHARGED'
  | 'PARTIAL';

/**
 * Completes the checkout. As a result a new order is created. The mutation allows to create the unpaid order when setting `orderSettings.allowUnpaidOrders` for given `Channel` is set to `true`. When `orderSettings.allowUnpaidOrders` is set to `false`, checkout can be completed only when attached `Payment`/`TransactionItem`s fully cover the checkout's total. When processing the checkout with `Payment`, in case of required additional confirmation step like 3D secure, the `confirmationNeeded` flag will be set to True and no order will be created until payment is confirmed with second call of this mutation.
 *
 * Triggers the following webhook events:
 * - SHIPPING_LIST_METHODS_FOR_CHECKOUT (sync): Optionally triggered when cached external shipping methods are invalid.
 * - CHECKOUT_FILTER_SHIPPING_METHODS (sync): Optionally triggered when cached filtered shipping methods are invalid.
 * - CHECKOUT_CALCULATE_TAXES (sync): Optionally triggered when checkout prices are expired.
 * - ORDER_CREATED (async): Triggered when order is created.
 * - NOTIFY_USER (async): A notification for order placement.
 * - NOTIFY_USER (async): A staff notification for order placement.
 * - ORDER_UPDATED (async): Triggered when order received the update after placement.
 * - ORDER_PAID (async): Triggered when newly created order is paid.
 * - ORDER_FULLY_PAID (async): Triggered when newly created order is fully paid.
 * - ORDER_CONFIRMED (async): Optionally triggered when newly created order are automatically marked as confirmed.
 */
export type CheckoutComplete = {
  __typename: 'CheckoutComplete';
  /** @deprecated Use `errors` field instead. */
  checkoutErrors: Array<CheckoutError>;
  /** Confirmation data used to process additional authorization steps. */
  confirmationData: Maybe<Scalars['JSONString']>;
  /** Set to true if payment needs to be confirmed before checkout is complete. */
  confirmationNeeded: Scalars['Boolean'];
  errors: Array<CheckoutError>;
  /** Placed order. */
  order: Maybe<Order>;
};

export type CheckoutCountableConnection = {
  __typename: 'CheckoutCountableConnection';
  edges: Array<CheckoutCountableEdge>;
  /** Pagination data for this connection. */
  pageInfo: PageInfo;
  /** A total count of items in the collection. */
  totalCount: Maybe<Scalars['Int']>;
};

export type CheckoutCountableEdge = {
  __typename: 'CheckoutCountableEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node: Checkout;
};

/**
 * Create a new checkout.
 *
 * `skipValidation` field requires HANDLE_CHECKOUTS and AUTHENTICATED_APP permissions.
 *
 * Triggers the following webhook events:
 * - CHECKOUT_CREATED (async): A checkout was created.
 */
export type CheckoutCreate = {
  __typename: 'CheckoutCreate';
  checkout: Maybe<Checkout>;
  /** @deprecated Use `errors` field instead. */
  checkoutErrors: Array<CheckoutError>;
  /**
   * Whether the checkout was created or the current active one was returned. Refer to checkoutLinesAdd and checkoutLinesUpdate to merge a cart with an active checkout.
   * @deprecated Always returns `true`.
   */
  created: Maybe<Scalars['Boolean']>;
  errors: Array<CheckoutError>;
};

/** Creates a new checkout from existing order. */
export type CheckoutCreateFromOrder = {
  __typename: 'CheckoutCreateFromOrder';
  /** Created checkout. */
  checkout: Maybe<Checkout>;
  errors: Array<CheckoutCreateFromOrderError>;
  /** Variants that were not attached to the checkout. */
  unavailableVariants: Maybe<Array<CheckoutCreateFromOrderUnavailableVariant>>;
};

export type CheckoutCreateFromOrderError = {
  __typename: 'CheckoutCreateFromOrderError';
  /** The error code. */
  code: CheckoutCreateFromOrderErrorCode;
  /** Name of a field that caused the error. A value of `null` indicates that the error isn't associated with a particular field. */
  field: Maybe<Scalars['String']>;
  /** The error message. */
  message: Maybe<Scalars['String']>;
};

export type CheckoutCreateFromOrderErrorCode =
  | 'CHANNEL_INACTIVE'
  | 'GRAPHQL_ERROR'
  | 'INVALID'
  | 'ORDER_NOT_FOUND'
  | 'TAX_ERROR';

export type CheckoutCreateFromOrderUnavailableVariant = {
  __typename: 'CheckoutCreateFromOrderUnavailableVariant';
  /** The error code. */
  code: CheckoutCreateFromOrderUnavailableVariantErrorCode;
  /** Order line ID that is unavailable. */
  lineId: Scalars['ID'];
  /** The error message. */
  message: Scalars['String'];
  /** Variant ID that is unavailable. */
  variantId: Scalars['ID'];
};

export type CheckoutCreateFromOrderUnavailableVariantErrorCode =
  | 'INSUFFICIENT_STOCK'
  | 'NOT_FOUND'
  | 'PRODUCT_NOT_PUBLISHED'
  | 'PRODUCT_UNAVAILABLE_FOR_PURCHASE'
  | 'QUANTITY_GREATER_THAN_LIMIT'
  | 'UNAVAILABLE_VARIANT_IN_CHANNEL';

export type CheckoutCreateInput = {
  /** Billing address of the customer. `skipValidation` requires HANDLE_CHECKOUTS and AUTHENTICATED_APP permissions. */
  billingAddress: InputMaybe<AddressInput>;
  /** Slug of a channel in which to create a checkout. */
  channel: InputMaybe<Scalars['String']>;
  /** The customer's email address. */
  email: InputMaybe<Scalars['String']>;
  /** Checkout language code. */
  languageCode: InputMaybe<LanguageCodeEnum>;
  /** A list of checkout lines, each containing information about an item in the checkout. */
  lines: Array<CheckoutLineInput>;
  /**
   * Checkout public metadata. Can be read by any API client authorized to read the object it's attached to.
   *
   * Warning: never store sensitive information, including financial data such as credit card details.
   *
   * Added in Saleor 3.21.
   */
  metadata: InputMaybe<Array<MetadataInput>>;
  /**
   * Checkout private metadata. Requires one of the following permissions: MANAGE_CHECKOUTS, HANDLE_CHECKOUTS
   *
   * Requires permissions to modify and to read the metadata of the object it's attached to.
   *
   * Warning: never store sensitive information, including financial data such as credit card details.
   *
   * Added in Saleor 3.21.
   */
  privateMetadata: InputMaybe<Array<MetadataInput>>;
  /**
   * Indicates whether the billing address should be saved to the users address book upon checkout completion. Can only be set when a billing address is provided. If not specified along with the address, the default behavior is to save the address.
   *
   * Added in Saleor 3.21.
   */
  saveBillingAddress: InputMaybe<Scalars['Boolean']>;
  /**
   * Indicates whether the shipping address should be saved to the users address book upon checkout completion.Can only be set when a shipping address is provided. If not specified along with the address, the default behavior is to save the address.
   *
   * Added in Saleor 3.21.
   */
  saveShippingAddress: InputMaybe<Scalars['Boolean']>;
  /** The mailing address to where the checkout will be shipped. Note: the address will be ignored if the checkout doesn't contain shippable items. `skipValidation` requires HANDLE_CHECKOUTS and AUTHENTICATED_APP permissions. */
  shippingAddress: InputMaybe<AddressInput>;
  /** The checkout validation rules that can be changed. */
  validationRules: InputMaybe<CheckoutValidationRules>;
};

/** Event sent when new checkout is created. */
export type CheckoutCreated = Event & {
  __typename: 'CheckoutCreated';
  /** The checkout the event relates to. */
  checkout: Maybe<Checkout>;
  /** Time of the event. */
  issuedAt: Maybe<Scalars['DateTime']>;
  /** The user or application that triggered the event. */
  issuingPrincipal: Maybe<IssuingPrincipal>;
  /** The application receiving the webhook. */
  recipient: Maybe<App>;
  /** Saleor version that triggered the event. */
  version: Maybe<Scalars['String']>;
};

/**
 * Sets the customer as the owner of the checkout.
 *
 * Requires one of the following permissions: AUTHENTICATED_APP, AUTHENTICATED_USER.
 *
 * Triggers the following webhook events:
 * - CHECKOUT_UPDATED (async): A checkout was updated.
 */
export type CheckoutCustomerAttach = {
  __typename: 'CheckoutCustomerAttach';
  /** An updated checkout. */
  checkout: Maybe<Checkout>;
  /** @deprecated Use `errors` field instead. */
  checkoutErrors: Array<CheckoutError>;
  errors: Array<CheckoutError>;
};

/**
 * Removes the user assigned as the owner of the checkout.
 *
 * Requires one of the following permissions: AUTHENTICATED_APP, AUTHENTICATED_USER.
 *
 * Triggers the following webhook events:
 * - CHECKOUT_UPDATED (async): A checkout was updated.
 */
export type CheckoutCustomerDetach = {
  __typename: 'CheckoutCustomerDetach';
  /** An updated checkout. */
  checkout: Maybe<Checkout>;
  /** @deprecated Use `errors` field instead. */
  checkoutErrors: Array<CheckoutError>;
  errors: Array<CheckoutError>;
};

/**
 * Updates customer note in the existing checkout object.
 *
 * Added in Saleor 3.21.
 *
 * Triggers the following webhook events:
 * - CHECKOUT_UPDATED (async): A checkout was updated.
 */
export type CheckoutCustomerNoteUpdate = {
  __typename: 'CheckoutCustomerNoteUpdate';
  /** An updated checkout. */
  checkout: Maybe<Checkout>;
  /** @deprecated Use `errors` field instead. */
  checkoutErrors: Array<CheckoutError>;
  errors: Array<CheckoutError>;
};

/**
 * Updates the delivery method (shipping method or pick up point) of the checkout. Updates the checkout shipping_address for click and collect delivery for a warehouse address.
 *
 * Triggers the following webhook events:
 * - SHIPPING_LIST_METHODS_FOR_CHECKOUT (sync): Triggered when updating the checkout delivery method with the external one.
 * - CHECKOUT_UPDATED (async): A checkout was updated.
 */
export type CheckoutDeliveryMethodUpdate = {
  __typename: 'CheckoutDeliveryMethodUpdate';
  /** An updated checkout. */
  checkout: Maybe<Checkout>;
  errors: Array<CheckoutError>;
};

/**
 * Updates email address in the existing checkout object.
 *
 * Triggers the following webhook events:
 * - CHECKOUT_UPDATED (async): A checkout was updated.
 */
export type CheckoutEmailUpdate = {
  __typename: 'CheckoutEmailUpdate';
  /** An updated checkout. */
  checkout: Maybe<Checkout>;
  /** @deprecated Use `errors` field instead. */
  checkoutErrors: Array<CheckoutError>;
  errors: Array<CheckoutError>;
};

export type CheckoutError = {
  __typename: 'CheckoutError';
  /** A type of address that causes the error. */
  addressType: Maybe<AddressTypeEnum>;
  /** The error code. */
  code: CheckoutErrorCode;
  /** Name of a field that caused the error. A value of `null` indicates that the error isn't associated with a particular field. */
  field: Maybe<Scalars['String']>;
  /** List of line Ids which cause the error. */
  lines: Maybe<Array<Scalars['ID']>>;
  /** The error message. */
  message: Maybe<Scalars['String']>;
  /** List of variant IDs which causes the error. */
  variants: Maybe<Array<Scalars['ID']>>;
};

export type CheckoutErrorCode =
  | 'BILLING_ADDRESS_NOT_SET'
  | 'CHANNEL_INACTIVE'
  | 'CHECKOUT_NOT_FULLY_PAID'
  | 'DELIVERY_METHOD_NOT_APPLICABLE'
  | 'EMAIL_NOT_SET'
  | 'GIFT_CARD_NOT_APPLICABLE'
  | 'GRAPHQL_ERROR'
  | 'INACTIVE_PAYMENT'
  | 'INSUFFICIENT_STOCK'
  | 'INVALID'
  | 'INVALID_SHIPPING_METHOD'
  | 'MISSING_ADDRESS_DATA'
  | 'MISSING_CHANNEL_SLUG'
  | 'NON_EDITABLE_GIFT_LINE'
  | 'NON_REMOVABLE_GIFT_LINE'
  | 'NOT_FOUND'
  | 'NO_LINES'
  | 'PAYMENT_ERROR'
  | 'PRODUCT_NOT_PUBLISHED'
  | 'PRODUCT_UNAVAILABLE_FOR_PURCHASE'
  | 'QUANTITY_GREATER_THAN_LIMIT'
  | 'REQUIRED'
  | 'SHIPPING_ADDRESS_NOT_SET'
  | 'SHIPPING_CHANGE_FORBIDDEN'
  | 'SHIPPING_METHOD_NOT_APPLICABLE'
  | 'SHIPPING_METHOD_NOT_SET'
  | 'SHIPPING_NOT_REQUIRED'
  | 'TAX_ERROR'
  | 'UNAVAILABLE_VARIANT_IN_CHANNEL'
  | 'UNIQUE'
  | 'VOUCHER_NOT_APPLICABLE'
  | 'ZERO_QUANTITY';

export type CheckoutFilterInput = {
  authorizeStatus: InputMaybe<Array<CheckoutAuthorizeStatusEnum>>;
  channels: InputMaybe<Array<Scalars['ID']>>;
  chargeStatus: InputMaybe<Array<CheckoutChargeStatusEnum>>;
  created: InputMaybe<DateRangeInput>;
  customer: InputMaybe<Scalars['String']>;
  metadata: InputMaybe<Array<MetadataFilter>>;
  search: InputMaybe<Scalars['String']>;
  updatedAt: InputMaybe<DateRangeInput>;
};

/** Filter shipping methods for checkout. */
export type CheckoutFilterShippingMethods = Event & {
  __typename: 'CheckoutFilterShippingMethods';
  /** The checkout the event relates to. */
  checkout: Maybe<Checkout>;
  /** Time of the event. */
  issuedAt: Maybe<Scalars['DateTime']>;
  /** The user or application that triggered the event. */
  issuingPrincipal: Maybe<IssuingPrincipal>;
  /** The application receiving the webhook. */
  recipient: Maybe<App>;
  /** Shipping methods that can be used with this checkout. */
  shippingMethods: Maybe<Array<ShippingMethod>>;
  /** Saleor version that triggered the event. */
  version: Maybe<Scalars['String']>;
};

/**
 * Event sent when a checkout was fully authorized. A checkout is considered fully authorized when its `authorizeStatus` is `FULL`.
 *
 * It is triggered only for checkouts whose payments are processed through the Transaction API.
 */
export type CheckoutFullyAuthorized = Event & {
  __typename: 'CheckoutFullyAuthorized';
  /** The checkout the event relates to. */
  checkout: Maybe<Checkout>;
  /** Time of the event. */
  issuedAt: Maybe<Scalars['DateTime']>;
  /** The user or application that triggered the event. */
  issuingPrincipal: Maybe<IssuingPrincipal>;
  /** The application receiving the webhook. */
  recipient: Maybe<App>;
  /** Saleor version that triggered the event. */
  version: Maybe<Scalars['String']>;
};

/**
 * Event sent when a checkout was fully paid. A checkout is considered fully paid when its `chargeStatus` is `FULL` or `OVERCHARGED`. This event is not sent if payments are only authorized but not fully charged.
 *
 * It is triggered only for checkouts whose payments are processed through the Transaction API.
 */
export type CheckoutFullyPaid = Event & {
  __typename: 'CheckoutFullyPaid';
  /** The checkout the event relates to. */
  checkout: Maybe<Checkout>;
  /** Time of the event. */
  issuedAt: Maybe<Scalars['DateTime']>;
  /** The user or application that triggered the event. */
  issuingPrincipal: Maybe<IssuingPrincipal>;
  /** The application receiving the webhook. */
  recipient: Maybe<App>;
  /** Saleor version that triggered the event. */
  version: Maybe<Scalars['String']>;
};

/**
 * Updates language code in the existing checkout.
 *
 * Triggers the following webhook events:
 * - CHECKOUT_UPDATED (async): A checkout was updated.
 */
export type CheckoutLanguageCodeUpdate = {
  __typename: 'CheckoutLanguageCodeUpdate';
  /** An updated checkout. */
  checkout: Maybe<Checkout>;
  /** @deprecated Use `errors` field instead. */
  checkoutErrors: Array<CheckoutError>;
  errors: Array<CheckoutError>;
};

/** Represents an item in the checkout. */
export type CheckoutLine = Node & ObjectWithMetadata & {
  __typename: 'CheckoutLine';
  /** The ID of the checkout line. */
  id: Scalars['ID'];
  /**
   * Determine if the line is a gift.
   *
   * Added in Saleor 3.19.
   *
   * Note: this API is currently in Feature Preview and can be subject to changes at later point.
   */
  isGift: Maybe<Scalars['Boolean']>;
  /** List of public metadata items. Can be accessed without permissions. */
  metadata: Array<MetadataItem>;
  /**
   * A single key from public metadata.
   *
   * Tip: Use GraphQL aliases to fetch multiple keys.
   */
  metafield: Maybe<Scalars['String']>;
  /** Public metadata. Use `keys` to control which fields you want to include. The default is to include everything. */
  metafields: Maybe<Scalars['Metadata']>;
  /**
   * The sum of the checkout line price prior to promotion.
   *
   * Added in Saleor 3.21.
   */
  priorTotalPrice: Maybe<Money>;
  /**
   * The unit price of the checkout line prior to promotion.
   *
   * Added in Saleor 3.21.
   */
  priorUnitPrice: Maybe<Money>;
  /** List of private metadata items. Requires staff permissions to access. */
  privateMetadata: Array<MetadataItem>;
  /**
   * A single key from private metadata. Requires staff permissions to access.
   *
   * Tip: Use GraphQL aliases to fetch multiple keys.
   */
  privateMetafield: Maybe<Scalars['String']>;
  /** Private metadata. Requires staff permissions to access. Use `keys` to control which fields you want to include. The default is to include everything. */
  privateMetafields: Maybe<Scalars['Metadata']>;
  /** List of problems with the checkout line. */
  problems: Maybe<Array<CheckoutLineProblem>>;
  /** The quantity of product variant assigned to the checkout line. */
  quantity: Scalars['Int'];
  /** Indicates whether the item need to be delivered. */
  requiresShipping: Scalars['Boolean'];
  /**
   * The sum of the checkout line price, taxes and discounts.
   *
   * Triggers the following webhook events:
   * - CHECKOUT_CALCULATE_TAXES (sync): Optionally triggered when checkout prices are expired.
   */
  totalPrice: TaxedMoney;
  /** The sum of the checkout line price, without discounts. */
  undiscountedTotalPrice: Money;
  /** The unit price of the checkout line, without discounts. */
  undiscountedUnitPrice: Money;
  /**
   * The unit price of the checkout line, with taxes and discounts.
   *
   * Triggers the following webhook events:
   * - CHECKOUT_CALCULATE_TAXES (sync): Optionally triggered when checkout prices are expired.
   */
  unitPrice: TaxedMoney;
  /** The product variant from which the checkout line was created. */
  variant: ProductVariant;
};


/** Represents an item in the checkout. */
export type CheckoutLineMetafieldArgs = {
  key: Scalars['String'];
};


/** Represents an item in the checkout. */
export type CheckoutLineMetafieldsArgs = {
  keys: InputMaybe<Array<Scalars['String']>>;
};


/** Represents an item in the checkout. */
export type CheckoutLinePrivateMetafieldArgs = {
  key: Scalars['String'];
};


/** Represents an item in the checkout. */
export type CheckoutLinePrivateMetafieldsArgs = {
  keys: InputMaybe<Array<Scalars['String']>>;
};

export type CheckoutLineCountableConnection = {
  __typename: 'CheckoutLineCountableConnection';
  edges: Array<CheckoutLineCountableEdge>;
  /** Pagination data for this connection. */
  pageInfo: PageInfo;
  /** A total count of items in the collection. */
  totalCount: Maybe<Scalars['Int']>;
};

export type CheckoutLineCountableEdge = {
  __typename: 'CheckoutLineCountableEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node: CheckoutLine;
};

/**
 * Deletes a CheckoutLine.
 *
 * Triggers the following webhook events:
 * - CHECKOUT_UPDATED (async): A checkout was updated.
 */
export type CheckoutLineDelete = {
  __typename: 'CheckoutLineDelete';
  /** An updated checkout. */
  checkout: Maybe<Checkout>;
  /** @deprecated Use `errors` field instead. */
  checkoutErrors: Array<CheckoutError>;
  errors: Array<CheckoutError>;
};

export type CheckoutLineInput = {
  /** Flag that allow force splitting the same variant into multiple lines by skipping the matching logic. */
  forceNewLine: InputMaybe<Scalars['Boolean']>;
  /**
   * Fields required to update the object's metadata. Can be read by any API client authorized to read the object it's attached to.
   *
   * Warning: never store sensitive information, including financial data such as credit card details.
   */
  metadata: InputMaybe<Array<MetadataInput>>;
  /** Custom price of the item. Can be set only by apps with `HANDLE_CHECKOUTS` permission. When the line with the same variant will be provided multiple times, the last price will be used. */
  price: InputMaybe<Scalars['PositiveDecimal']>;
  /** The number of items purchased. */
  quantity: Scalars['Int'];
  /** ID of the product variant. */
  variantId: Scalars['ID'];
};

/** Represents an problem in the checkout line. */
export type CheckoutLineProblem = CheckoutLineProblemInsufficientStock | CheckoutLineProblemVariantNotAvailable;

/** Indicates insufficient stock for a given checkout line.Placing the order will not be possible until solving this problem. */
export type CheckoutLineProblemInsufficientStock = {
  __typename: 'CheckoutLineProblemInsufficientStock';
  /** Available quantity of a variant. */
  availableQuantity: Maybe<Scalars['Int']>;
  /** The line that has variant with insufficient stock. */
  line: CheckoutLine;
  /** The variant with insufficient stock. */
  variant: ProductVariant;
};

/** The variant assigned to the checkout line is not available.Placing the order will not be possible until solving this problem. */
export type CheckoutLineProblemVariantNotAvailable = {
  __typename: 'CheckoutLineProblemVariantNotAvailable';
  /** The line that has variant that is not available. */
  line: CheckoutLine;
};

export type CheckoutLineUpdateInput = {
  /** ID of the line. */
  lineId: InputMaybe<Scalars['ID']>;
  /**
   * Checkout line public metadata. Will add and update keys. To delete keys use deleteMetadata mutation.
   *
   * Added in Saleor 3.21. Can be read by any API client authorized to read the object it's attached to.
   *
   * Warning: never store sensitive information, including financial data such as credit card details.
   */
  metadata: InputMaybe<Array<MetadataInput>>;
  /** Custom price of the item. Can be set only by apps with `HANDLE_CHECKOUTS` permission. When the line with the same variant will be provided multiple times, the last price will be used. */
  price: InputMaybe<Scalars['PositiveDecimal']>;
  /** The number of items purchased. Optional for apps, required for any other users. */
  quantity: InputMaybe<Scalars['Int']>;
  /**
   * ID of the product variant.
   * @deprecated Use `lineId` instead.
   */
  variantId: InputMaybe<Scalars['ID']>;
};

/**
 * Adds a checkout line to the existing checkout.If line was already in checkout, its quantity will be increased.
 *
 * Triggers the following webhook events:
 * - CHECKOUT_UPDATED (async): A checkout was updated.
 */
export type CheckoutLinesAdd = {
  __typename: 'CheckoutLinesAdd';
  /** An updated checkout. */
  checkout: Maybe<Checkout>;
  /** @deprecated Use `errors` field instead. */
  checkoutErrors: Array<CheckoutError>;
  errors: Array<CheckoutError>;
};

/**
 * Deletes checkout lines.
 *
 * Triggers the following webhook events:
 * - CHECKOUT_UPDATED (async): A checkout was updated.
 */
export type CheckoutLinesDelete = {
  __typename: 'CheckoutLinesDelete';
  /** An updated checkout. */
  checkout: Maybe<Checkout>;
  errors: Array<CheckoutError>;
};

/**
 * Updates checkout line in the existing checkout.
 *
 * Triggers the following webhook events:
 * - CHECKOUT_UPDATED (async): A checkout was updated.
 */
export type CheckoutLinesUpdate = {
  __typename: 'CheckoutLinesUpdate';
  /** An updated checkout. */
  checkout: Maybe<Checkout>;
  /** @deprecated Use `errors` field instead. */
  checkoutErrors: Array<CheckoutError>;
  errors: Array<CheckoutError>;
};

/** Event sent when checkout metadata is updated. */
export type CheckoutMetadataUpdated = Event & {
  __typename: 'CheckoutMetadataUpdated';
  /** The checkout the event relates to. */
  checkout: Maybe<Checkout>;
  /** Time of the event. */
  issuedAt: Maybe<Scalars['DateTime']>;
  /** The user or application that triggered the event. */
  issuingPrincipal: Maybe<IssuingPrincipal>;
  /** The application receiving the webhook. */
  recipient: Maybe<App>;
  /** Saleor version that triggered the event. */
  version: Maybe<Scalars['String']>;
};

/** Creates a new payment for given checkout. */
export type CheckoutPaymentCreate = {
  __typename: 'CheckoutPaymentCreate';
  /** Related checkout object. */
  checkout: Maybe<Checkout>;
  errors: Array<PaymentError>;
  /** A newly created payment. */
  payment: Maybe<Payment>;
  /** @deprecated Use `errors` field instead. */
  paymentErrors: Array<PaymentError>;
};

/** Represents an problem in the checkout. */
export type CheckoutProblem = CheckoutLineProblemInsufficientStock | CheckoutLineProblemVariantNotAvailable;

/**
 * Remove a gift card or a voucher from a checkout.
 *
 * Triggers the following webhook events:
 * - CHECKOUT_UPDATED (async): A checkout was updated.
 */
export type CheckoutRemovePromoCode = {
  __typename: 'CheckoutRemovePromoCode';
  /** The checkout with the removed gift card or voucher. */
  checkout: Maybe<Checkout>;
  /** @deprecated Use `errors` field instead. */
  checkoutErrors: Array<CheckoutError>;
  errors: Array<CheckoutError>;
};

/** Represents the channel-specific checkout settings. */
export type CheckoutSettings = {
  __typename: 'CheckoutSettings';
  /**
   * The date time defines the earliest checkout creation date on which fully paid checkouts can begin to be automatically completed.
   *
   * Added in Saleor 3.22.
   */
  automaticCompletionCutOffDate: Maybe<Scalars['DateTime']>;
  /**
   * The time in minutes to wait after a checkout is fully paid before automatically completing it.
   *
   * Added in Saleor 3.22.
   */
  automaticCompletionDelay: Maybe<Scalars['Minute']>;
  /**
   * Default `false`. Determines if the paid checkouts should be automatically completed. This setting applies only to checkouts where payment was processed through transactions.When enabled, the checkout will be automatically completed once the checkout `charge_status` reaches `FULL`. This occurs when the total sum of charged and authorized transaction amounts equals or exceeds the checkout's total amount.
   *
   * Added in Saleor 3.20.
   */
  automaticallyCompleteFullyPaidCheckouts: Scalars['Boolean'];
  /** Default `true`. Determines if the checkout mutations should use legacy error flow. In legacy flow, all mutations can raise an exception unrelated to the requested action - (e.g. out-of-stock exception when updating checkoutShippingAddress.) If `false`, the errors will be aggregated in `checkout.problems` field. Some of the `problems` can block the finalizing checkout process. The legacy flow will be removed in Saleor 4.0. The flow with `checkout.problems` will be the default one. */
  useLegacyErrorFlow: Scalars['Boolean'];
};

export type CheckoutSettingsInput = {
  /**
   * Settings for automatic completion of fully paid checkouts.
   *
   * Added in Saleor 3.22.
   */
  automaticCompletion: InputMaybe<CheckoutAutoCompleteInput>;
  /**
   * Default `false`. Determines if the paid checkouts should be automatically completed. This setting applies only to checkouts where payment was processed through transactions.When enabled, the checkout will be automatically completed once the checkout `authorize_status` reaches `FULL`. This occurs when the total sum of charged and authorized transaction amounts equals or exceeds the checkout's total amount.
   *
   * Added in Saleor 3.20.
   * @deprecated Use `automatic_completion` instead.
   */
  automaticallyCompleteFullyPaidCheckouts: InputMaybe<Scalars['Boolean']>;
  /**
   * Default `true`. Determines if the checkout mutations should use legacy error flow. In legacy flow, all mutations can raise an exception unrelated to the requested action - (e.g. out-of-stock exception when updating checkoutShippingAddress.) If `false`, the errors will be aggregated in `checkout.problems` field. Some of the `problems` can block the finalizing checkout process. The legacy flow will be removed in Saleor 4.0. The flow with `checkout.problems` will be the default one.
   * @deprecated Field no longer supported
   */
  useLegacyErrorFlow: InputMaybe<Scalars['Boolean']>;
};

/**
 * Updates shipping address in the existing checkout.
 *
 * Triggers the following webhook events:
 * - CHECKOUT_UPDATED (async): A checkout was updated.
 */
export type CheckoutShippingAddressUpdate = {
  __typename: 'CheckoutShippingAddressUpdate';
  /** An updated checkout. */
  checkout: Maybe<Checkout>;
  /** @deprecated Use `errors` field instead. */
  checkoutErrors: Array<CheckoutError>;
  errors: Array<CheckoutError>;
};

/**
 * Updates the shipping method of the checkout.
 *
 * Triggers the following webhook events:
 * - SHIPPING_LIST_METHODS_FOR_CHECKOUT (sync): Triggered when updating the checkout shipping method with the external one.
 * - CHECKOUT_UPDATED (async): A checkout was updated.
 */
export type CheckoutShippingMethodUpdate = {
  __typename: 'CheckoutShippingMethodUpdate';
  /** An updated checkout. */
  checkout: Maybe<Checkout>;
  /** @deprecated Use `errors` field instead. */
  checkoutErrors: Array<CheckoutError>;
  errors: Array<CheckoutError>;
};

export type CheckoutSortField =
  /** Sort checkouts by creation date. */
  | 'CREATION_DATE'
  /** Sort checkouts by customer. */
  | 'CUSTOMER'
  /** Sort checkouts by payment. */
  | 'PAYMENT';

export type CheckoutSortingInput = {
  /** Specifies the direction in which to sort checkouts. */
  direction: OrderDirection;
  /** Sort checkouts by the selected field. */
  field: CheckoutSortField;
};

/** Event sent when checkout is updated. */
export type CheckoutUpdated = Event & {
  __typename: 'CheckoutUpdated';
  /** The checkout the event relates to. */
  checkout: Maybe<Checkout>;
  /** Time of the event. */
  issuedAt: Maybe<Scalars['DateTime']>;
  /** The user or application that triggered the event. */
  issuingPrincipal: Maybe<IssuingPrincipal>;
  /** The application receiving the webhook. */
  recipient: Maybe<App>;
  /** Saleor version that triggered the event. */
  version: Maybe<Scalars['String']>;
};

export type CheckoutValidationRules = {
  /** The validation rules that can be applied to provided billing address data. */
  billingAddress: InputMaybe<CheckoutAddressValidationRules>;
  /** The validation rules that can be applied to provided shipping address data. */
  shippingAddress: InputMaybe<CheckoutAddressValidationRules>;
};

export type ChoiceValue = {
  __typename: 'ChoiceValue';
  /** The raw name of the choice. */
  raw: Maybe<Scalars['String']>;
  /** The verbose name of the choice. */
  verbose: Maybe<Scalars['String']>;
};

/** Enum determining the state of a circuit breaker. */
export type CircuitBreakerStateEnum =
  /** The breaker is conducting (requests are passing through). */
  | 'CLOSED'
  /** The breaker is in a trial period (to close or open). Note that unlike classic breaker patterns, this is not a state where we are throttling the number of requests, it's a state similar to CLOSED but with different thresholds. */
  | 'HALF_OPEN'
  /** The breaker is tripped (no requests are passing). Breaker will enter half-open state after cooldown period. */
  | 'OPEN';

/** Represents a collection of products. */
export type Collection = Node & ObjectWithMetadata & {
  __typename: 'Collection';
  /** Background image of the collection. */
  backgroundImage: Maybe<Image>;
  /** Channel given to retrieve this collection. Also used by federation gateway to resolve this object in a federated query. */
  channel: Maybe<Scalars['String']>;
  /**
   * List of channels in which the collection is available.
   *
   * Requires one of the following permissions: MANAGE_PRODUCTS.
   */
  channelListings: Maybe<Array<CollectionChannelListing>>;
  /**
   * Description of the collection.
   *
   * Rich text format. For reference see https://editorjs.io/
   */
  description: Maybe<Scalars['JSONString']>;
  /**
   * Description of the collection.
   *
   * Rich text format. For reference see https://editorjs.io/
   * @deprecated Use the `description` field instead.
   */
  descriptionJson: Maybe<Scalars['JSONString']>;
  /** The ID of the collection. */
  id: Scalars['ID'];
  /** List of public metadata items. Can be accessed without permissions. */
  metadata: Array<MetadataItem>;
  /**
   * A single key from public metadata.
   *
   * Tip: Use GraphQL aliases to fetch multiple keys.
   */
  metafield: Maybe<Scalars['String']>;
  /** Public metadata. Use `keys` to control which fields you want to include. The default is to include everything. */
  metafields: Maybe<Scalars['Metadata']>;
  /** Name of the collection. */
  name: Scalars['String'];
  /** List of private metadata items. Requires staff permissions to access. */
  privateMetadata: Array<MetadataItem>;
  /**
   * A single key from private metadata. Requires staff permissions to access.
   *
   * Tip: Use GraphQL aliases to fetch multiple keys.
   */
  privateMetafield: Maybe<Scalars['String']>;
  /** Private metadata. Requires staff permissions to access. Use `keys` to control which fields you want to include. The default is to include everything. */
  privateMetafields: Maybe<Scalars['Metadata']>;
  /** List of products in this collection. */
  products: Maybe<ProductCountableConnection>;
  /** SEO description of the collection. */
  seoDescription: Maybe<Scalars['String']>;
  /** SEO title of the collection. */
  seoTitle: Maybe<Scalars['String']>;
  /** Slug of the collection. */
  slug: Scalars['String'];
  /** Returns translated collection fields for the given language code. */
  translation: Maybe<CollectionTranslation>;
};


/** Represents a collection of products. */
export type CollectionBackgroundImageArgs = {
  format?: InputMaybe<ThumbnailFormatEnum>;
  size: InputMaybe<Scalars['Int']>;
};


/** Represents a collection of products. */
export type CollectionMetafieldArgs = {
  key: Scalars['String'];
};


/** Represents a collection of products. */
export type CollectionMetafieldsArgs = {
  keys: InputMaybe<Array<Scalars['String']>>;
};


/** Represents a collection of products. */
export type CollectionPrivateMetafieldArgs = {
  key: Scalars['String'];
};


/** Represents a collection of products. */
export type CollectionPrivateMetafieldsArgs = {
  keys: InputMaybe<Array<Scalars['String']>>;
};


/** Represents a collection of products. */
export type CollectionProductsArgs = {
  after: InputMaybe<Scalars['String']>;
  before: InputMaybe<Scalars['String']>;
  filter: InputMaybe<ProductFilterInput>;
  first: InputMaybe<Scalars['Int']>;
  last: InputMaybe<Scalars['Int']>;
  search: InputMaybe<Scalars['String']>;
  sortBy: InputMaybe<ProductOrder>;
  where: InputMaybe<ProductWhereInput>;
};


/** Represents a collection of products. */
export type CollectionTranslationArgs = {
  languageCode: LanguageCodeEnum;
};

/**
 * Adds products to a collection.
 *
 * Requires one of the following permissions: MANAGE_PRODUCTS.
 */
export type CollectionAddProducts = {
  __typename: 'CollectionAddProducts';
  /** Collection to which products will be added. */
  collection: Maybe<Collection>;
  /** @deprecated Use `errors` field instead. */
  collectionErrors: Array<CollectionError>;
  errors: Array<CollectionError>;
};

/**
 * Deletes collections.
 *
 * Requires one of the following permissions: MANAGE_PRODUCTS.
 */
export type CollectionBulkDelete = {
  __typename: 'CollectionBulkDelete';
  /** @deprecated Use `errors` field instead. */
  collectionErrors: Array<CollectionError>;
  /** Returns how many objects were affected. */
  count: Scalars['Int'];
  errors: Array<CollectionError>;
};

/** Represents collection channel listing. */
export type CollectionChannelListing = Node & {
  __typename: 'CollectionChannelListing';
  /** The channel to which the collection belongs. */
  channel: Channel;
  /** The ID of the collection channel listing. */
  id: Scalars['ID'];
  /** Indicates if the collection is published in the channel. */
  isPublished: Scalars['Boolean'];
  /** @deprecated Use the `publishedAt` field to fetch the publication date. */
  publicationDate: Maybe<Scalars['Date']>;
  /** The collection publication date. */
  publishedAt: Maybe<Scalars['DateTime']>;
};

export type CollectionChannelListingError = {
  __typename: 'CollectionChannelListingError';
  /** List of attributes IDs which causes the error. */
  attributes: Maybe<Array<Scalars['ID']>>;
  /** List of channels IDs which causes the error. */
  channels: Maybe<Array<Scalars['ID']>>;
  /** The error code. */
  code: ProductErrorCode;
  /** Name of a field that caused the error. A value of `null` indicates that the error isn't associated with a particular field. */
  field: Maybe<Scalars['String']>;
  /** The error message. */
  message: Maybe<Scalars['String']>;
  /** List of attribute values IDs which causes the error. */
  values: Maybe<Array<Scalars['ID']>>;
};

/**
 * Manage collection's availability in channels.
 *
 * Requires one of the following permissions: MANAGE_PRODUCTS.
 */
export type CollectionChannelListingUpdate = {
  __typename: 'CollectionChannelListingUpdate';
  /** An updated collection instance. */
  collection: Maybe<Collection>;
  /** @deprecated Use `errors` field instead. */
  collectionChannelListingErrors: Array<CollectionChannelListingError>;
  errors: Array<CollectionChannelListingError>;
};

export type CollectionChannelListingUpdateInput = {
  /** List of channels to which the collection should be assigned. */
  addChannels: InputMaybe<Array<PublishableChannelListingInput>>;
  /** List of channels from which the collection should be unassigned. */
  removeChannels: InputMaybe<Array<Scalars['ID']>>;
};

/** Represents a connection to a list of collections. */
export type CollectionCountableConnection = {
  __typename: 'CollectionCountableConnection';
  edges: Array<CollectionCountableEdge>;
  /** Pagination data for this connection. */
  pageInfo: PageInfo;
  /** A total count of items in the collection. */
  totalCount: Maybe<Scalars['Int']>;
};

export type CollectionCountableEdge = {
  __typename: 'CollectionCountableEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node: Collection;
};

/**
 * Creates a new collection.
 *
 * Requires one of the following permissions: MANAGE_PRODUCTS.
 */
export type CollectionCreate = {
  __typename: 'CollectionCreate';
  collection: Maybe<Collection>;
  /** @deprecated Use `errors` field instead. */
  collectionErrors: Array<CollectionError>;
  errors: Array<CollectionError>;
};

export type CollectionCreateInput = {
  /** Background image file. */
  backgroundImage: InputMaybe<Scalars['Upload']>;
  /** Alt text for an image. */
  backgroundImageAlt: InputMaybe<Scalars['String']>;
  /**
   * Description of the collection.
   *
   * Rich text format. For reference see https://editorjs.io/
   */
  description: InputMaybe<Scalars['JSONString']>;
  /** Informs whether a collection is published. */
  isPublished: InputMaybe<Scalars['Boolean']>;
  /**
   * Fields required to update the collection metadata. Can be read by any API client authorized to read the object it's attached to.
   *
   * Warning: never store sensitive information, including financial data such as credit card details.
   */
  metadata: InputMaybe<Array<MetadataInput>>;
  /** Name of the collection. */
  name: InputMaybe<Scalars['String']>;
  /**
   * Fields required to update the collection private metadata. Requires permissions to modify and to read the metadata of the object it's attached to.
   *
   * Warning: never store sensitive information, including financial data such as credit card details.
   */
  privateMetadata: InputMaybe<Array<MetadataInput>>;
  /** List of products to be added to the collection. */
  products: InputMaybe<Array<Scalars['ID']>>;
  /**
   * Publication date. ISO 8601 standard.
   * @deprecated Field no longer supported
   */
  publicationDate: InputMaybe<Scalars['Date']>;
  /** Search engine optimization fields. */
  seo: InputMaybe<SeoInput>;
  /** Slug of the collection. */
  slug: InputMaybe<Scalars['String']>;
};

/** Event sent when new collection is created. */
export type CollectionCreated = Event & {
  __typename: 'CollectionCreated';
  /** The collection the event relates to. */
  collection: Maybe<Collection>;
  /** Time of the event. */
  issuedAt: Maybe<Scalars['DateTime']>;
  /** The user or application that triggered the event. */
  issuingPrincipal: Maybe<IssuingPrincipal>;
  /** The application receiving the webhook. */
  recipient: Maybe<App>;
  /** Saleor version that triggered the event. */
  version: Maybe<Scalars['String']>;
};


/** Event sent when new collection is created. */
export type CollectionCreatedCollectionArgs = {
  channel: InputMaybe<Scalars['String']>;
};

/**
 * Deletes a collection.
 *
 * Requires one of the following permissions: MANAGE_PRODUCTS.
 */
export type CollectionDelete = {
  __typename: 'CollectionDelete';
  collection: Maybe<Collection>;
  /** @deprecated Use `errors` field instead. */
  collectionErrors: Array<CollectionError>;
  errors: Array<CollectionError>;
};

/** Event sent when collection is deleted. */
export type CollectionDeleted = Event & {
  __typename: 'CollectionDeleted';
  /** The collection the event relates to. */
  collection: Maybe<Collection>;
  /** Time of the event. */
  issuedAt: Maybe<Scalars['DateTime']>;
  /** The user or application that triggered the event. */
  issuingPrincipal: Maybe<IssuingPrincipal>;
  /** The application receiving the webhook. */
  recipient: Maybe<App>;
  /** Saleor version that triggered the event. */
  version: Maybe<Scalars['String']>;
};


/** Event sent when collection is deleted. */
export type CollectionDeletedCollectionArgs = {
  channel: InputMaybe<Scalars['String']>;
};

export type CollectionError = {
  __typename: 'CollectionError';
  /** The error code. */
  code: CollectionErrorCode;
  /** Name of a field that caused the error. A value of `null` indicates that the error isn't associated with a particular field. */
  field: Maybe<Scalars['String']>;
  /** The error message. */
  message: Maybe<Scalars['String']>;
  /** List of products IDs which causes the error. */
  products: Maybe<Array<Scalars['ID']>>;
};

export type CollectionErrorCode =
  | 'CANNOT_MANAGE_PRODUCT_WITHOUT_VARIANT'
  | 'DUPLICATED_INPUT_ITEM'
  | 'GRAPHQL_ERROR'
  | 'INVALID'
  | 'NOT_FOUND'
  | 'REQUIRED'
  | 'UNIQUE';

export type CollectionFilterInput = {
  /**
   * Specifies the channel by which the data should be filtered.
   * @deprecated Use root-level channel argument instead.
   */
  channel: InputMaybe<Scalars['String']>;
  ids: InputMaybe<Array<Scalars['ID']>>;
  metadata: InputMaybe<Array<MetadataFilter>>;
  published: InputMaybe<CollectionPublished>;
  search: InputMaybe<Scalars['String']>;
  slugs: InputMaybe<Array<Scalars['String']>>;
};

export type CollectionInput = {
  /** Background image file. */
  backgroundImage: InputMaybe<Scalars['Upload']>;
  /** Alt text for an image. */
  backgroundImageAlt: InputMaybe<Scalars['String']>;
  /**
   * Description of the collection.
   *
   * Rich text format. For reference see https://editorjs.io/
   */
  description: InputMaybe<Scalars['JSONString']>;
  /** Informs whether a collection is published. */
  isPublished: InputMaybe<Scalars['Boolean']>;
  /**
   * Fields required to update the collection metadata. Can be read by any API client authorized to read the object it's attached to.
   *
   * Warning: never store sensitive information, including financial data such as credit card details.
   */
  metadata: InputMaybe<Array<MetadataInput>>;
  /** Name of the collection. */
  name: InputMaybe<Scalars['String']>;
  /**
   * Fields required to update the collection private metadata. Requires permissions to modify and to read the metadata of the object it's attached to.
   *
   * Warning: never store sensitive information, including financial data such as credit card details.
   */
  privateMetadata: InputMaybe<Array<MetadataInput>>;
  /**
   * Publication date. ISO 8601 standard.
   * @deprecated Field no longer supported
   */
  publicationDate: InputMaybe<Scalars['Date']>;
  /** Search engine optimization fields. */
  seo: InputMaybe<SeoInput>;
  /** Slug of the collection. */
  slug: InputMaybe<Scalars['String']>;
};

/** Event sent when collection metadata is updated. */
export type CollectionMetadataUpdated = Event & {
  __typename: 'CollectionMetadataUpdated';
  /** The collection the event relates to. */
  collection: Maybe<Collection>;
  /** Time of the event. */
  issuedAt: Maybe<Scalars['DateTime']>;
  /** The user or application that triggered the event. */
  issuingPrincipal: Maybe<IssuingPrincipal>;
  /** The application receiving the webhook. */
  recipient: Maybe<App>;
  /** Saleor version that triggered the event. */
  version: Maybe<Scalars['String']>;
};


/** Event sent when collection metadata is updated. */
export type CollectionMetadataUpdatedCollectionArgs = {
  channel: InputMaybe<Scalars['String']>;
};

export type CollectionPublished =
  | 'HIDDEN'
  | 'PUBLISHED';

/**
 * Remove products from a collection.
 *
 * Requires one of the following permissions: MANAGE_PRODUCTS.
 */
export type CollectionRemoveProducts = {
  __typename: 'CollectionRemoveProducts';
  /** Collection from which products will be removed. */
  collection: Maybe<Collection>;
  /** @deprecated Use `errors` field instead. */
  collectionErrors: Array<CollectionError>;
  errors: Array<CollectionError>;
};

/**
 * Reorder the products of a collection.
 *
 * Requires one of the following permissions: MANAGE_PRODUCTS.
 */
export type CollectionReorderProducts = {
  __typename: 'CollectionReorderProducts';
  /** Collection from which products are reordered. */
  collection: Maybe<Collection>;
  /** @deprecated Use `errors` field instead. */
  collectionErrors: Array<CollectionError>;
  errors: Array<CollectionError>;
};

export type CollectionSortField =
  /**
   * Sort collections by availability.
   *
   * This option requires a channel filter to work as the values can vary between channels.
   */
  | 'AVAILABILITY'
  /** Sort collections by name. */
  | 'NAME'
  /** Sort collections by product count. */
  | 'PRODUCT_COUNT'
  /**
   * Sort collections by publication date.
   *
   * This option requires a channel filter to work as the values can vary between channels.
   */
  | 'PUBLICATION_DATE'
  /**
   * Sort collections by published at.
   *
   * This option requires a channel filter to work as the values can vary between channels.
   */
  | 'PUBLISHED_AT';

export type CollectionSortingInput = {
  /**
   * Specifies the channel in which to sort the data.
   * @deprecated Use root-level channel argument instead.
   */
  channel: InputMaybe<Scalars['String']>;
  /** Specifies the direction in which to sort collections. */
  direction: OrderDirection;
  /** Sort collections by the selected field. */
  field: CollectionSortField;
};

/** Represents collection's original translatable fields and related translations. */
export type CollectionTranslatableContent = Node & {
  __typename: 'CollectionTranslatableContent';
  /**
   * Represents a collection of products.
   * @deprecated Get model fields from the root level queries.
   */
  collection: Maybe<Collection>;
  /** The ID of the collection to translate. */
  collectionId: Scalars['ID'];
  /**
   * Collection's description to translate.
   *
   * Rich text format. For reference see https://editorjs.io/
   */
  description: Maybe<Scalars['JSONString']>;
  /**
   * Description of the collection.
   *
   * Rich text format. For reference see https://editorjs.io/
   * @deprecated Use the `description` field instead.
   */
  descriptionJson: Maybe<Scalars['JSONString']>;
  /** The ID of the collection translatable content. */
  id: Scalars['ID'];
  /** Collection's name to translate. */
  name: Scalars['String'];
  /** SEO description to translate. */
  seoDescription: Maybe<Scalars['String']>;
  /** SEO title to translate. */
  seoTitle: Maybe<Scalars['String']>;
  /**
   * Slug to translate
   *
   * Added in Saleor 3.21.
   */
  slug: Maybe<Scalars['String']>;
  /** Returns translated collection fields for the given language code. */
  translation: Maybe<CollectionTranslation>;
};


/** Represents collection's original translatable fields and related translations. */
export type CollectionTranslatableContentTranslationArgs = {
  languageCode: LanguageCodeEnum;
};

/**
 * Creates/updates translations for a collection.
 *
 * Requires one of the following permissions: MANAGE_TRANSLATIONS.
 */
export type CollectionTranslate = {
  __typename: 'CollectionTranslate';
  collection: Maybe<Collection>;
  errors: Array<TranslationError>;
  /** @deprecated Use `errors` field instead. */
  translationErrors: Array<TranslationError>;
};

/** Represents collection translations. */
export type CollectionTranslation = Node & {
  __typename: 'CollectionTranslation';
  /**
   * Translated description of the collection.
   *
   * Rich text format. For reference see https://editorjs.io/
   */
  description: Maybe<Scalars['JSONString']>;
  /**
   * Translated description of the collection.
   *
   * Rich text format. For reference see https://editorjs.io/
   * @deprecated Use the `description` field instead.
   */
  descriptionJson: Maybe<Scalars['JSONString']>;
  /** The ID of the collection translation. */
  id: Scalars['ID'];
  /** Translation language. */
  language: LanguageDisplay;
  /** Translated collection name. */
  name: Maybe<Scalars['String']>;
  /** Translated SEO description. */
  seoDescription: Maybe<Scalars['String']>;
  /** Translated SEO title. */
  seoTitle: Maybe<Scalars['String']>;
  /**
   * Translated collection slug.
   *
   * Added in Saleor 3.21.
   */
  slug: Maybe<Scalars['String']>;
  /** Represents the collection fields to translate. */
  translatableContent: Maybe<CollectionTranslatableContent>;
};

/**
 * Updates a collection.
 *
 * Requires one of the following permissions: MANAGE_PRODUCTS.
 */
export type CollectionUpdate = {
  __typename: 'CollectionUpdate';
  collection: Maybe<Collection>;
  /** @deprecated Use `errors` field instead. */
  collectionErrors: Array<CollectionError>;
  errors: Array<CollectionError>;
};

/** Event sent when collection is updated. */
export type CollectionUpdated = Event & {
  __typename: 'CollectionUpdated';
  /** The collection the event relates to. */
  collection: Maybe<Collection>;
  /** Time of the event. */
  issuedAt: Maybe<Scalars['DateTime']>;
  /** The user or application that triggered the event. */
  issuingPrincipal: Maybe<IssuingPrincipal>;
  /** The application receiving the webhook. */
  recipient: Maybe<App>;
  /** Saleor version that triggered the event. */
  version: Maybe<Scalars['String']>;
};


/** Event sent when collection is updated. */
export type CollectionUpdatedCollectionArgs = {
  channel: InputMaybe<Scalars['String']>;
};

export type CollectionWhereInput = {
  /** List of conditions that must be met. */
  AND: InputMaybe<Array<CollectionWhereInput>>;
  /** A list of conditions of which at least one must be met. */
  OR: InputMaybe<Array<CollectionWhereInput>>;
  ids: InputMaybe<Array<Scalars['ID']>>;
  metadata: InputMaybe<Array<MetadataFilter>>;
};

/** Stores information about a single configuration field. */
export type ConfigurationItem = {
  __typename: 'ConfigurationItem';
  /** Help text for the field. */
  helpText: Maybe<Scalars['String']>;
  /** Label for the field. */
  label: Maybe<Scalars['String']>;
  /** Name of the field. */
  name: Scalars['String'];
  /** Type of the field. */
  type: Maybe<ConfigurationTypeFieldEnum>;
  /** Current value of the field. */
  value: Maybe<Scalars['String']>;
};

export type ConfigurationItemInput = {
  /** Name of the field to update. */
  name: Scalars['String'];
  /** Value of the given field to update. */
  value: InputMaybe<Scalars['String']>;
};

export type ConfigurationTypeFieldEnum =
  | 'BOOLEAN'
  | 'MULTILINE'
  | 'OUTPUT'
  | 'PASSWORD'
  | 'SECRET'
  | 'SECRETMULTILINE'
  | 'STRING';

/**
 * Confirm user account with token sent by email during registration.
 *
 * Triggers the following webhook events:
 * - ACCOUNT_CONFIRMED (async): Account was confirmed.
 */
export type ConfirmAccount = {
  __typename: 'ConfirmAccount';
  /** @deprecated Use `errors` field instead. */
  accountErrors: Array<AccountError>;
  errors: Array<AccountError>;
  /** An activated user account. */
  user: Maybe<User>;
};

/**
 * Confirm the email change of the logged-in user.
 *
 * Requires one of the following permissions: AUTHENTICATED_USER.
 *
 * Triggers the following webhook events:
 * - CUSTOMER_UPDATED (async): A customer account was updated.
 * - NOTIFY_USER (async): A notification that account email change was confirmed.
 * - ACCOUNT_EMAIL_CHANGED (async): An account email was changed.
 */
export type ConfirmEmailChange = {
  __typename: 'ConfirmEmailChange';
  /** @deprecated Use `errors` field instead. */
  accountErrors: Array<AccountError>;
  errors: Array<AccountError>;
  /** A user instance with a new email. */
  user: Maybe<User>;
};

/** Define the filtering options for fields that can contain multiple values. */
export type ContainsFilterInput = {
  /** The field contains all of the specified values. */
  containsAll: InputMaybe<Array<Scalars['String']>>;
  /** The field contains at least one of the specified values. */
  containsAny: InputMaybe<Array<Scalars['String']>>;
};

/**
 * Represents country codes defined by the ISO 3166-1 alpha-2 standard.
 *
 * The `EU` value is DEPRECATED and will be removed in Saleor 3.21.
 */
export type CountryCode =
  | 'AD'
  | 'AE'
  | 'AF'
  | 'AG'
  | 'AI'
  | 'AL'
  | 'AM'
  | 'AO'
  | 'AQ'
  | 'AR'
  | 'AS'
  | 'AT'
  | 'AU'
  | 'AW'
  | 'AX'
  | 'AZ'
  | 'BA'
  | 'BB'
  | 'BD'
  | 'BE'
  | 'BF'
  | 'BG'
  | 'BH'
  | 'BI'
  | 'BJ'
  | 'BL'
  | 'BM'
  | 'BN'
  | 'BO'
  | 'BQ'
  | 'BR'
  | 'BS'
  | 'BT'
  | 'BV'
  | 'BW'
  | 'BY'
  | 'BZ'
  | 'CA'
  | 'CC'
  | 'CD'
  | 'CF'
  | 'CG'
  | 'CH'
  | 'CI'
  | 'CK'
  | 'CL'
  | 'CM'
  | 'CN'
  | 'CO'
  | 'CR'
  | 'CU'
  | 'CV'
  | 'CW'
  | 'CX'
  | 'CY'
  | 'CZ'
  | 'DE'
  | 'DJ'
  | 'DK'
  | 'DM'
  | 'DO'
  | 'DZ'
  | 'EC'
  | 'EE'
  | 'EG'
  | 'EH'
  | 'ER'
  | 'ES'
  | 'ET'
  | 'EU'
  | 'FI'
  | 'FJ'
  | 'FK'
  | 'FM'
  | 'FO'
  | 'FR'
  | 'GA'
  | 'GB'
  | 'GD'
  | 'GE'
  | 'GF'
  | 'GG'
  | 'GH'
  | 'GI'
  | 'GL'
  | 'GM'
  | 'GN'
  | 'GP'
  | 'GQ'
  | 'GR'
  | 'GS'
  | 'GT'
  | 'GU'
  | 'GW'
  | 'GY'
  | 'HK'
  | 'HM'
  | 'HN'
  | 'HR'
  | 'HT'
  | 'HU'
  | 'ID'
  | 'IE'
  | 'IL'
  | 'IM'
  | 'IN'
  | 'IO'
  | 'IQ'
  | 'IR'
  | 'IS'
  | 'IT'
  | 'JE'
  | 'JM'
  | 'JO'
  | 'JP'
  | 'KE'
  | 'KG'
  | 'KH'
  | 'KI'
  | 'KM'
  | 'KN'
  | 'KP'
  | 'KR'
  | 'KW'
  | 'KY'
  | 'KZ'
  | 'LA'
  | 'LB'
  | 'LC'
  | 'LI'
  | 'LK'
  | 'LR'
  | 'LS'
  | 'LT'
  | 'LU'
  | 'LV'
  | 'LY'
  | 'MA'
  | 'MC'
  | 'MD'
  | 'ME'
  | 'MF'
  | 'MG'
  | 'MH'
  | 'MK'
  | 'ML'
  | 'MM'
  | 'MN'
  | 'MO'
  | 'MP'
  | 'MQ'
  | 'MR'
  | 'MS'
  | 'MT'
  | 'MU'
  | 'MV'
  | 'MW'
  | 'MX'
  | 'MY'
  | 'MZ'
  | 'NA'
  | 'NC'
  | 'NE'
  | 'NF'
  | 'NG'
  | 'NI'
  | 'NL'
  | 'NO'
  | 'NP'
  | 'NR'
  | 'NU'
  | 'NZ'
  | 'OM'
  | 'PA'
  | 'PE'
  | 'PF'
  | 'PG'
  | 'PH'
  | 'PK'
  | 'PL'
  | 'PM'
  | 'PN'
  | 'PR'
  | 'PS'
  | 'PT'
  | 'PW'
  | 'PY'
  | 'QA'
  | 'RE'
  | 'RO'
  | 'RS'
  | 'RU'
  | 'RW'
  | 'SA'
  | 'SB'
  | 'SC'
  | 'SD'
  | 'SE'
  | 'SG'
  | 'SH'
  | 'SI'
  | 'SJ'
  | 'SK'
  | 'SL'
  | 'SM'
  | 'SN'
  | 'SO'
  | 'SR'
  | 'SS'
  | 'ST'
  | 'SV'
  | 'SX'
  | 'SY'
  | 'SZ'
  | 'TC'
  | 'TD'
  | 'TF'
  | 'TG'
  | 'TH'
  | 'TJ'
  | 'TK'
  | 'TL'
  | 'TM'
  | 'TN'
  | 'TO'
  | 'TR'
  | 'TT'
  | 'TV'
  | 'TW'
  | 'TZ'
  | 'UA'
  | 'UG'
  | 'UM'
  | 'US'
  | 'UY'
  | 'UZ'
  | 'VA'
  | 'VC'
  | 'VE'
  | 'VG'
  | 'VI'
  | 'VN'
  | 'VU'
  | 'WF'
  | 'WS'
  | 'XK'
  | 'YE'
  | 'YT'
  | 'ZA'
  | 'ZM'
  | 'ZW';

/** Filter by country code. */
export type CountryCodeEnumFilterInput = {
  /** The value equal to. */
  eq: InputMaybe<CountryCode>;
  /** The value not included in. */
  notOneOf: InputMaybe<Array<CountryCode>>;
  /** The value included in. */
  oneOf: InputMaybe<Array<CountryCode>>;
};

export type CountryDisplay = {
  __typename: 'CountryDisplay';
  /** Country code. */
  code: Scalars['String'];
  /** Country name. */
  country: Scalars['String'];
  /**
   * Country tax.
   * @deprecated Always returns `null`. Use `TaxClassCountryRate` type to manage tax rates per country.
   */
  vat: Maybe<Vat>;
};

export type CountryFilterInput = {
  /** Boolean for filtering countries by having shipping zone assigned.If 'true', return countries with shipping zone assigned.If 'false', return countries without any shipping zone assigned.If the argument is not provided (null), return all countries. */
  attachedToShippingZones: InputMaybe<Scalars['Boolean']>;
};

export type CountryRateInput = {
  /** Country in which this rate applies. */
  countryCode: CountryCode;
  /** Tax rate value provided as percentage. Example: provide `23` to represent `23%` tax rate. */
  rate: Scalars['Float'];
};

export type CountryRateUpdateInput = {
  /** Country in which this rate applies. */
  countryCode: CountryCode;
  /** Tax rate value provided as percentage. Example: provide `23` to represent `23%` tax rate. Provide `null` to remove the particular rate. */
  rate: InputMaybe<Scalars['Float']>;
};

/** Create JWT token. */
export type CreateToken = {
  __typename: 'CreateToken';
  /** @deprecated Use `errors` field instead. */
  accountErrors: Array<AccountError>;
  /** CSRF token required to re-generate access token. */
  csrfToken: Maybe<Scalars['String']>;
  errors: Array<AccountError>;
  /** JWT refresh token, required to re-generate access token. */
  refreshToken: Maybe<Scalars['String']>;
  /** JWT token, required to authenticate. */
  token: Maybe<Scalars['String']>;
  /** A user instance. */
  user: Maybe<User>;
};

export type CreditCard = {
  __typename: 'CreditCard';
  /** Card brand. */
  brand: Scalars['String'];
  /** Two-digit number representing the cards expiration month. */
  expMonth: Maybe<Scalars['Int']>;
  /** Four-digit number representing the cards expiration year. */
  expYear: Maybe<Scalars['Int']>;
  /** First 4 digits of the card number. */
  firstDigits: Maybe<Scalars['String']>;
  /** Last 4 digits of the card number. */
  lastDigits: Scalars['String'];
};

/**
 * Deletes customers.
 *
 * Requires one of the following permissions: MANAGE_USERS.
 *
 * Triggers the following webhook events:
 * - CUSTOMER_DELETED (async): A customer account was deleted.
 */
export type CustomerBulkDelete = {
  __typename: 'CustomerBulkDelete';
  /** @deprecated Use `errors` field instead. */
  accountErrors: Array<AccountError>;
  /** Returns how many objects were affected. */
  count: Scalars['Int'];
  errors: Array<AccountError>;
};

export type CustomerBulkResult = {
  __typename: 'CustomerBulkResult';
  /** Customer data. */
  customer: Maybe<User>;
  /** List of errors that occurred during the update attempt. */
  errors: Maybe<Array<CustomerBulkUpdateError>>;
};

/**
 * Updates customers.
 *
 * Requires one of the following permissions: MANAGE_USERS.
 *
 * Triggers the following webhook events:
 * - CUSTOMER_UPDATED (async): A customer account was updated.
 * - CUSTOMER_METADATA_UPDATED (async): Optionally called when customer's metadata was updated.
 */
export type CustomerBulkUpdate = {
  __typename: 'CustomerBulkUpdate';
  /** Returns how many objects were created. */
  count: Scalars['Int'];
  errors: Array<CustomerBulkUpdateError>;
  /** List of the updated customers. */
  results: Array<CustomerBulkResult>;
};

export type CustomerBulkUpdateError = {
  __typename: 'CustomerBulkUpdateError';
  /** The error code. */
  code: CustomerBulkUpdateErrorCode;
  /** The error message. */
  message: Maybe<Scalars['String']>;
  /** Path to field that caused the error. A value of `null` indicates that the error isn't associated with a particular field. */
  path: Maybe<Scalars['String']>;
};

export type CustomerBulkUpdateErrorCode =
  | 'BLANK'
  | 'DUPLICATED_INPUT_ITEM'
  | 'GRAPHQL_ERROR'
  | 'INVALID'
  | 'MAX_LENGTH'
  | 'NOT_FOUND'
  | 'REQUIRED'
  | 'UNIQUE';

export type CustomerBulkUpdateInput = {
  /** External ID of a customer to update. */
  externalReference: InputMaybe<Scalars['String']>;
  /** ID of a customer to update. */
  id: InputMaybe<Scalars['ID']>;
  /** Fields required to update a customer. */
  input: CustomerInput;
};

/**
 * Creates a new customer.
 *
 * Requires one of the following permissions: MANAGE_USERS.
 *
 * Triggers the following webhook events:
 * - CUSTOMER_CREATED (async): A new customer account was created.
 * - CUSTOMER_METADATA_UPDATED (async): Optionally called when customer's metadata was updated.
 * - NOTIFY_USER (async): A notification for setting the password.
 * - ACCOUNT_SET_PASSWORD_REQUESTED (async): Setting a new password for the account is requested.
 */
export type CustomerCreate = {
  __typename: 'CustomerCreate';
  /** @deprecated Use `errors` field instead. */
  accountErrors: Array<AccountError>;
  errors: Array<AccountError>;
  user: Maybe<User>;
};

/** Event sent when new customer user is created. */
export type CustomerCreated = Event & {
  __typename: 'CustomerCreated';
  /** Time of the event. */
  issuedAt: Maybe<Scalars['DateTime']>;
  /** The user or application that triggered the event. */
  issuingPrincipal: Maybe<IssuingPrincipal>;
  /** The application receiving the webhook. */
  recipient: Maybe<App>;
  /** The user the event relates to. */
  user: Maybe<User>;
  /** Saleor version that triggered the event. */
  version: Maybe<Scalars['String']>;
};

/**
 * Deletes a customer.
 *
 * Requires one of the following permissions: MANAGE_USERS.
 *
 * Triggers the following webhook events:
 * - CUSTOMER_DELETED (async): A customer account was deleted.
 */
export type CustomerDelete = {
  __typename: 'CustomerDelete';
  /** @deprecated Use `errors` field instead. */
  accountErrors: Array<AccountError>;
  errors: Array<AccountError>;
  user: Maybe<User>;
};

/** History log of the customer. */
export type CustomerEvent = Node & {
  __typename: 'CustomerEvent';
  /** App that performed the action. */
  app: Maybe<App>;
  /** Number of objects concerned by the event. */
  count: Maybe<Scalars['Int']>;
  /** Date when event happened at in ISO 8601 format. */
  date: Maybe<Scalars['DateTime']>;
  /** The ID of the customer event. */
  id: Scalars['ID'];
  /** Content of the event. */
  message: Maybe<Scalars['String']>;
  /** The concerned order. */
  order: Maybe<Order>;
  /** The concerned order line. */
  orderLine: Maybe<OrderLine>;
  /** Customer event type. */
  type: Maybe<CustomerEventsEnum>;
  /** User who performed the action. */
  user: Maybe<User>;
};

export type CustomerEventsEnum =
  | 'ACCOUNT_ACTIVATED'
  | 'ACCOUNT_CREATED'
  | 'ACCOUNT_DEACTIVATED'
  | 'CUSTOMER_DELETED'
  | 'DIGITAL_LINK_DOWNLOADED'
  | 'EMAIL_ASSIGNED'
  | 'EMAIL_CHANGED'
  | 'EMAIL_CHANGED_REQUEST'
  | 'NAME_ASSIGNED'
  | 'NOTE_ADDED'
  | 'NOTE_ADDED_TO_ORDER'
  | 'PASSWORD_CHANGED'
  | 'PASSWORD_RESET'
  | 'PASSWORD_RESET_LINK_SENT'
  | 'PLACED_ORDER';

export type CustomerFilterInput = {
  dateJoined: InputMaybe<DateRangeInput>;
  /** Filter by ids. */
  ids: InputMaybe<Array<Scalars['ID']>>;
  metadata: InputMaybe<Array<MetadataFilter>>;
  numberOfOrders: InputMaybe<IntRangeInput>;
  placedOrders: InputMaybe<DateRangeInput>;
  search: InputMaybe<Scalars['String']>;
  updatedAt: InputMaybe<DateTimeRangeInput>;
};

export type CustomerInput = {
  /** Billing address of the customer. */
  defaultBillingAddress: InputMaybe<AddressInput>;
  /** Shipping address of the customer. */
  defaultShippingAddress: InputMaybe<AddressInput>;
  /** The unique email address of the user. */
  email: InputMaybe<Scalars['String']>;
  /** External ID of the customer. */
  externalReference: InputMaybe<Scalars['String']>;
  /** Given name. */
  firstName: InputMaybe<Scalars['String']>;
  /** User account is active. */
  isActive: InputMaybe<Scalars['Boolean']>;
  /** User account is confirmed. */
  isConfirmed: InputMaybe<Scalars['Boolean']>;
  /** User language code. */
  languageCode: InputMaybe<LanguageCodeEnum>;
  /** Family name. */
  lastName: InputMaybe<Scalars['String']>;
  /**
   * Fields required to update the user metadata. Can be read by any API client authorized to read the object it's attached to.
   *
   * Warning: never store sensitive information, including financial data such as credit card details.
   */
  metadata: InputMaybe<Array<MetadataInput>>;
  /** A note about the user. */
  note: InputMaybe<Scalars['String']>;
  /**
   * Fields required to update the user private metadata. Requires permissions to modify and to read the metadata of the object it's attached to.
   *
   * Warning: never store sensitive information, including financial data such as credit card details.
   */
  privateMetadata: InputMaybe<Array<MetadataInput>>;
};

/** Event sent when customer user metadata is updated. */
export type CustomerMetadataUpdated = Event & {
  __typename: 'CustomerMetadataUpdated';
  /** Time of the event. */
  issuedAt: Maybe<Scalars['DateTime']>;
  /** The user or application that triggered the event. */
  issuingPrincipal: Maybe<IssuingPrincipal>;
  /** The application receiving the webhook. */
  recipient: Maybe<App>;
  /** The user the event relates to. */
  user: Maybe<User>;
  /** Saleor version that triggered the event. */
  version: Maybe<Scalars['String']>;
};

/**
 * Updates an existing customer.
 *
 * Requires one of the following permissions: MANAGE_USERS.
 *
 * Triggers the following webhook events:
 * - CUSTOMER_UPDATED (async): A new customer account was updated.
 * - CUSTOMER_METADATA_UPDATED (async): Optionally called when customer's metadata was updated.
 */
export type CustomerUpdate = {
  __typename: 'CustomerUpdate';
  /** @deprecated Use `errors` field instead. */
  accountErrors: Array<AccountError>;
  errors: Array<AccountError>;
  user: Maybe<User>;
};

/** Event sent when customer user is updated. */
export type CustomerUpdated = Event & {
  __typename: 'CustomerUpdated';
  /** Time of the event. */
  issuedAt: Maybe<Scalars['DateTime']>;
  /** The user or application that triggered the event. */
  issuingPrincipal: Maybe<IssuingPrincipal>;
  /** The application receiving the webhook. */
  recipient: Maybe<App>;
  /** The user the event relates to. */
  user: Maybe<User>;
  /** Saleor version that triggered the event. */
  version: Maybe<Scalars['String']>;
};

export type CustomerWhereInput = {
  /** List of conditions that must be met. */
  AND: InputMaybe<Array<CustomerWhereInput>>;
  /** A list of conditions of which at least one must be met. */
  OR: InputMaybe<Array<CustomerWhereInput>>;
  /** Filter by addresses data associated with user. */
  addresses: InputMaybe<AddressFilterInput>;
  /** Filter by date joined. */
  dateJoined: InputMaybe<DateTimeRangeInput>;
  /** Filter by email address. */
  email: InputMaybe<StringFilterInput>;
  /** Filter by first name. */
  firstName: InputMaybe<StringFilterInput>;
  ids: InputMaybe<Array<Scalars['ID']>>;
  /** Filter by whether the user is active. */
  isActive: InputMaybe<Scalars['Boolean']>;
  /** Filter by last name. */
  lastName: InputMaybe<StringFilterInput>;
  /** Filter by metadata fields. */
  metadata: InputMaybe<MetadataFilterInput>;
  /** Filter by number of orders placed by the user. */
  numberOfOrders: InputMaybe<IntFilterInput>;
  /** Filter by date when orders were placed. */
  placedOrdersAt: InputMaybe<DateTimeRangeInput>;
  /** Filter by last updated date. */
  updatedAt: InputMaybe<DateTimeRangeInput>;
};

export type DateRangeInput = {
  /** Start date. */
  gte: InputMaybe<Scalars['Date']>;
  /** End date. */
  lte: InputMaybe<Scalars['Date']>;
};

/** Define the filtering options for date time fields. */
export type DateTimeFilterInput = {
  /** The value equal to. */
  eq: InputMaybe<Scalars['DateTime']>;
  /** The value included in. */
  oneOf: InputMaybe<Array<Scalars['DateTime']>>;
  /** The value in range. */
  range: InputMaybe<DateTimeRangeInput>;
};

export type DateTimeRangeInput = {
  /** Start date. */
  gte: InputMaybe<Scalars['DateTime']>;
  /** End date. */
  lte: InputMaybe<Scalars['DateTime']>;
};

/**
 * Deactivate all JWT tokens of the currently authenticated user.
 *
 * Requires one of the following permissions: AUTHENTICATED_USER.
 */
export type DeactivateAllUserTokens = {
  __typename: 'DeactivateAllUserTokens';
  /** @deprecated Use `errors` field instead. */
  accountErrors: Array<AccountError>;
  errors: Array<AccountError>;
};

/** Define the filtering options for decimal fields. */
export type DecimalFilterInput = {
  /** The value equal to. */
  eq: InputMaybe<Scalars['Decimal']>;
  /** The value included in. */
  oneOf: InputMaybe<Array<Scalars['Decimal']>>;
  /** The value in range. */
  range: InputMaybe<DecimalRangeInput>;
};

export type DecimalRangeInput = {
  /** Decimal value greater than or equal to. */
  gte: InputMaybe<Scalars['Decimal']>;
  /** Decimal value less than or equal to. */
  lte: InputMaybe<Scalars['Decimal']>;
};

/** Delete metadata of an object. To use it, you need to have access to the modified object. */
export type DeleteMetadata = {
  __typename: 'DeleteMetadata';
  errors: Array<MetadataError>;
  item: Maybe<ObjectWithMetadata>;
  /** @deprecated Use `errors` field instead. */
  metadataErrors: Array<MetadataError>;
};

/** Delete object's private metadata. To use it, you need to be an authenticated staff user or an app and have access to the modified object. */
export type DeletePrivateMetadata = {
  __typename: 'DeletePrivateMetadata';
  errors: Array<MetadataError>;
  item: Maybe<ObjectWithMetadata>;
  /** @deprecated Use `errors` field instead. */
  metadataErrors: Array<MetadataError>;
};

/** Represents a delivery method chosen for the checkout. `Warehouse` type is used when checkout is marked as "click and collect" and `ShippingMethod` otherwise. */
export type DeliveryMethod = ShippingMethod | Warehouse;

/** Represents digital content associated with a product variant. */
export type DigitalContent = Node & ObjectWithMetadata & {
  __typename: 'DigitalContent';
  /** Indicator for automatic fulfillment of digital content. */
  automaticFulfillment: Scalars['Boolean'];
  /** File associated with digital content. */
  contentFile: Scalars['String'];
  /** The ID of the digital content. */
  id: Scalars['ID'];
  /** Maximum number of allowed downloads for the digital content. */
  maxDownloads: Maybe<Scalars['Int']>;
  /** List of public metadata items. Can be accessed without permissions. */
  metadata: Array<MetadataItem>;
  /**
   * A single key from public metadata.
   *
   * Tip: Use GraphQL aliases to fetch multiple keys.
   */
  metafield: Maybe<Scalars['String']>;
  /** Public metadata. Use `keys` to control which fields you want to include. The default is to include everything. */
  metafields: Maybe<Scalars['Metadata']>;
  /** List of private metadata items. Requires staff permissions to access. */
  privateMetadata: Array<MetadataItem>;
  /**
   * A single key from private metadata. Requires staff permissions to access.
   *
   * Tip: Use GraphQL aliases to fetch multiple keys.
   */
  privateMetafield: Maybe<Scalars['String']>;
  /** Private metadata. Requires staff permissions to access. Use `keys` to control which fields you want to include. The default is to include everything. */
  privateMetafields: Maybe<Scalars['Metadata']>;
  /** Product variant assigned to digital content. */
  productVariant: ProductVariant;
  /** Number of days the URL for the digital content remains valid. */
  urlValidDays: Maybe<Scalars['Int']>;
  /** List of URLs for the digital variant. */
  urls: Maybe<Array<DigitalContentUrl>>;
  /** Default settings indicator for digital content. */
  useDefaultSettings: Scalars['Boolean'];
};


/** Represents digital content associated with a product variant. */
export type DigitalContentMetafieldArgs = {
  key: Scalars['String'];
};


/** Represents digital content associated with a product variant. */
export type DigitalContentMetafieldsArgs = {
  keys: InputMaybe<Array<Scalars['String']>>;
};


/** Represents digital content associated with a product variant. */
export type DigitalContentPrivateMetafieldArgs = {
  key: Scalars['String'];
};


/** Represents digital content associated with a product variant. */
export type DigitalContentPrivateMetafieldsArgs = {
  keys: InputMaybe<Array<Scalars['String']>>;
};

/** A connection to a list of digital content items. */
export type DigitalContentCountableConnection = {
  __typename: 'DigitalContentCountableConnection';
  edges: Array<DigitalContentCountableEdge>;
  /** Pagination data for this connection. */
  pageInfo: PageInfo;
  /** A total count of items in the collection. */
  totalCount: Maybe<Scalars['Int']>;
};

export type DigitalContentCountableEdge = {
  __typename: 'DigitalContentCountableEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node: DigitalContent;
};

/**
 * Create new digital content. This mutation must be sent as a `multipart` request. More detailed specs of the upload format can be found here: https://github.com/jaydenseric/graphql-multipart-request-spec
 *
 * Requires one of the following permissions: MANAGE_PRODUCTS.
 */
export type DigitalContentCreate = {
  __typename: 'DigitalContentCreate';
  content: Maybe<DigitalContent>;
  errors: Array<ProductError>;
  /** @deprecated Use `errors` field instead. */
  productErrors: Array<ProductError>;
  variant: Maybe<ProductVariant>;
};

/**
 * Remove digital content assigned to given variant.
 *
 * Requires one of the following permissions: MANAGE_PRODUCTS.
 */
export type DigitalContentDelete = {
  __typename: 'DigitalContentDelete';
  errors: Array<ProductError>;
  /** @deprecated Use `errors` field instead. */
  productErrors: Array<ProductError>;
  variant: Maybe<ProductVariant>;
};

export type DigitalContentInput = {
  /** Overwrite default automatic_fulfillment setting for variant. */
  automaticFulfillment: InputMaybe<Scalars['Boolean']>;
  /** Determines how many times a download link can be accessed by a customer. */
  maxDownloads: InputMaybe<Scalars['Int']>;
  /**
   * Fields required to update the digital content metadata. Can be read by any API client authorized to read the object it's attached to.
   *
   * Warning: never store sensitive information, including financial data such as credit card details.
   */
  metadata: InputMaybe<Array<MetadataInput>>;
  /**
   * Fields required to update the digital content private metadata. Requires permissions to modify and to read the metadata of the object it's attached to.
   *
   * Warning: never store sensitive information, including financial data such as credit card details.
   */
  privateMetadata: InputMaybe<Array<MetadataInput>>;
  /** Determines for how many days a download link is active since it was generated. */
  urlValidDays: InputMaybe<Scalars['Int']>;
  /** Use default digital content settings for this product. */
  useDefaultSettings: Scalars['Boolean'];
};

/**
 * Updates digital content.
 *
 * Requires one of the following permissions: MANAGE_PRODUCTS.
 */
export type DigitalContentUpdate = {
  __typename: 'DigitalContentUpdate';
  content: Maybe<DigitalContent>;
  errors: Array<ProductError>;
  /** @deprecated Use `errors` field instead. */
  productErrors: Array<ProductError>;
  variant: Maybe<ProductVariant>;
};

export type DigitalContentUploadInput = {
  /** Overwrite default automatic_fulfillment setting for variant. */
  automaticFulfillment: InputMaybe<Scalars['Boolean']>;
  /** Represents an file in a multipart request. */
  contentFile: Scalars['Upload'];
  /** Determines how many times a download link can be accessed by a customer. */
  maxDownloads: InputMaybe<Scalars['Int']>;
  /**
   * Fields required to update the digital content metadata. Can be read by any API client authorized to read the object it's attached to.
   *
   * Warning: never store sensitive information, including financial data such as credit card details.
   */
  metadata: InputMaybe<Array<MetadataInput>>;
  /**
   * Fields required to update the digital content private metadata. Requires permissions to modify and to read the metadata of the object it's attached to.
   *
   * Warning: never store sensitive information, including financial data such as credit card details.
   */
  privateMetadata: InputMaybe<Array<MetadataInput>>;
  /** Determines for how many days a download link is active since it was generated. */
  urlValidDays: InputMaybe<Scalars['Int']>;
  /** Use default digital content settings for this product. */
  useDefaultSettings: Scalars['Boolean'];
};

/** Represents a URL for digital content. */
export type DigitalContentUrl = Node & {
  __typename: 'DigitalContentUrl';
  /** Digital content associated with the URL. */
  content: DigitalContent;
  /** Date and time when the digital content URL was created. */
  created: Scalars['DateTime'];
  /** Number of times digital content has been downloaded. */
  downloadNum: Scalars['Int'];
  /** The ID of the digital content URL. */
  id: Scalars['ID'];
  /** UUID of digital content. */
  token: Scalars['UUID'];
  /** URL for digital content. */
  url: Maybe<Scalars['String']>;
};

/**
 * Generate new URL to digital content.
 *
 * Requires one of the following permissions: MANAGE_PRODUCTS.
 */
export type DigitalContentUrlCreate = {
  __typename: 'DigitalContentUrlCreate';
  digitalContentUrl: Maybe<DigitalContentUrl>;
  errors: Array<ProductError>;
  /** @deprecated Use `errors` field instead. */
  productErrors: Array<ProductError>;
};

export type DigitalContentUrlCreateInput = {
  /** Digital content ID which URL will belong to. */
  content: Scalars['ID'];
};

export type DiscountError = {
  __typename: 'DiscountError';
  /** List of channels IDs which causes the error. */
  channels: Maybe<Array<Scalars['ID']>>;
  /** The error code. */
  code: DiscountErrorCode;
  /** Name of a field that caused the error. A value of `null` indicates that the error isn't associated with a particular field. */
  field: Maybe<Scalars['String']>;
  /** The error message. */
  message: Maybe<Scalars['String']>;
  /** List of products IDs which causes the error. */
  products: Maybe<Array<Scalars['ID']>>;
  /**
   * List of voucher codes which causes the error.
   *
   * Added in Saleor 3.18.
   */
  voucherCodes: Maybe<Array<Scalars['String']>>;
};

export type DiscountErrorCode =
  | 'ALREADY_EXISTS'
  | 'CANNOT_MANAGE_PRODUCT_WITHOUT_VARIANT'
  | 'DUPLICATED_INPUT_ITEM'
  | 'GRAPHQL_ERROR'
  | 'INVALID'
  | 'NOT_FOUND'
  | 'REQUIRED'
  | 'UNIQUE'
  | 'VOUCHER_ALREADY_USED';

export type DiscountStatusEnum =
  | 'ACTIVE'
  | 'EXPIRED'
  | 'SCHEDULED';

export type DiscountValueTypeEnum =
  | 'FIXED'
  | 'PERCENTAGE';

export type DiscountedObjectWhereInput = {
  /** List of conditions that must be met. */
  AND: InputMaybe<Array<DiscountedObjectWhereInput>>;
  /** A list of conditions of which at least one must be met. */
  OR: InputMaybe<Array<DiscountedObjectWhereInput>>;
  /** Filter by the base subtotal price. */
  baseSubtotalPrice: InputMaybe<DecimalFilterInput>;
  /** Filter by the base total price. */
  baseTotalPrice: InputMaybe<DecimalFilterInput>;
};

export type DistanceUnitsEnum =
  | 'CM'
  | 'DM'
  | 'FT'
  | 'INCH'
  | 'KM'
  | 'M'
  | 'MM'
  | 'YD';

/** Represents API domain. */
export type Domain = {
  __typename: 'Domain';
  /** The host name of the domain. */
  host: Scalars['String'];
  /** Inform if SSL is enabled. */
  sslEnabled: Scalars['Boolean'];
  /** The absolute URL of the API. */
  url: Scalars['String'];
};

/**
 * Deletes draft orders.
 *
 * Requires one of the following permissions: MANAGE_ORDERS.
 */
export type DraftOrderBulkDelete = {
  __typename: 'DraftOrderBulkDelete';
  /** Returns how many objects were affected. */
  count: Scalars['Int'];
  errors: Array<OrderError>;
  /** @deprecated Use `errors` field instead. */
  orderErrors: Array<OrderError>;
};

/**
 * Completes creating an order.
 *
 * Requires one of the following permissions: MANAGE_ORDERS.
 */
export type DraftOrderComplete = {
  __typename: 'DraftOrderComplete';
  errors: Array<OrderError>;
  /** Completed order. */
  order: Maybe<Order>;
  /** @deprecated Use `errors` field instead. */
  orderErrors: Array<OrderError>;
};

/**
 * Creates a new draft order.
 *
 * Requires one of the following permissions: MANAGE_ORDERS.
 */
export type DraftOrderCreate = {
  __typename: 'DraftOrderCreate';
  errors: Array<OrderError>;
  order: Maybe<Order>;
  /** @deprecated Use `errors` field instead. */
  orderErrors: Array<OrderError>;
};

export type DraftOrderCreateInput = {
  /** Billing address of the customer. */
  billingAddress: InputMaybe<AddressInput>;
  /** ID of the channel associated with the order. */
  channelId: InputMaybe<Scalars['ID']>;
  /** A note from a customer. Visible by customers in the order summary. */
  customerNote: InputMaybe<Scalars['String']>;
  /**
   * Discount amount for the order.
   * @deprecated Providing a value for the field has no effect. Use `orderDiscountAdd` mutation instead.
   */
  discount: InputMaybe<Scalars['PositiveDecimal']>;
  /** External ID of this order. */
  externalReference: InputMaybe<Scalars['String']>;
  /**
   * Order language code.
   *
   * Added in Saleor 3.21.
   */
  languageCode: InputMaybe<LanguageCodeEnum>;
  /** Variant line input consisting of variant ID and quantity of products. */
  lines: InputMaybe<Array<OrderLineCreateInput>>;
  /**
   * Order public metadata.
   *
   * Added in Saleor 3.21. Can be read by any API client authorized to read the object it's attached to.
   *
   * Warning: never store sensitive information, including financial data such as credit card details.
   */
  metadata: InputMaybe<Array<MetadataInput>>;
  /**
   * Order private metadata.
   *
   * Added in Saleor 3.21. Requires permissions to modify and to read the metadata of the object it's attached to.
   *
   * Warning: never store sensitive information, including financial data such as credit card details.
   */
  privateMetadata: InputMaybe<Array<MetadataInput>>;
  /** URL of a view where users should be redirected to see the order details. URL in RFC 1808 format. */
  redirectUrl: InputMaybe<Scalars['String']>;
  /**
   * Indicates whether the billing address should be saved to the users address book upon draft order completion. Can only be set when a billing address is provided. If not specified along with the address, the default behavior is to not save the address.
   *
   * Added in Saleor 3.21.
   */
  saveBillingAddress: InputMaybe<Scalars['Boolean']>;
  /**
   * Indicates whether the shipping address should be saved to the users address book upon draft order completion.Can only be set when a shipping address is provided. If not specified along with the address, the default behavior is to not save the address.
   *
   * Added in Saleor 3.21.
   */
  saveShippingAddress: InputMaybe<Scalars['Boolean']>;
  /** Shipping address of the customer. */
  shippingAddress: InputMaybe<AddressInput>;
  /** ID of a selected shipping method. */
  shippingMethod: InputMaybe<Scalars['ID']>;
  /** Customer associated with the draft order. */
  user: InputMaybe<Scalars['ID']>;
  /** Email address of the customer. */
  userEmail: InputMaybe<Scalars['String']>;
  /** ID of the voucher associated with the order. */
  voucher: InputMaybe<Scalars['ID']>;
  /**
   * A code of the voucher associated with the order.
   *
   * Added in Saleor 3.18.
   */
  voucherCode: InputMaybe<Scalars['String']>;
};

/** Event sent when new draft order is created. */
export type DraftOrderCreated = Event & {
  __typename: 'DraftOrderCreated';
  /** Time of the event. */
  issuedAt: Maybe<Scalars['DateTime']>;
  /** The user or application that triggered the event. */
  issuingPrincipal: Maybe<IssuingPrincipal>;
  /** The order the event relates to. */
  order: Maybe<Order>;
  /** The application receiving the webhook. */
  recipient: Maybe<App>;
  /** Saleor version that triggered the event. */
  version: Maybe<Scalars['String']>;
};

/**
 * Deletes a draft order.
 *
 * Requires one of the following permissions: MANAGE_ORDERS.
 */
export type DraftOrderDelete = {
  __typename: 'DraftOrderDelete';
  errors: Array<OrderError>;
  order: Maybe<Order>;
  /** @deprecated Use `errors` field instead. */
  orderErrors: Array<OrderError>;
};

/** Event sent when draft order is deleted. */
export type DraftOrderDeleted = Event & {
  __typename: 'DraftOrderDeleted';
  /** Time of the event. */
  issuedAt: Maybe<Scalars['DateTime']>;
  /** The user or application that triggered the event. */
  issuingPrincipal: Maybe<IssuingPrincipal>;
  /** The order the event relates to. */
  order: Maybe<Order>;
  /** The application receiving the webhook. */
  recipient: Maybe<App>;
  /** Saleor version that triggered the event. */
  version: Maybe<Scalars['String']>;
};

export type DraftOrderInput = {
  /** Billing address of the customer. */
  billingAddress: InputMaybe<AddressInput>;
  /** ID of the channel associated with the order. */
  channelId: InputMaybe<Scalars['ID']>;
  /** A note from a customer. Visible by customers in the order summary. */
  customerNote: InputMaybe<Scalars['String']>;
  /**
   * Discount amount for the order.
   * @deprecated Providing a value for the field has no effect. Use `orderDiscountAdd` mutation instead.
   */
  discount: InputMaybe<Scalars['PositiveDecimal']>;
  /** External ID of this order. */
  externalReference: InputMaybe<Scalars['String']>;
  /**
   * Order language code.
   *
   * Added in Saleor 3.21.
   */
  languageCode: InputMaybe<LanguageCodeEnum>;
  /**
   * Order public metadata.
   *
   * Added in Saleor 3.21. Can be read by any API client authorized to read the object it's attached to.
   *
   * Warning: never store sensitive information, including financial data such as credit card details.
   */
  metadata: InputMaybe<Array<MetadataInput>>;
  /**
   * Order private metadata.
   *
   * Added in Saleor 3.21. Requires permissions to modify and to read the metadata of the object it's attached to.
   *
   * Warning: never store sensitive information, including financial data such as credit card details.
   */
  privateMetadata: InputMaybe<Array<MetadataInput>>;
  /** URL of a view where users should be redirected to see the order details. URL in RFC 1808 format. */
  redirectUrl: InputMaybe<Scalars['String']>;
  /**
   * Indicates whether the billing address should be saved to the users address book upon draft order completion. Can only be set when a billing address is provided. If not specified along with the address, the default behavior is to not save the address.
   *
   * Added in Saleor 3.21.
   */
  saveBillingAddress: InputMaybe<Scalars['Boolean']>;
  /**
   * Indicates whether the shipping address should be saved to the users address book upon draft order completion.Can only be set when a shipping address is provided. If not specified along with the address, the default behavior is to not save the address.
   *
   * Added in Saleor 3.21.
   */
  saveShippingAddress: InputMaybe<Scalars['Boolean']>;
  /** Shipping address of the customer. */
  shippingAddress: InputMaybe<AddressInput>;
  /** ID of a selected shipping method. */
  shippingMethod: InputMaybe<Scalars['ID']>;
  /** Customer associated with the draft order. */
  user: InputMaybe<Scalars['ID']>;
  /** Email address of the customer. */
  userEmail: InputMaybe<Scalars['String']>;
  /** ID of the voucher associated with the order. */
  voucher: InputMaybe<Scalars['ID']>;
  /**
   * A code of the voucher associated with the order.
   *
   * Added in Saleor 3.18.
   */
  voucherCode: InputMaybe<Scalars['String']>;
};

/**
 * Deletes order lines.
 *
 * Requires one of the following permissions: MANAGE_ORDERS.
 */
export type DraftOrderLinesBulkDelete = {
  __typename: 'DraftOrderLinesBulkDelete';
  /** Returns how many objects were affected. */
  count: Scalars['Int'];
  errors: Array<OrderError>;
  /** @deprecated Use `errors` field instead. */
  orderErrors: Array<OrderError>;
};

/**
 * Updates a draft order.
 *
 * Requires one of the following permissions: MANAGE_ORDERS.
 */
export type DraftOrderUpdate = {
  __typename: 'DraftOrderUpdate';
  errors: Array<OrderError>;
  order: Maybe<Order>;
  /** @deprecated Use `errors` field instead. */
  orderErrors: Array<OrderError>;
};

/** Event sent when draft order is updated. */
export type DraftOrderUpdated = Event & {
  __typename: 'DraftOrderUpdated';
  /** Time of the event. */
  issuedAt: Maybe<Scalars['DateTime']>;
  /** The user or application that triggered the event. */
  issuingPrincipal: Maybe<IssuingPrincipal>;
  /** The order the event relates to. */
  order: Maybe<Order>;
  /** The application receiving the webhook. */
  recipient: Maybe<App>;
  /** Saleor version that triggered the event. */
  version: Maybe<Scalars['String']>;
};

export type DraftOrderWhereInput = {
  /** List of conditions that must be met. */
  AND: InputMaybe<Array<DraftOrderWhereInput>>;
  /** A list of conditions of which at least one must be met. */
  OR: InputMaybe<Array<DraftOrderWhereInput>>;
  /** Filter by authorize status. */
  authorizeStatus: InputMaybe<OrderAuthorizeStatusEnumFilterInput>;
  /** Filter by billing address of the order. */
  billingAddress: InputMaybe<AddressFilterInput>;
  /** Filter by channel. */
  channelId: InputMaybe<GlobalIdFilterInput>;
  /** Filter by charge status. */
  chargeStatus: InputMaybe<OrderChargeStatusEnumFilterInput>;
  /** Filter order by created at date. */
  createdAt: InputMaybe<DateTimeRangeInput>;
  /** Filter by order events. Each list item represents conditions that must be satisfied by a single object. The filter matches orders that have related objects meeting all specified groups of conditions. */
  events: InputMaybe<Array<OrderEventFilterInput>>;
  ids: InputMaybe<Array<Scalars['ID']>>;
  /** Filter by whether the order uses the click and collect delivery method. */
  isClickAndCollect: InputMaybe<Scalars['Boolean']>;
  /** Filter by line items associated with the order. Each list item represents conditions that must be satisfied by a single object. The filter matches orders that have related objects meeting all specified groups of conditions. */
  lines: InputMaybe<Array<LinesFilterInput>>;
  /** Filter by number of lines in the order. */
  linesCount: InputMaybe<IntFilterInput>;
  /** Filter by metadata fields. */
  metadata: InputMaybe<MetadataFilterInput>;
  /** Filter by order number. */
  number: InputMaybe<IntFilterInput>;
  /** Filter by the product type of related order lines. */
  productTypeId: InputMaybe<GlobalIdFilterInput>;
  /** Filter by shipping address of the order. */
  shippingAddress: InputMaybe<AddressFilterInput>;
  /** Filter by total gross amount of the order. */
  totalGross: InputMaybe<PriceFilterInput>;
  /** Filter by total net amount of the order. */
  totalNet: InputMaybe<PriceFilterInput>;
  /** Filter by transaction data associated with the order. Each list item represents conditions that must be satisfied by a single object. The filter matches orders that have related objects meeting all specified groups of conditions. */
  transactions: InputMaybe<Array<TransactionFilterInput>>;
  /** Filter order by updated at date. */
  updatedAt: InputMaybe<DateTimeRangeInput>;
  /** Filter by user. */
  user: InputMaybe<GlobalIdFilterInput>;
  /** Filter by user email. */
  userEmail: InputMaybe<StringFilterInput>;
  /** Filter by voucher code used in the order. */
  voucherCode: InputMaybe<StringFilterInput>;
};

export type ErrorPolicyEnum =
  /** Save what is possible within a single row. If there are errors in an input data row, try to save it partially and skip the invalid part. */
  | 'IGNORE_FAILED'
  /** Reject all rows if there is at least one error in any of them. */
  | 'REJECT_EVERYTHING'
  /** Reject rows with errors. */
  | 'REJECT_FAILED_ROWS';

export type Event = {
  /** Time of the event. */
  issuedAt: Maybe<Scalars['DateTime']>;
  /** The user or application that triggered the event. */
  issuingPrincipal: Maybe<IssuingPrincipal>;
  /** The application receiving the webhook. */
  recipient: Maybe<App>;
  /** Saleor version that triggered the event. */
  version: Maybe<Scalars['String']>;
};

/** Event delivery. */
export type EventDelivery = Node & {
  __typename: 'EventDelivery';
  /** Event delivery attempts. */
  attempts: Maybe<EventDeliveryAttemptCountableConnection>;
  /** Creation time of an event delivery. */
  createdAt: Scalars['DateTime'];
  /** Webhook event type. */
  eventType: WebhookEventTypeEnum;
  /** The ID of an event delivery. */
  id: Scalars['ID'];
  /** Event payload. */
  payload: Maybe<Scalars['String']>;
  /** Event delivery status. */
  status: EventDeliveryStatusEnum;
};


/** Event delivery. */
export type EventDeliveryAttemptsArgs = {
  after: InputMaybe<Scalars['String']>;
  before: InputMaybe<Scalars['String']>;
  first: InputMaybe<Scalars['Int']>;
  last: InputMaybe<Scalars['Int']>;
  sortBy: InputMaybe<EventDeliveryAttemptSortingInput>;
};

/** Event delivery attempts. */
export type EventDeliveryAttempt = Node & {
  __typename: 'EventDeliveryAttempt';
  /** Event delivery creation date and time. */
  createdAt: Scalars['DateTime'];
  /** Delivery attempt duration. */
  duration: Maybe<Scalars['Float']>;
  /** The ID of Event Delivery Attempt. */
  id: Scalars['ID'];
  /** Request headers for delivery attempt. */
  requestHeaders: Maybe<Scalars['String']>;
  /** Delivery attempt response content. */
  response: Maybe<Scalars['String']>;
  /** Response headers for delivery attempt. */
  responseHeaders: Maybe<Scalars['String']>;
  /** Delivery attempt response status code. */
  responseStatusCode: Maybe<Scalars['Int']>;
  /** Event delivery status. */
  status: EventDeliveryStatusEnum;
  /** Task id for delivery attempt. */
  taskId: Maybe<Scalars['String']>;
};

export type EventDeliveryAttemptCountableConnection = {
  __typename: 'EventDeliveryAttemptCountableConnection';
  edges: Array<EventDeliveryAttemptCountableEdge>;
  /** Pagination data for this connection. */
  pageInfo: PageInfo;
  /** A total count of items in the collection. */
  totalCount: Maybe<Scalars['Int']>;
};

export type EventDeliveryAttemptCountableEdge = {
  __typename: 'EventDeliveryAttemptCountableEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node: EventDeliveryAttempt;
};

export type EventDeliveryAttemptSortField =
  /** Sort event delivery attempts by created at. */
  | 'CREATED_AT';

export type EventDeliveryAttemptSortingInput = {
  /** Specifies the direction in which to sort attempts. */
  direction: OrderDirection;
  /** Sort attempts by the selected field. */
  field: EventDeliveryAttemptSortField;
};

export type EventDeliveryCountableConnection = {
  __typename: 'EventDeliveryCountableConnection';
  edges: Array<EventDeliveryCountableEdge>;
  /** Pagination data for this connection. */
  pageInfo: PageInfo;
  /** A total count of items in the collection. */
  totalCount: Maybe<Scalars['Int']>;
};

export type EventDeliveryCountableEdge = {
  __typename: 'EventDeliveryCountableEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node: EventDelivery;
};

export type EventDeliveryFilterInput = {
  eventType: InputMaybe<WebhookEventTypeEnum>;
  status: InputMaybe<EventDeliveryStatusEnum>;
};

/**
 * Retries event delivery.
 *
 * Requires one of the following permissions: MANAGE_APPS.
 */
export type EventDeliveryRetry = {
  __typename: 'EventDeliveryRetry';
  /** Event delivery. */
  delivery: Maybe<EventDelivery>;
  errors: Array<WebhookError>;
};

export type EventDeliverySortField =
  /** Sort event deliveries by created at. */
  | 'CREATED_AT';

export type EventDeliverySortingInput = {
  /** Specifies the direction in which to sort deliveries. */
  direction: OrderDirection;
  /** Sort deliveries by the selected field. */
  field: EventDeliverySortField;
};

export type EventDeliveryStatusEnum =
  | 'FAILED'
  | 'PENDING'
  | 'SUCCESS';

export type ExportError = {
  __typename: 'ExportError';
  /** The error code. */
  code: ExportErrorCode;
  /** Name of a field that caused the error. A value of `null` indicates that the error isn't associated with a particular field. */
  field: Maybe<Scalars['String']>;
  /** The error message. */
  message: Maybe<Scalars['String']>;
};

export type ExportErrorCode =
  | 'GRAPHQL_ERROR'
  | 'INVALID'
  | 'NOT_FOUND'
  | 'REQUIRED';

/** History log of export file. */
export type ExportEvent = Node & {
  __typename: 'ExportEvent';
  /** App which performed the action. Requires one of the following permissions: OWNER, MANAGE_APPS. */
  app: Maybe<App>;
  /** Date when event happened at in ISO 8601 format. */
  date: Scalars['DateTime'];
  /** The ID of the object. */
  id: Scalars['ID'];
  /** Content of the event. */
  message: Scalars['String'];
  /** Export event type. */
  type: ExportEventsEnum;
  /** User who performed the action. Requires one of the following permissions: OWNER, MANAGE_STAFF. */
  user: Maybe<User>;
};

export type ExportEventsEnum =
  | 'EXPORTED_FILE_SENT'
  | 'EXPORT_DELETED'
  | 'EXPORT_FAILED'
  | 'EXPORT_FAILED_INFO_SENT'
  | 'EXPORT_PENDING'
  | 'EXPORT_SUCCESS';

/** Represents a job data of exported file. */
export type ExportFile = Job & Node & {
  __typename: 'ExportFile';
  /** The app which requests file export. */
  app: Maybe<App>;
  /** Created date time of job in ISO 8601 format. */
  createdAt: Scalars['DateTime'];
  /** List of events associated with the export. */
  events: Maybe<Array<ExportEvent>>;
  /** The ID of the export file. */
  id: Scalars['ID'];
  /** Job message. */
  message: Maybe<Scalars['String']>;
  /** Job status. */
  status: JobStatusEnum;
  /** Date time of job last update in ISO 8601 format. */
  updatedAt: Scalars['DateTime'];
  /** The URL of field to download. */
  url: Maybe<Scalars['String']>;
  /** The user who requests file export. */
  user: Maybe<User>;
};

export type ExportFileCountableConnection = {
  __typename: 'ExportFileCountableConnection';
  edges: Array<ExportFileCountableEdge>;
  /** Pagination data for this connection. */
  pageInfo: PageInfo;
  /** A total count of items in the collection. */
  totalCount: Maybe<Scalars['Int']>;
};

export type ExportFileCountableEdge = {
  __typename: 'ExportFileCountableEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node: ExportFile;
};

export type ExportFileFilterInput = {
  app: InputMaybe<Scalars['String']>;
  createdAt: InputMaybe<DateTimeRangeInput>;
  status: InputMaybe<JobStatusEnum>;
  updatedAt: InputMaybe<DateTimeRangeInput>;
  user: InputMaybe<Scalars['String']>;
};

export type ExportFileSortField =
  | 'CREATED_AT'
  | 'LAST_MODIFIED_AT'
  | 'STATUS'
  | 'UPDATED_AT';

export type ExportFileSortingInput = {
  /** Specifies the direction in which to sort export file. */
  direction: OrderDirection;
  /** Sort export file by the selected field. */
  field: ExportFileSortField;
};

/**
 * Export gift cards to csv file.
 *
 * Requires one of the following permissions: MANAGE_GIFT_CARD.
 *
 * Triggers the following webhook events:
 * - NOTIFY_USER (async): A notification for the exported file.
 * - GIFT_CARD_EXPORT_COMPLETED (async): A notification for the exported file.
 */
export type ExportGiftCards = {
  __typename: 'ExportGiftCards';
  errors: Array<ExportError>;
  /** The newly created export file job which is responsible for export data. */
  exportFile: Maybe<ExportFile>;
};

export type ExportGiftCardsInput = {
  /** Type of exported file. */
  fileType: FileTypesEnum;
  /** Filtering options for gift cards. */
  filter: InputMaybe<GiftCardFilterInput>;
  /** List of gift cards IDs to export. */
  ids: InputMaybe<Array<Scalars['ID']>>;
  /** Determine which gift cards should be exported. */
  scope: ExportScope;
};

export type ExportInfoInput = {
  /** List of attribute ids witch should be exported. */
  attributes: InputMaybe<Array<Scalars['ID']>>;
  /** List of channels ids which should be exported. */
  channels: InputMaybe<Array<Scalars['ID']>>;
  /** List of product fields witch should be exported. */
  fields: InputMaybe<Array<ProductFieldEnum>>;
  /** List of warehouse ids witch should be exported. */
  warehouses: InputMaybe<Array<Scalars['ID']>>;
};

/**
 * Export products to csv file.
 *
 * Requires one of the following permissions: MANAGE_PRODUCTS.
 *
 * Triggers the following webhook events:
 * - NOTIFY_USER (async): A notification for the exported file.
 * - PRODUCT_EXPORT_COMPLETED (async): A notification for the exported file.
 */
export type ExportProducts = {
  __typename: 'ExportProducts';
  errors: Array<ExportError>;
  /** @deprecated Use `errors` field instead. */
  exportErrors: Array<ExportError>;
  /** The newly created export file job which is responsible for export data. */
  exportFile: Maybe<ExportFile>;
};

export type ExportProductsInput = {
  /** Input with info about fields which should be exported. */
  exportInfo: InputMaybe<ExportInfoInput>;
  /** Type of exported file. */
  fileType: FileTypesEnum;
  /** Filtering options for products. */
  filter: InputMaybe<ProductFilterInput>;
  /** List of products IDs to export. */
  ids: InputMaybe<Array<Scalars['ID']>>;
  /** Determine which products should be exported. */
  scope: ExportScope;
};

export type ExportScope =
  /** Export all products. */
  | 'ALL'
  /** Export the filtered products. */
  | 'FILTER'
  /** Export products with given ids. */
  | 'IDS';

/**
 * Export voucher codes to csv/xlsx file.
 *
 * Added in Saleor 3.18.
 *
 * Note: this API is currently in Feature Preview and can be subject to changes at later point.
 *
 * Requires one of the following permissions: MANAGE_DISCOUNTS.
 *
 * Triggers the following webhook events:
 * - VOUCHER_CODE_EXPORT_COMPLETED (async): A notification for the exported file.
 */
export type ExportVoucherCodes = {
  __typename: 'ExportVoucherCodes';
  errors: Array<ExportError>;
  /** The newly created export file job which is responsible for export data. */
  exportFile: Maybe<ExportFile>;
};

export type ExportVoucherCodesInput = {
  /** Type of exported file. */
  fileType: FileTypesEnum;
  /** List of voucher code IDs to export. */
  ids: InputMaybe<Array<Scalars['ID']>>;
  /** The ID of the voucher. If provided, exports all codes belonging to the voucher. */
  voucherId: InputMaybe<Scalars['ID']>;
};

/** External authentication plugin. */
export type ExternalAuthentication = {
  __typename: 'ExternalAuthentication';
  /** ID of external authentication plugin. */
  id: Scalars['String'];
  /** Name of external authentication plugin. */
  name: Maybe<Scalars['String']>;
};

/** Prepare external authentication URL for user by custom plugin. */
export type ExternalAuthenticationUrl = {
  __typename: 'ExternalAuthenticationUrl';
  /** @deprecated Use `errors` field instead. */
  accountErrors: Array<AccountError>;
  /** The data returned by authentication plugin. */
  authenticationData: Maybe<Scalars['JSONString']>;
  errors: Array<AccountError>;
};

/** Logout user by custom plugin. */
export type ExternalLogout = {
  __typename: 'ExternalLogout';
  /** @deprecated Use `errors` field instead. */
  accountErrors: Array<AccountError>;
  errors: Array<AccountError>;
  /** The data returned by authentication plugin. */
  logoutData: Maybe<Scalars['JSONString']>;
};

export type ExternalNotificationError = {
  __typename: 'ExternalNotificationError';
  /** The error code. */
  code: ExternalNotificationErrorCodes;
  /** Name of a field that caused the error. A value of `null` indicates that the error isn't associated with a particular field. */
  field: Maybe<Scalars['String']>;
  /** The error message. */
  message: Maybe<Scalars['String']>;
};

export type ExternalNotificationErrorCodes =
  | 'CHANNEL_INACTIVE'
  | 'INVALID_MODEL_TYPE'
  | 'NOT_FOUND'
  | 'REQUIRED';

/** Trigger sending a notification with the notify plugin method. Serializes nodes provided as ids parameter and includes this data in the notification payload. */
export type ExternalNotificationTrigger = {
  __typename: 'ExternalNotificationTrigger';
  errors: Array<ExternalNotificationError>;
};

export type ExternalNotificationTriggerInput = {
  /** External event type. This field is passed to a plugin as an event type. */
  externalEventType: Scalars['String'];
  /** Additional payload that will be merged with the one based on the business object ID. */
  extraPayload: InputMaybe<Scalars['JSONString']>;
  /** The list of customers or orders node IDs that will be serialized and included in the notification payload. */
  ids: Array<Scalars['ID']>;
};

/** Obtain external access tokens for user by custom plugin. */
export type ExternalObtainAccessTokens = {
  __typename: 'ExternalObtainAccessTokens';
  /** @deprecated Use `errors` field instead. */
  accountErrors: Array<AccountError>;
  /** CSRF token required to re-generate external access token. */
  csrfToken: Maybe<Scalars['String']>;
  errors: Array<AccountError>;
  /** The refresh token, required to re-generate external access token. */
  refreshToken: Maybe<Scalars['String']>;
  /** The token, required to authenticate. */
  token: Maybe<Scalars['String']>;
  /** A user instance. */
  user: Maybe<User>;
};

/** Refresh user's access by custom plugin. */
export type ExternalRefresh = {
  __typename: 'ExternalRefresh';
  /** @deprecated Use `errors` field instead. */
  accountErrors: Array<AccountError>;
  /** CSRF token required to re-generate external access token. */
  csrfToken: Maybe<Scalars['String']>;
  errors: Array<AccountError>;
  /** The refresh token, required to re-generate external access token. */
  refreshToken: Maybe<Scalars['String']>;
  /** The token, required to authenticate. */
  token: Maybe<Scalars['String']>;
  /** A user instance. */
  user: Maybe<User>;
};

/** Verify external authentication data by plugin. */
export type ExternalVerify = {
  __typename: 'ExternalVerify';
  /** @deprecated Use `errors` field instead. */
  accountErrors: Array<AccountError>;
  errors: Array<AccountError>;
  /** Determine if authentication data is valid or not. */
  isValid: Scalars['Boolean'];
  /** User assigned to data. */
  user: Maybe<User>;
  /** External data. */
  verifyData: Maybe<Scalars['JSONString']>;
};

export type File = {
  __typename: 'File';
  /** Content type of the file. */
  contentType: Maybe<Scalars['String']>;
  /** The URL of the file. */
  url: Scalars['String'];
};

export type FileTypesEnum =
  | 'CSV'
  | 'XLSX';

/**
 * Upload a file. This mutation must be sent as a `multipart` request. More detailed specs of the upload format can be found here: https://github.com/jaydenseric/graphql-multipart-request-spec
 *
 * Requires one of the following permissions: AUTHENTICATED_APP, AUTHENTICATED_STAFF_USER.
 */
export type FileUpload = {
  __typename: 'FileUpload';
  errors: Array<UploadError>;
  /** @deprecated Use `errors` field instead. */
  uploadErrors: Array<UploadError>;
  uploadedFile: Maybe<File>;
};

/** Represents order fulfillment. */
export type Fulfillment = Node & ObjectWithMetadata & {
  __typename: 'Fulfillment';
  /** Date and time when fulfillment was created. */
  created: Scalars['DateTime'];
  /** Sequence in which the fulfillments were created for an order. */
  fulfillmentOrder: Scalars['Int'];
  /** ID of the fulfillment. */
  id: Scalars['ID'];
  /** List of lines for the fulfillment. */
  lines: Maybe<Array<FulfillmentLine>>;
  /** List of public metadata items. Can be accessed without permissions. */
  metadata: Array<MetadataItem>;
  /**
   * A single key from public metadata.
   *
   * Tip: Use GraphQL aliases to fetch multiple keys.
   */
  metafield: Maybe<Scalars['String']>;
  /** Public metadata. Use `keys` to control which fields you want to include. The default is to include everything. */
  metafields: Maybe<Scalars['Metadata']>;
  /** List of private metadata items. Requires staff permissions to access. */
  privateMetadata: Array<MetadataItem>;
  /**
   * A single key from private metadata. Requires staff permissions to access.
   *
   * Tip: Use GraphQL aliases to fetch multiple keys.
   */
  privateMetafield: Maybe<Scalars['String']>;
  /** Private metadata. Requires staff permissions to access. Use `keys` to control which fields you want to include. The default is to include everything. */
  privateMetafields: Maybe<Scalars['Metadata']>;
  /** Amount of refunded shipping price. */
  shippingRefundedAmount: Maybe<Money>;
  /** Status of fulfillment. */
  status: FulfillmentStatus;
  /** User-friendly fulfillment status. */
  statusDisplay: Maybe<Scalars['String']>;
  /** Total refunded amount assigned to this fulfillment. */
  totalRefundedAmount: Maybe<Money>;
  /** Fulfillment tracking number. */
  trackingNumber: Scalars['String'];
  /** Warehouse from fulfillment was fulfilled. */
  warehouse: Maybe<Warehouse>;
};


/** Represents order fulfillment. */
export type FulfillmentMetafieldArgs = {
  key: Scalars['String'];
};


/** Represents order fulfillment. */
export type FulfillmentMetafieldsArgs = {
  keys: InputMaybe<Array<Scalars['String']>>;
};


/** Represents order fulfillment. */
export type FulfillmentPrivateMetafieldArgs = {
  key: Scalars['String'];
};


/** Represents order fulfillment. */
export type FulfillmentPrivateMetafieldsArgs = {
  keys: InputMaybe<Array<Scalars['String']>>;
};

/**
 * Approve existing fulfillment.
 *
 * Requires one of the following permissions: MANAGE_ORDERS.
 *
 * Triggers the following webhook events:
 * - FULFILLMENT_APPROVED (async): Fulfillment is approved.
 */
export type FulfillmentApprove = {
  __typename: 'FulfillmentApprove';
  errors: Array<OrderError>;
  /** An approved fulfillment. */
  fulfillment: Maybe<Fulfillment>;
  /** Order which fulfillment was approved. */
  order: Maybe<Order>;
  /** @deprecated Use `errors` field instead. */
  orderErrors: Array<OrderError>;
};

/** Event sent when fulfillment is approved. */
export type FulfillmentApproved = Event & {
  __typename: 'FulfillmentApproved';
  /** The fulfillment the event relates to. */
  fulfillment: Maybe<Fulfillment>;
  /** Time of the event. */
  issuedAt: Maybe<Scalars['DateTime']>;
  /** The user or application that triggered the event. */
  issuingPrincipal: Maybe<IssuingPrincipal>;
  /** If true, send a notification to the customer. */
  notifyCustomer: Scalars['Boolean'];
  /** The order the fulfillment belongs to. */
  order: Maybe<Order>;
  /** The application receiving the webhook. */
  recipient: Maybe<App>;
  /** Saleor version that triggered the event. */
  version: Maybe<Scalars['String']>;
};

/**
 * Cancels existing fulfillment and optionally restocks items.
 *
 * Requires one of the following permissions: MANAGE_ORDERS.
 */
export type FulfillmentCancel = {
  __typename: 'FulfillmentCancel';
  errors: Array<OrderError>;
  /** A canceled fulfillment. */
  fulfillment: Maybe<Fulfillment>;
  /** Order which fulfillment was cancelled. */
  order: Maybe<Order>;
  /** @deprecated Use `errors` field instead. */
  orderErrors: Array<OrderError>;
};

export type FulfillmentCancelInput = {
  /** ID of a warehouse where items will be restocked. Optional when fulfillment is in WAITING_FOR_APPROVAL state. */
  warehouseId: InputMaybe<Scalars['ID']>;
};

/** Event sent when fulfillment is canceled. */
export type FulfillmentCanceled = Event & {
  __typename: 'FulfillmentCanceled';
  /** The fulfillment the event relates to. */
  fulfillment: Maybe<Fulfillment>;
  /** Time of the event. */
  issuedAt: Maybe<Scalars['DateTime']>;
  /** The user or application that triggered the event. */
  issuingPrincipal: Maybe<IssuingPrincipal>;
  /** The order the fulfillment belongs to. */
  order: Maybe<Order>;
  /** The application receiving the webhook. */
  recipient: Maybe<App>;
  /** Saleor version that triggered the event. */
  version: Maybe<Scalars['String']>;
};

/** Event sent when new fulfillment is created. */
export type FulfillmentCreated = Event & {
  __typename: 'FulfillmentCreated';
  /** The fulfillment the event relates to. */
  fulfillment: Maybe<Fulfillment>;
  /** Time of the event. */
  issuedAt: Maybe<Scalars['DateTime']>;
  /** The user or application that triggered the event. */
  issuingPrincipal: Maybe<IssuingPrincipal>;
  /** If true, the app should send a notification to the customer. */
  notifyCustomer: Scalars['Boolean'];
  /** The order the fulfillment belongs to. */
  order: Maybe<Order>;
  /** The application receiving the webhook. */
  recipient: Maybe<App>;
  /** Saleor version that triggered the event. */
  version: Maybe<Scalars['String']>;
};

/** Filter input for order fulfillments data. */
export type FulfillmentFilterInput = {
  /** Filter by metadata fields. */
  metadata: InputMaybe<MetadataFilterInput>;
  /** Filter by fulfillment status. */
  status: InputMaybe<FulfillmentStatusEnumFilterInput>;
  /** Filter by fulfillment warehouse. */
  warehouse: InputMaybe<FulfillmentWarehouseFilterInput>;
};

/** Represents line of the fulfillment. */
export type FulfillmentLine = Node & {
  __typename: 'FulfillmentLine';
  /** ID of the fulfillment line. */
  id: Scalars['ID'];
  /** The order line to which the fulfillment line is related. */
  orderLine: Maybe<OrderLine>;
  /** The number of items included in the fulfillment line. */
  quantity: Scalars['Int'];
};

/** Event sent when fulfillment metadata is updated. */
export type FulfillmentMetadataUpdated = Event & {
  __typename: 'FulfillmentMetadataUpdated';
  /** The fulfillment the event relates to. */
  fulfillment: Maybe<Fulfillment>;
  /** Time of the event. */
  issuedAt: Maybe<Scalars['DateTime']>;
  /** The user or application that triggered the event. */
  issuingPrincipal: Maybe<IssuingPrincipal>;
  /** The order the fulfillment belongs to. */
  order: Maybe<Order>;
  /** The application receiving the webhook. */
  recipient: Maybe<App>;
  /** Saleor version that triggered the event. */
  version: Maybe<Scalars['String']>;
};

/**
 * Refund products.
 *
 * Requires one of the following permissions: MANAGE_ORDERS.
 */
export type FulfillmentRefundProducts = {
  __typename: 'FulfillmentRefundProducts';
  errors: Array<OrderError>;
  /** A refunded fulfillment. */
  fulfillment: Maybe<Fulfillment>;
  /** Order which fulfillment was refunded. */
  order: Maybe<Order>;
  /** @deprecated Use `errors` field instead. */
  orderErrors: Array<OrderError>;
};

/**
 * Return products.
 *
 * Requires one of the following permissions: MANAGE_ORDERS.
 */
export type FulfillmentReturnProducts = {
  __typename: 'FulfillmentReturnProducts';
  errors: Array<OrderError>;
  /** Order which fulfillment was returned. */
  order: Maybe<Order>;
  /** @deprecated Use `errors` field instead. */
  orderErrors: Array<OrderError>;
  /** A replace fulfillment. */
  replaceFulfillment: Maybe<Fulfillment>;
  /** A draft order which was created for products with replace flag. */
  replaceOrder: Maybe<Order>;
  /** A return fulfillment. */
  returnFulfillment: Maybe<Fulfillment>;
};

export type FulfillmentStatus =
  | 'CANCELED'
  | 'FULFILLED'
  | 'REFUNDED'
  | 'REFUNDED_AND_RETURNED'
  | 'REPLACED'
  | 'RETURNED'
  | 'WAITING_FOR_APPROVAL';

/** Filter by fulfillment status. */
export type FulfillmentStatusEnumFilterInput = {
  /** The value equal to. */
  eq: InputMaybe<FulfillmentStatus>;
  /** The value included in. */
  oneOf: InputMaybe<Array<FulfillmentStatus>>;
};

/** Event sent when the tracking number is updated. */
export type FulfillmentTrackingNumberUpdated = Event & {
  __typename: 'FulfillmentTrackingNumberUpdated';
  /** The fulfillment the event relates to. */
  fulfillment: Maybe<Fulfillment>;
  /** Time of the event. */
  issuedAt: Maybe<Scalars['DateTime']>;
  /** The user or application that triggered the event. */
  issuingPrincipal: Maybe<IssuingPrincipal>;
  /** The order the fulfillment belongs to. */
  order: Maybe<Order>;
  /** The application receiving the webhook. */
  recipient: Maybe<App>;
  /** Saleor version that triggered the event. */
  version: Maybe<Scalars['String']>;
};

/**
 * Updates a fulfillment for an order.
 *
 * Requires one of the following permissions: MANAGE_ORDERS.
 *
 * Triggers the following webhook events:
 * - FULFILLMENT_TRACKING_NUMBER_UPDATED (async): Fulfillment tracking number is updated.
 */
export type FulfillmentUpdateTracking = {
  __typename: 'FulfillmentUpdateTracking';
  errors: Array<OrderError>;
  /** A fulfillment with updated tracking. */
  fulfillment: Maybe<Fulfillment>;
  /** Order for which fulfillment was updated. */
  order: Maybe<Order>;
  /** @deprecated Use `errors` field instead. */
  orderErrors: Array<OrderError>;
};

export type FulfillmentUpdateTrackingInput = {
  /** If true, send an email notification to the customer. */
  notifyCustomer: InputMaybe<Scalars['Boolean']>;
  /** Fulfillment tracking number. */
  trackingNumber: InputMaybe<Scalars['String']>;
};

/** Filter input for fulfillment warehouses. */
export type FulfillmentWarehouseFilterInput = {
  /** Filter fulfillments by warehouse external reference. */
  externalReference: InputMaybe<StringFilterInput>;
  /** Filter fulfillments by warehouse ID. */
  id: InputMaybe<GlobalIdFilterInput>;
  /** Filter fulfillments by warehouse slug. */
  slug: InputMaybe<StringFilterInput>;
};

/** Payment gateway client configuration key and value pair. */
export type GatewayConfigLine = {
  __typename: 'GatewayConfigLine';
  /** Gateway config key. */
  field: Scalars['String'];
  /** Gateway config value for key. */
  value: Maybe<Scalars['String']>;
};

/** A gift card is a prepaid electronic payment card accepted in stores. They can be used during checkout by providing a valid gift card codes. */
export type GiftCard = Node & ObjectWithMetadata & {
  __typename: 'GiftCard';
  /**
   * App which created the gift card.
   *
   * Requires one of the following permissions: MANAGE_APPS, OWNER.
   */
  app: Maybe<App>;
  /** Slug of the channel where the gift card was bought. */
  boughtInChannel: Maybe<Scalars['String']>;
  /**
   * Gift card code. It can be fetched both by a staff member with 'MANAGE_GIFT_CARD' when gift card hasn't been used yet or a user who bought or issued the gift card.
   *
   * Requires one of the following permissions: MANAGE_GIFT_CARD, OWNER.
   */
  code: Scalars['String'];
  /** Date and time when gift card was created. */
  created: Scalars['DateTime'];
  /** The user who bought or issued a gift card. */
  createdBy: Maybe<User>;
  /**
   * Email address of the user who bought or issued gift card.
   *
   * Requires one of the following permissions: MANAGE_USERS, OWNER.
   */
  createdByEmail: Maybe<Scalars['String']>;
  currentBalance: Money;
  /** Code in format which allows displaying in a user interface. */
  displayCode: Scalars['String'];
  /**
   * End date of gift card.
   * @deprecated Use `expiryDate` field instead.
   */
  endDate: Maybe<Scalars['DateTime']>;
  /**
   * List of events associated with the gift card.
   *
   * Requires one of the following permissions: MANAGE_GIFT_CARD.
   */
  events: Array<GiftCardEvent>;
  /** Expiry date of the gift card. */
  expiryDate: Maybe<Scalars['Date']>;
  /** ID of the gift card. */
  id: Scalars['ID'];
  initialBalance: Money;
  isActive: Scalars['Boolean'];
  /** Last 4 characters of gift card code. */
  last4CodeChars: Scalars['String'];
  /** Date and time when gift card was last used. */
  lastUsedOn: Maybe<Scalars['DateTime']>;
  /** List of public metadata items. Can be accessed without permissions. */
  metadata: Array<MetadataItem>;
  /**
   * A single key from public metadata.
   *
   * Tip: Use GraphQL aliases to fetch multiple keys.
   */
  metafield: Maybe<Scalars['String']>;
  /** Public metadata. Use `keys` to control which fields you want to include. The default is to include everything. */
  metafields: Maybe<Scalars['Metadata']>;
  /** List of private metadata items. Requires staff permissions to access. */
  privateMetadata: Array<MetadataItem>;
  /**
   * A single key from private metadata. Requires staff permissions to access.
   *
   * Tip: Use GraphQL aliases to fetch multiple keys.
   */
  privateMetafield: Maybe<Scalars['String']>;
  /** Private metadata. Requires staff permissions to access. Use `keys` to control which fields you want to include. The default is to include everything. */
  privateMetafields: Maybe<Scalars['Metadata']>;
  /** Related gift card product. */
  product: Maybe<Product>;
  /**
   * Start date of gift card.
   * @deprecated Field no longer supported
   */
  startDate: Maybe<Scalars['DateTime']>;
  /**
   * The gift card tag.
   *
   * Requires one of the following permissions: MANAGE_GIFT_CARD.
   */
  tags: Array<GiftCardTag>;
  /**
   * The customer who used a gift card.
   * @deprecated Field no longer supported
   */
  usedBy: Maybe<User>;
  /**
   * Email address of the customer who used a gift card.
   * @deprecated Field no longer supported
   */
  usedByEmail: Maybe<Scalars['String']>;
  /**
   * The customer who bought a gift card.
   * @deprecated Use `createdBy` field instead.
   */
  user: Maybe<User>;
};


/** A gift card is a prepaid electronic payment card accepted in stores. They can be used during checkout by providing a valid gift card codes. */
export type GiftCardEventsArgs = {
  filter: InputMaybe<GiftCardEventFilterInput>;
};


/** A gift card is a prepaid electronic payment card accepted in stores. They can be used during checkout by providing a valid gift card codes. */
export type GiftCardMetafieldArgs = {
  key: Scalars['String'];
};


/** A gift card is a prepaid electronic payment card accepted in stores. They can be used during checkout by providing a valid gift card codes. */
export type GiftCardMetafieldsArgs = {
  keys: InputMaybe<Array<Scalars['String']>>;
};


/** A gift card is a prepaid electronic payment card accepted in stores. They can be used during checkout by providing a valid gift card codes. */
export type GiftCardPrivateMetafieldArgs = {
  key: Scalars['String'];
};


/** A gift card is a prepaid electronic payment card accepted in stores. They can be used during checkout by providing a valid gift card codes. */
export type GiftCardPrivateMetafieldsArgs = {
  keys: InputMaybe<Array<Scalars['String']>>;
};

/**
 * Activate a gift card.
 *
 * Requires one of the following permissions: MANAGE_GIFT_CARD.
 *
 * Triggers the following webhook events:
 * - GIFT_CARD_STATUS_CHANGED (async): A gift card was activated.
 */
export type GiftCardActivate = {
  __typename: 'GiftCardActivate';
  errors: Array<GiftCardError>;
  /** Activated gift card. */
  giftCard: Maybe<GiftCard>;
  /** @deprecated Use `errors` field instead. */
  giftCardErrors: Array<GiftCardError>;
};

/**
 * Adds note to the gift card.
 *
 * Requires one of the following permissions: MANAGE_GIFT_CARD.
 *
 * Triggers the following webhook events:
 * - GIFT_CARD_UPDATED (async): A gift card was updated.
 */
export type GiftCardAddNote = {
  __typename: 'GiftCardAddNote';
  errors: Array<GiftCardError>;
  /** Gift card note created. */
  event: Maybe<GiftCardEvent>;
  /** Gift card with the note added. */
  giftCard: Maybe<GiftCard>;
};

export type GiftCardAddNoteInput = {
  /** Note message. */
  message: Scalars['String'];
};

/**
 * Activate gift cards.
 *
 * Requires one of the following permissions: MANAGE_GIFT_CARD.
 *
 * Triggers the following webhook events:
 * - GIFT_CARD_STATUS_CHANGED (async): A gift card was activated.
 */
export type GiftCardBulkActivate = {
  __typename: 'GiftCardBulkActivate';
  /** Returns how many objects were affected. */
  count: Scalars['Int'];
  errors: Array<GiftCardError>;
};

/**
 * Creates gift cards.
 *
 * Requires one of the following permissions: MANAGE_GIFT_CARD.
 *
 * Triggers the following webhook events:
 * - GIFT_CARD_CREATED (async): A gift card was created.
 * - NOTIFY_USER (async): A notification for created gift card.
 */
export type GiftCardBulkCreate = {
  __typename: 'GiftCardBulkCreate';
  /** Returns how many objects were created. */
  count: Scalars['Int'];
  errors: Array<GiftCardError>;
  /** List of created gift cards. */
  giftCards: Array<GiftCard>;
};

export type GiftCardBulkCreateInput = {
  /** Balance of the gift card. */
  balance: PriceInput;
  /** The number of cards to issue. */
  count: Scalars['Int'];
  /** The gift card expiry date. */
  expiryDate: InputMaybe<Scalars['Date']>;
  /** Determine if gift card is active. */
  isActive: Scalars['Boolean'];
  /** The gift card tags. */
  tags: InputMaybe<Array<Scalars['String']>>;
};

/**
 * Deactivate gift cards.
 *
 * Requires one of the following permissions: MANAGE_GIFT_CARD.
 *
 * Triggers the following webhook events:
 * - GIFT_CARD_STATUS_CHANGED (async): A gift card was deactivated.
 */
export type GiftCardBulkDeactivate = {
  __typename: 'GiftCardBulkDeactivate';
  /** Returns how many objects were affected. */
  count: Scalars['Int'];
  errors: Array<GiftCardError>;
};

/**
 * Deletes gift cards.
 *
 * Requires one of the following permissions: MANAGE_GIFT_CARD.
 *
 * Triggers the following webhook events:
 * - GIFT_CARD_DELETED (async): A gift card was deleted.
 */
export type GiftCardBulkDelete = {
  __typename: 'GiftCardBulkDelete';
  /** Returns how many objects were affected. */
  count: Scalars['Int'];
  errors: Array<GiftCardError>;
};

export type GiftCardCountableConnection = {
  __typename: 'GiftCardCountableConnection';
  edges: Array<GiftCardCountableEdge>;
  /** Pagination data for this connection. */
  pageInfo: PageInfo;
  /** A total count of items in the collection. */
  totalCount: Maybe<Scalars['Int']>;
};

export type GiftCardCountableEdge = {
  __typename: 'GiftCardCountableEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node: GiftCard;
};

/**
 * Creates a new gift card.
 *
 * Requires one of the following permissions: MANAGE_GIFT_CARD.
 *
 * Triggers the following webhook events:
 * - GIFT_CARD_CREATED (async): A gift card was created.
 * - NOTIFY_USER (async): A notification for created gift card.
 */
export type GiftCardCreate = {
  __typename: 'GiftCardCreate';
  errors: Array<GiftCardError>;
  giftCard: Maybe<GiftCard>;
  /** @deprecated Use `errors` field instead. */
  giftCardErrors: Array<GiftCardError>;
};

export type GiftCardCreateInput = {
  /** The gift card tags to add. */
  addTags: InputMaybe<Array<Scalars['String']>>;
  /** Balance of the gift card. */
  balance: PriceInput;
  /** Slug of a channel from which the email should be sent. */
  channel: InputMaybe<Scalars['String']>;
  /**
   * Code to use the gift card.
   * @deprecated The code is now auto generated.
   */
  code: InputMaybe<Scalars['String']>;
  /**
   * End date of the gift card in ISO 8601 format.
   * @deprecated Use `expiryDate` from `expirySettings` instead.
   */
  endDate: InputMaybe<Scalars['Date']>;
  /** The gift card expiry date. */
  expiryDate: InputMaybe<Scalars['Date']>;
  /** Determine if gift card is active. */
  isActive: Scalars['Boolean'];
  /**
   * Gift Card public metadata.
   *
   * Added in Saleor 3.21. Can be read by any API client authorized to read the object it's attached to.
   *
   * Warning: never store sensitive information, including financial data such as credit card details.
   */
  metadata: InputMaybe<Array<MetadataInput>>;
  /** The gift card note from the staff member. */
  note: InputMaybe<Scalars['String']>;
  /**
   * Gift Card private metadata.
   *
   * Added in Saleor 3.21. Requires permissions to modify and to read the metadata of the object it's attached to.
   *
   * Warning: never store sensitive information, including financial data such as credit card details.
   */
  privateMetadata: InputMaybe<Array<MetadataInput>>;
  /**
   * Start date of the gift card in ISO 8601 format.
   * @deprecated Field no longer supported
   */
  startDate: InputMaybe<Scalars['Date']>;
  /** Email of the customer to whom gift card will be sent. */
  userEmail: InputMaybe<Scalars['String']>;
};

/** Event sent when new gift card is created. */
export type GiftCardCreated = Event & {
  __typename: 'GiftCardCreated';
  /** The gift card the event relates to. */
  giftCard: Maybe<GiftCard>;
  /** Time of the event. */
  issuedAt: Maybe<Scalars['DateTime']>;
  /** The user or application that triggered the event. */
  issuingPrincipal: Maybe<IssuingPrincipal>;
  /** The application receiving the webhook. */
  recipient: Maybe<App>;
  /** Saleor version that triggered the event. */
  version: Maybe<Scalars['String']>;
};

/**
 * Deactivate a gift card.
 *
 * Requires one of the following permissions: MANAGE_GIFT_CARD.
 *
 * Triggers the following webhook events:
 * - GIFT_CARD_STATUS_CHANGED (async): A gift card was deactivated.
 */
export type GiftCardDeactivate = {
  __typename: 'GiftCardDeactivate';
  errors: Array<GiftCardError>;
  /** Deactivated gift card. */
  giftCard: Maybe<GiftCard>;
  /** @deprecated Use `errors` field instead. */
  giftCardErrors: Array<GiftCardError>;
};

/**
 * Deletes gift card.
 *
 * Requires one of the following permissions: MANAGE_GIFT_CARD.
 *
 * Triggers the following webhook events:
 * - GIFT_CARD_DELETED (async): A gift card was deleted.
 */
export type GiftCardDelete = {
  __typename: 'GiftCardDelete';
  errors: Array<GiftCardError>;
  giftCard: Maybe<GiftCard>;
  /** @deprecated Use `errors` field instead. */
  giftCardErrors: Array<GiftCardError>;
};

/** Event sent when gift card is deleted. */
export type GiftCardDeleted = Event & {
  __typename: 'GiftCardDeleted';
  /** The gift card the event relates to. */
  giftCard: Maybe<GiftCard>;
  /** Time of the event. */
  issuedAt: Maybe<Scalars['DateTime']>;
  /** The user or application that triggered the event. */
  issuingPrincipal: Maybe<IssuingPrincipal>;
  /** The application receiving the webhook. */
  recipient: Maybe<App>;
  /** Saleor version that triggered the event. */
  version: Maybe<Scalars['String']>;
};

export type GiftCardError = {
  __typename: 'GiftCardError';
  /** The error code. */
  code: GiftCardErrorCode;
  /** Name of a field that caused the error. A value of `null` indicates that the error isn't associated with a particular field. */
  field: Maybe<Scalars['String']>;
  /** The error message. */
  message: Maybe<Scalars['String']>;
  /** List of tag values that cause the error. */
  tags: Maybe<Array<Scalars['String']>>;
};

export type GiftCardErrorCode =
  | 'ALREADY_EXISTS'
  | 'DUPLICATED_INPUT_ITEM'
  | 'EXPIRED_GIFT_CARD'
  | 'GRAPHQL_ERROR'
  | 'INVALID'
  | 'NOT_FOUND'
  | 'REQUIRED'
  | 'UNIQUE';

/** History log of the gift card. */
export type GiftCardEvent = Node & {
  __typename: 'GiftCardEvent';
  /** App that performed the action. Requires one of the following permissions: MANAGE_APPS, OWNER. */
  app: Maybe<App>;
  /** The gift card balance. */
  balance: Maybe<GiftCardEventBalance>;
  /** Date when event happened at in ISO 8601 format. */
  date: Maybe<Scalars['DateTime']>;
  /** Email of the customer. */
  email: Maybe<Scalars['String']>;
  /** The gift card expiry date. */
  expiryDate: Maybe<Scalars['Date']>;
  /** ID of the event associated with a gift card. */
  id: Scalars['ID'];
  /** Content of the event. */
  message: Maybe<Scalars['String']>;
  /** Previous gift card expiry date. */
  oldExpiryDate: Maybe<Scalars['Date']>;
  /** The list of old gift card tags. */
  oldTags: Maybe<Array<Scalars['String']>>;
  /** The order ID where gift card was used or bought. */
  orderId: Maybe<Scalars['ID']>;
  /** User-friendly number of an order where gift card was used or bought. */
  orderNumber: Maybe<Scalars['String']>;
  /** The list of gift card tags. */
  tags: Maybe<Array<Scalars['String']>>;
  /** Gift card event type. */
  type: Maybe<GiftCardEventsEnum>;
  /** User who performed the action. Requires one of the following permissions: MANAGE_USERS, MANAGE_STAFF, OWNER. */
  user: Maybe<User>;
};

export type GiftCardEventBalance = {
  __typename: 'GiftCardEventBalance';
  /** Current balance of the gift card. */
  currentBalance: Money;
  /** Initial balance of the gift card. */
  initialBalance: Maybe<Money>;
  /** Previous current balance of the gift card. */
  oldCurrentBalance: Maybe<Money>;
  /** Previous initial balance of the gift card. */
  oldInitialBalance: Maybe<Money>;
};

export type GiftCardEventFilterInput = {
  orders: InputMaybe<Array<Scalars['ID']>>;
  type: InputMaybe<GiftCardEventsEnum>;
};

export type GiftCardEventsEnum =
  | 'ACTIVATED'
  | 'BALANCE_RESET'
  | 'BOUGHT'
  | 'DEACTIVATED'
  | 'EXPIRY_DATE_UPDATED'
  | 'ISSUED'
  | 'NOTE_ADDED'
  | 'RESENT'
  | 'SENT_TO_CUSTOMER'
  | 'TAGS_UPDATED'
  | 'UPDATED'
  | 'USED_IN_ORDER';

/** Event sent when gift card export is completed. */
export type GiftCardExportCompleted = Event & {
  __typename: 'GiftCardExportCompleted';
  /** The export file for gift cards. */
  export: Maybe<ExportFile>;
  /** Time of the event. */
  issuedAt: Maybe<Scalars['DateTime']>;
  /** The user or application that triggered the event. */
  issuingPrincipal: Maybe<IssuingPrincipal>;
  /** The application receiving the webhook. */
  recipient: Maybe<App>;
  /** Saleor version that triggered the event. */
  version: Maybe<Scalars['String']>;
};

export type GiftCardFilterInput = {
  code: InputMaybe<Scalars['String']>;
  createdByEmail: InputMaybe<Scalars['String']>;
  currency: InputMaybe<Scalars['String']>;
  currentBalance: InputMaybe<PriceRangeInput>;
  initialBalance: InputMaybe<PriceRangeInput>;
  isActive: InputMaybe<Scalars['Boolean']>;
  metadata: InputMaybe<Array<MetadataFilter>>;
  products: InputMaybe<Array<Scalars['ID']>>;
  tags: InputMaybe<Array<Scalars['String']>>;
  used: InputMaybe<Scalars['Boolean']>;
  usedBy: InputMaybe<Array<Scalars['ID']>>;
};

/** Event sent when gift card metadata is updated. */
export type GiftCardMetadataUpdated = Event & {
  __typename: 'GiftCardMetadataUpdated';
  /** The gift card the event relates to. */
  giftCard: Maybe<GiftCard>;
  /** Time of the event. */
  issuedAt: Maybe<Scalars['DateTime']>;
  /** The user or application that triggered the event. */
  issuingPrincipal: Maybe<IssuingPrincipal>;
  /** The application receiving the webhook. */
  recipient: Maybe<App>;
  /** Saleor version that triggered the event. */
  version: Maybe<Scalars['String']>;
};

/**
 * Resend a gift card.
 *
 * Requires one of the following permissions: MANAGE_GIFT_CARD.
 *
 * Triggers the following webhook events:
 * - NOTIFY_USER (async): A notification for gift card resend.
 */
export type GiftCardResend = {
  __typename: 'GiftCardResend';
  errors: Array<GiftCardError>;
  /** Gift card which has been sent. */
  giftCard: Maybe<GiftCard>;
};

export type GiftCardResendInput = {
  /** Slug of a channel from which the email should be sent. */
  channel: Scalars['String'];
  /** Email to which gift card should be send. */
  email: InputMaybe<Scalars['String']>;
  /** ID of a gift card to resend. */
  id: Scalars['ID'];
};

/** Event sent when gift card is e-mailed. */
export type GiftCardSent = Event & {
  __typename: 'GiftCardSent';
  /** Slug of a channel for which this gift card email was sent. */
  channel: Maybe<Scalars['String']>;
  /** The gift card the event relates to. */
  giftCard: Maybe<GiftCard>;
  /** Time of the event. */
  issuedAt: Maybe<Scalars['DateTime']>;
  /** The user or application that triggered the event. */
  issuingPrincipal: Maybe<IssuingPrincipal>;
  /** The application receiving the webhook. */
  recipient: Maybe<App>;
  /** E-mail address to which gift card was sent. */
  sentToEmail: Maybe<Scalars['String']>;
  /** Saleor version that triggered the event. */
  version: Maybe<Scalars['String']>;
};

/** Gift card related settings from site settings. */
export type GiftCardSettings = {
  __typename: 'GiftCardSettings';
  /** The gift card expiry period settings. */
  expiryPeriod: Maybe<TimePeriod>;
  /** The gift card expiry type settings. */
  expiryType: GiftCardSettingsExpiryTypeEnum;
};

export type GiftCardSettingsError = {
  __typename: 'GiftCardSettingsError';
  /** The error code. */
  code: GiftCardSettingsErrorCode;
  /** Name of a field that caused the error. A value of `null` indicates that the error isn't associated with a particular field. */
  field: Maybe<Scalars['String']>;
  /** The error message. */
  message: Maybe<Scalars['String']>;
};

export type GiftCardSettingsErrorCode =
  | 'GRAPHQL_ERROR'
  | 'INVALID'
  | 'REQUIRED';

export type GiftCardSettingsExpiryTypeEnum =
  | 'EXPIRY_PERIOD'
  | 'NEVER_EXPIRE';

/**
 * Update gift card settings.
 *
 * Requires one of the following permissions: MANAGE_GIFT_CARD.
 */
export type GiftCardSettingsUpdate = {
  __typename: 'GiftCardSettingsUpdate';
  errors: Array<GiftCardSettingsError>;
  /** Gift card settings. */
  giftCardSettings: Maybe<GiftCardSettings>;
};

export type GiftCardSettingsUpdateInput = {
  /** Defines gift card expiry period. */
  expiryPeriod: InputMaybe<TimePeriodInputType>;
  /** Defines gift card default expiry settings. */
  expiryType: InputMaybe<GiftCardSettingsExpiryTypeEnum>;
};

export type GiftCardSortField =
  /** Sort gift cards by created at. */
  | 'CREATED_AT'
  /** Sort gift cards by current balance. */
  | 'CURRENT_BALANCE'
  /** Sort gift cards by product. */
  | 'PRODUCT'
  /** Sort gift cards by used by. */
  | 'USED_BY';

export type GiftCardSortingInput = {
  /** Specifies the direction in which to sort gift cards. */
  direction: OrderDirection;
  /** Sort gift cards by the selected field. */
  field: GiftCardSortField;
};

/** Event sent when gift card status has changed. */
export type GiftCardStatusChanged = Event & {
  __typename: 'GiftCardStatusChanged';
  /** The gift card the event relates to. */
  giftCard: Maybe<GiftCard>;
  /** Time of the event. */
  issuedAt: Maybe<Scalars['DateTime']>;
  /** The user or application that triggered the event. */
  issuingPrincipal: Maybe<IssuingPrincipal>;
  /** The application receiving the webhook. */
  recipient: Maybe<App>;
  /** Saleor version that triggered the event. */
  version: Maybe<Scalars['String']>;
};

/** The gift card tag. */
export type GiftCardTag = Node & {
  __typename: 'GiftCardTag';
  /** ID of the tag associated with a gift card. */
  id: Scalars['ID'];
  /** Name of the tag associated with a gift card. */
  name: Scalars['String'];
};

export type GiftCardTagCountableConnection = {
  __typename: 'GiftCardTagCountableConnection';
  edges: Array<GiftCardTagCountableEdge>;
  /** Pagination data for this connection. */
  pageInfo: PageInfo;
  /** A total count of items in the collection. */
  totalCount: Maybe<Scalars['Int']>;
};

export type GiftCardTagCountableEdge = {
  __typename: 'GiftCardTagCountableEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node: GiftCardTag;
};

export type GiftCardTagFilterInput = {
  search: InputMaybe<Scalars['String']>;
};

/**
 * Update a gift card.
 *
 * Requires one of the following permissions: MANAGE_GIFT_CARD.
 *
 * Triggers the following webhook events:
 * - GIFT_CARD_UPDATED (async): A gift card was updated.
 */
export type GiftCardUpdate = {
  __typename: 'GiftCardUpdate';
  errors: Array<GiftCardError>;
  giftCard: Maybe<GiftCard>;
  /** @deprecated Use `errors` field instead. */
  giftCardErrors: Array<GiftCardError>;
};

export type GiftCardUpdateInput = {
  /** The gift card tags to add. */
  addTags: InputMaybe<Array<Scalars['String']>>;
  /** The gift card balance amount. */
  balanceAmount: InputMaybe<Scalars['PositiveDecimal']>;
  /**
   * End date of the gift card in ISO 8601 format.
   * @deprecated Use `expiryDate` from `expirySettings` instead.
   */
  endDate: InputMaybe<Scalars['Date']>;
  /** The gift card expiry date. */
  expiryDate: InputMaybe<Scalars['Date']>;
  /**
   * Gift Card public metadata.
   *
   * Added in Saleor 3.21. Can be read by any API client authorized to read the object it's attached to.
   *
   * Warning: never store sensitive information, including financial data such as credit card details.
   */
  metadata: InputMaybe<Array<MetadataInput>>;
  /**
   * Gift Card private metadata.
   *
   * Added in Saleor 3.21. Requires permissions to modify and to read the metadata of the object it's attached to.
   *
   * Warning: never store sensitive information, including financial data such as credit card details.
   */
  privateMetadata: InputMaybe<Array<MetadataInput>>;
  /** The gift card tags to remove. */
  removeTags: InputMaybe<Array<Scalars['String']>>;
  /**
   * Start date of the gift card in ISO 8601 format.
   * @deprecated Field no longer supported
   */
  startDate: InputMaybe<Scalars['Date']>;
};

/** Event sent when gift card is updated. */
export type GiftCardUpdated = Event & {
  __typename: 'GiftCardUpdated';
  /** The gift card the event relates to. */
  giftCard: Maybe<GiftCard>;
  /** Time of the event. */
  issuedAt: Maybe<Scalars['DateTime']>;
  /** The user or application that triggered the event. */
  issuingPrincipal: Maybe<IssuingPrincipal>;
  /** The application receiving the webhook. */
  recipient: Maybe<App>;
  /** Saleor version that triggered the event. */
  version: Maybe<Scalars['String']>;
};

/** Define the filtering options for foreign key fields. */
export type GlobalIdFilterInput = {
  /** The value equal to. */
  eq: InputMaybe<Scalars['ID']>;
  /** The value included in. */
  oneOf: InputMaybe<Array<Scalars['ID']>>;
};

/** Represents permission group data. */
export type Group = Node & {
  __typename: 'Group';
  /** List of channels the group has access to. */
  accessibleChannels: Maybe<Array<Channel>>;
  /** The ID of the group. */
  id: Scalars['ID'];
  /** The name of the group. */
  name: Scalars['String'];
  /** List of group permissions */
  permissions: Maybe<Array<Permission>>;
  /** Determine if the group have restricted access to channels. */
  restrictedAccessToChannels: Scalars['Boolean'];
  /** True, if the currently authenticated user has rights to manage a group. */
  userCanManage: Scalars['Boolean'];
  /**
   * List of group users
   *
   * Requires one of the following permissions: MANAGE_STAFF.
   */
  users: Maybe<Array<User>>;
};

export type GroupCountableConnection = {
  __typename: 'GroupCountableConnection';
  edges: Array<GroupCountableEdge>;
  /** Pagination data for this connection. */
  pageInfo: PageInfo;
  /** A total count of items in the collection. */
  totalCount: Maybe<Scalars['Int']>;
};

export type GroupCountableEdge = {
  __typename: 'GroupCountableEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node: Group;
};

export type HttpMethod =
  | 'GET'
  | 'POST';

/** Thumbnail formats for icon images. */
export type IconThumbnailFormatEnum =
  | 'ORIGINAL'
  | 'WEBP';

/** Represents an image. */
export type Image = {
  __typename: 'Image';
  /** Alt text for an image. */
  alt: Maybe<Scalars['String']>;
  /** The URL of the image. */
  url: Scalars['String'];
};

/** Define the filtering options for integer fields. */
export type IntFilterInput = {
  /** The value equal to. */
  eq: InputMaybe<Scalars['Int']>;
  /** The value included in. */
  oneOf: InputMaybe<Array<Scalars['Int']>>;
  /** The value in range. */
  range: InputMaybe<IntRangeInput>;
};

export type IntRangeInput = {
  /** Value greater than or equal to. */
  gte: InputMaybe<Scalars['Int']>;
  /** Value less than or equal to. */
  lte: InputMaybe<Scalars['Int']>;
};

/** Represents an Invoice. */
export type Invoice = Job & Node & ObjectWithMetadata & {
  __typename: 'Invoice';
  /** Date and time at which invoice was created. */
  createdAt: Scalars['DateTime'];
  /**
   * URL to view an invoice.
   * @deprecated Use `url` field.
   */
  externalUrl: Maybe<Scalars['String']>;
  /** The ID of the object. */
  id: Scalars['ID'];
  /** Message associated with an invoice. */
  message: Maybe<Scalars['String']>;
  /** List of public metadata items. Can be accessed without permissions. */
  metadata: Array<MetadataItem>;
  /**
   * A single key from public metadata.
   *
   * Tip: Use GraphQL aliases to fetch multiple keys.
   */
  metafield: Maybe<Scalars['String']>;
  /** Public metadata. Use `keys` to control which fields you want to include. The default is to include everything. */
  metafields: Maybe<Scalars['Metadata']>;
  /** Invoice number. */
  number: Maybe<Scalars['String']>;
  /** Order related to the invoice. */
  order: Maybe<Order>;
  /** List of private metadata items. Requires staff permissions to access. */
  privateMetadata: Array<MetadataItem>;
  /**
   * A single key from private metadata. Requires staff permissions to access.
   *
   * Tip: Use GraphQL aliases to fetch multiple keys.
   */
  privateMetafield: Maybe<Scalars['String']>;
  /** Private metadata. Requires staff permissions to access. Use `keys` to control which fields you want to include. The default is to include everything. */
  privateMetafields: Maybe<Scalars['Metadata']>;
  /** Job status. */
  status: JobStatusEnum;
  /** Date and time at which invoice was updated. */
  updatedAt: Scalars['DateTime'];
  /** URL to view/download an invoice. */
  url: Maybe<Scalars['String']>;
};


/** Represents an Invoice. */
export type InvoiceMetafieldArgs = {
  key: Scalars['String'];
};


/** Represents an Invoice. */
export type InvoiceMetafieldsArgs = {
  keys: InputMaybe<Array<Scalars['String']>>;
};


/** Represents an Invoice. */
export type InvoicePrivateMetafieldArgs = {
  key: Scalars['String'];
};


/** Represents an Invoice. */
export type InvoicePrivateMetafieldsArgs = {
  keys: InputMaybe<Array<Scalars['String']>>;
};

/**
 * Creates a ready to send invoice.
 *
 * Requires one of the following permissions: MANAGE_ORDERS.
 */
export type InvoiceCreate = {
  __typename: 'InvoiceCreate';
  errors: Array<InvoiceError>;
  invoice: Maybe<Invoice>;
  /** @deprecated Use `errors` field instead. */
  invoiceErrors: Array<InvoiceError>;
};

export type InvoiceCreateInput = {
  /**
   * Fields required to update the invoice metadata. Can be read by any API client authorized to read the object it's attached to.
   *
   * Warning: never store sensitive information, including financial data such as credit card details.
   */
  metadata: InputMaybe<Array<MetadataInput>>;
  /** Invoice number. */
  number: Scalars['String'];
  /**
   * Fields required to update the invoice private metadata. Requires permissions to modify and to read the metadata of the object it's attached to.
   *
   * Warning: never store sensitive information, including financial data such as credit card details.
   */
  privateMetadata: InputMaybe<Array<MetadataInput>>;
  /** URL of an invoice to download. */
  url: Scalars['String'];
};

/**
 * Deletes an invoice.
 *
 * Requires one of the following permissions: MANAGE_ORDERS.
 */
export type InvoiceDelete = {
  __typename: 'InvoiceDelete';
  errors: Array<InvoiceError>;
  invoice: Maybe<Invoice>;
  /** @deprecated Use `errors` field instead. */
  invoiceErrors: Array<InvoiceError>;
};

/** Event sent when invoice is deleted. */
export type InvoiceDeleted = Event & {
  __typename: 'InvoiceDeleted';
  /** The invoice the event relates to. */
  invoice: Maybe<Invoice>;
  /** Time of the event. */
  issuedAt: Maybe<Scalars['DateTime']>;
  /** The user or application that triggered the event. */
  issuingPrincipal: Maybe<IssuingPrincipal>;
  /** Order related to the invoice. */
  order: Maybe<Order>;
  /** The application receiving the webhook. */
  recipient: Maybe<App>;
  /** Saleor version that triggered the event. */
  version: Maybe<Scalars['String']>;
};

export type InvoiceError = {
  __typename: 'InvoiceError';
  /** The error code. */
  code: InvoiceErrorCode;
  /** Name of a field that caused the error. A value of `null` indicates that the error isn't associated with a particular field. */
  field: Maybe<Scalars['String']>;
  /** The error message. */
  message: Maybe<Scalars['String']>;
};

export type InvoiceErrorCode =
  | 'EMAIL_NOT_SET'
  | 'INVALID_STATUS'
  | 'NOT_FOUND'
  | 'NOT_READY'
  | 'NO_INVOICE_PLUGIN'
  | 'NUMBER_NOT_SET'
  | 'REQUIRED'
  | 'URL_NOT_SET';

/** Filter input for invoices. */
export type InvoiceFilterInput = {
  /** Filter invoices by creation date. */
  createdAt: InputMaybe<DateTimeRangeInput>;
};

/**
 * Request an invoice for the order using plugin.
 *
 * Requires one of the following permissions: MANAGE_ORDERS.
 *
 * Triggers the following webhook events:
 * - INVOICE_REQUESTED (async): An invoice was requested.
 */
export type InvoiceRequest = {
  __typename: 'InvoiceRequest';
  errors: Array<InvoiceError>;
  invoice: Maybe<Invoice>;
  /** @deprecated Use `errors` field instead. */
  invoiceErrors: Array<InvoiceError>;
  /** Order related to an invoice. */
  order: Maybe<Order>;
};

/**
 * Requests deletion of an invoice.
 *
 * Requires one of the following permissions: MANAGE_ORDERS.
 *
 * Triggers the following webhook events:
 * - INVOICE_DELETED (async): An invoice was requested to delete.
 */
export type InvoiceRequestDelete = {
  __typename: 'InvoiceRequestDelete';
  errors: Array<InvoiceError>;
  invoice: Maybe<Invoice>;
  /** @deprecated Use `errors` field instead. */
  invoiceErrors: Array<InvoiceError>;
};

/** Event sent when invoice is requested. */
export type InvoiceRequested = Event & {
  __typename: 'InvoiceRequested';
  /** The invoice the event relates to. */
  invoice: Maybe<Invoice>;
  /** Time of the event. */
  issuedAt: Maybe<Scalars['DateTime']>;
  /** The user or application that triggered the event. */
  issuingPrincipal: Maybe<IssuingPrincipal>;
  /** Order related to the invoice. */
  order: Order;
  /** The application receiving the webhook. */
  recipient: Maybe<App>;
  /** Saleor version that triggered the event. */
  version: Maybe<Scalars['String']>;
};

/**
 * Send an invoice notification to the customer.
 *
 * Requires one of the following permissions: MANAGE_ORDERS.
 *
 * Triggers the following webhook events:
 * - INVOICE_SENT (async): A notification for invoice send
 * - NOTIFY_USER (async): A notification for invoice send
 */
export type InvoiceSendNotification = {
  __typename: 'InvoiceSendNotification';
  errors: Array<InvoiceError>;
  invoice: Maybe<Invoice>;
  /** @deprecated Use `errors` field instead. */
  invoiceErrors: Array<InvoiceError>;
};

/** Event sent when invoice is sent. */
export type InvoiceSent = Event & {
  __typename: 'InvoiceSent';
  /** The invoice the event relates to. */
  invoice: Maybe<Invoice>;
  /** Time of the event. */
  issuedAt: Maybe<Scalars['DateTime']>;
  /** The user or application that triggered the event. */
  issuingPrincipal: Maybe<IssuingPrincipal>;
  /** Order related to the invoice. */
  order: Maybe<Order>;
  /** The application receiving the webhook. */
  recipient: Maybe<App>;
  /** Saleor version that triggered the event. */
  version: Maybe<Scalars['String']>;
};

/**
 * Updates an invoice.
 *
 * Requires one of the following permissions: MANAGE_ORDERS.
 */
export type InvoiceUpdate = {
  __typename: 'InvoiceUpdate';
  errors: Array<InvoiceError>;
  invoice: Maybe<Invoice>;
  /** @deprecated Use `errors` field instead. */
  invoiceErrors: Array<InvoiceError>;
};

export type IssuingPrincipal = App | User;

export type Job = {
  /** Created date time of job in ISO 8601 format. */
  createdAt: Scalars['DateTime'];
  /** Job message. */
  message: Maybe<Scalars['String']>;
  /** Job status. */
  status: JobStatusEnum;
  /** Date time of job last update in ISO 8601 format. */
  updatedAt: Scalars['DateTime'];
};

export type JobStatusEnum =
  | 'DELETED'
  | 'FAILED'
  | 'PENDING'
  | 'SUCCESS';

/** Language code enum. It contains all the languages supported by Saleor. */
export type LanguageCodeEnum =
  /** Afrikaans */
  | 'AF'
  /** Afrikaans (Namibia) */
  | 'AF_NA'
  /** Afrikaans (South Africa) */
  | 'AF_ZA'
  /** Aghem */
  | 'AGQ'
  /** Aghem (Cameroon) */
  | 'AGQ_CM'
  /** Akan */
  | 'AK'
  /** Akan (Ghana) */
  | 'AK_GH'
  /** Amharic */
  | 'AM'
  /** Amharic (Ethiopia) */
  | 'AM_ET'
  /** Arabic */
  | 'AR'
  /** Arabic (United Arab Emirates) */
  | 'AR_AE'
  /** Arabic (Bahrain) */
  | 'AR_BH'
  /** Arabic (Djibouti) */
  | 'AR_DJ'
  /** Arabic (Algeria) */
  | 'AR_DZ'
  /** Arabic (Egypt) */
  | 'AR_EG'
  /** Arabic (Western Sahara) */
  | 'AR_EH'
  /** Arabic (Eritrea) */
  | 'AR_ER'
  /** Arabic (Israel) */
  | 'AR_IL'
  /** Arabic (Iraq) */
  | 'AR_IQ'
  /** Arabic (Jordan) */
  | 'AR_JO'
  /** Arabic (Comoros) */
  | 'AR_KM'
  /** Arabic (Kuwait) */
  | 'AR_KW'
  /** Arabic (Lebanon) */
  | 'AR_LB'
  /** Arabic (Libya) */
  | 'AR_LY'
  /** Arabic (Morocco) */
  | 'AR_MA'
  /** Arabic (Mauritania) */
  | 'AR_MR'
  /** Arabic (Oman) */
  | 'AR_OM'
  /** Arabic (Palestinian Territories) */
  | 'AR_PS'
  /** Arabic (Qatar) */
  | 'AR_QA'
  /** Arabic (Saudi Arabia) */
  | 'AR_SA'
  /** Arabic (Sudan) */
  | 'AR_SD'
  /** Arabic (Somalia) */
  | 'AR_SO'
  /** Arabic (South Sudan) */
  | 'AR_SS'
  /** Arabic (Syria) */
  | 'AR_SY'
  /** Arabic (Chad) */
  | 'AR_TD'
  /** Arabic (Tunisia) */
  | 'AR_TN'
  /** Arabic (Yemen) */
  | 'AR_YE'
  /** Assamese */
  | 'AS'
  /** Asu */
  | 'ASA'
  /** Asu (Tanzania) */
  | 'ASA_TZ'
  /** Asturian */
  | 'AST'
  /** Asturian (Spain) */
  | 'AST_ES'
  /** Assamese (India) */
  | 'AS_IN'
  /** Azerbaijani */
  | 'AZ'
  /** Azerbaijani (Cyrillic) */
  | 'AZ_CYRL'
  /** Azerbaijani (Cyrillic, Azerbaijan) */
  | 'AZ_CYRL_AZ'
  /** Azerbaijani (Latin) */
  | 'AZ_LATN'
  /** Azerbaijani (Latin, Azerbaijan) */
  | 'AZ_LATN_AZ'
  /** Basaa */
  | 'BAS'
  /** Basaa (Cameroon) */
  | 'BAS_CM'
  /** Belarusian */
  | 'BE'
  /** Bemba */
  | 'BEM'
  /** Bemba (Zambia) */
  | 'BEM_ZM'
  /** Bena */
  | 'BEZ'
  /** Bena (Tanzania) */
  | 'BEZ_TZ'
  /** Belarusian (Belarus) */
  | 'BE_BY'
  /** Bulgarian */
  | 'BG'
  /** Bulgarian (Bulgaria) */
  | 'BG_BG'
  /** Bambara */
  | 'BM'
  /** Bambara (Mali) */
  | 'BM_ML'
  /** Bangla */
  | 'BN'
  /** Bangla (Bangladesh) */
  | 'BN_BD'
  /** Bangla (India) */
  | 'BN_IN'
  /** Tibetan */
  | 'BO'
  /** Tibetan (China) */
  | 'BO_CN'
  /** Tibetan (India) */
  | 'BO_IN'
  /** Breton */
  | 'BR'
  /** Bodo */
  | 'BRX'
  /** Bodo (India) */
  | 'BRX_IN'
  /** Breton (France) */
  | 'BR_FR'
  /** Bosnian */
  | 'BS'
  /** Bosnian (Cyrillic) */
  | 'BS_CYRL'
  /** Bosnian (Cyrillic, Bosnia & Herzegovina) */
  | 'BS_CYRL_BA'
  /** Bosnian (Latin) */
  | 'BS_LATN'
  /** Bosnian (Latin, Bosnia & Herzegovina) */
  | 'BS_LATN_BA'
  /** Catalan */
  | 'CA'
  /** Catalan (Andorra) */
  | 'CA_AD'
  /** Catalan (Spain) */
  | 'CA_ES'
  /** Catalan (Spain, Valencian) */
  | 'CA_ES_VALENCIA'
  /** Catalan (France) */
  | 'CA_FR'
  /** Catalan (Italy) */
  | 'CA_IT'
  /** Chakma */
  | 'CCP'
  /** Chakma (Bangladesh) */
  | 'CCP_BD'
  /** Chakma (India) */
  | 'CCP_IN'
  /** Chechen */
  | 'CE'
  /** Cebuano */
  | 'CEB'
  /** Cebuano (Philippines) */
  | 'CEB_PH'
  /** Chechen (Russia) */
  | 'CE_RU'
  /** Chiga */
  | 'CGG'
  /** Chiga (Uganda) */
  | 'CGG_UG'
  /** Cherokee */
  | 'CHR'
  /** Cherokee (United States) */
  | 'CHR_US'
  /** Central Kurdish */
  | 'CKB'
  /** Central Kurdish (Iraq) */
  | 'CKB_IQ'
  /** Central Kurdish (Iran) */
  | 'CKB_IR'
  /** Czech */
  | 'CS'
  /** Czech (Czechia) */
  | 'CS_CZ'
  /** Church Slavic */
  | 'CU'
  /** Church Slavic (Russia) */
  | 'CU_RU'
  /** Welsh */
  | 'CY'
  /** Welsh (United Kingdom) */
  | 'CY_GB'
  /** Danish */
  | 'DA'
  /** Taita */
  | 'DAV'
  /** Taita (Kenya) */
  | 'DAV_KE'
  /** Danish (Denmark) */
  | 'DA_DK'
  /** Danish (Greenland) */
  | 'DA_GL'
  /** German */
  | 'DE'
  /** German (Austria) */
  | 'DE_AT'
  /** German (Belgium) */
  | 'DE_BE'
  /** German (Switzerland) */
  | 'DE_CH'
  /** German (Germany) */
  | 'DE_DE'
  /** German (Italy) */
  | 'DE_IT'
  /** German (Liechtenstein) */
  | 'DE_LI'
  /** German (Luxembourg) */
  | 'DE_LU'
  /** Zarma */
  | 'DJE'
  /** Zarma (Niger) */
  | 'DJE_NE'
  /** Lower Sorbian */
  | 'DSB'
  /** Lower Sorbian (Germany) */
  | 'DSB_DE'
  /** Duala */
  | 'DUA'
  /** Duala (Cameroon) */
  | 'DUA_CM'
  /** Jola-Fonyi */
  | 'DYO'
  /** Jola-Fonyi (Senegal) */
  | 'DYO_SN'
  /** Dzongkha */
  | 'DZ'
  /** Dzongkha (Bhutan) */
  | 'DZ_BT'
  /** Embu */
  | 'EBU'
  /** Embu (Kenya) */
  | 'EBU_KE'
  /** Ewe */
  | 'EE'
  /** Ewe (Ghana) */
  | 'EE_GH'
  /** Ewe (Togo) */
  | 'EE_TG'
  /** Greek */
  | 'EL'
  /** Greek (Cyprus) */
  | 'EL_CY'
  /** Greek (Greece) */
  | 'EL_GR'
  /** English */
  | 'EN'
  /** English (United Arab Emirates) */
  | 'EN_AE'
  /** English (Antigua & Barbuda) */
  | 'EN_AG'
  /** English (Anguilla) */
  | 'EN_AI'
  /** English (American Samoa) */
  | 'EN_AS'
  /** English (Austria) */
  | 'EN_AT'
  /** English (Australia) */
  | 'EN_AU'
  /** English (Barbados) */
  | 'EN_BB'
  /** English (Belgium) */
  | 'EN_BE'
  /** English (Burundi) */
  | 'EN_BI'
  /** English (Bermuda) */
  | 'EN_BM'
  /** English (Bahamas) */
  | 'EN_BS'
  /** English (Botswana) */
  | 'EN_BW'
  /** English (Belize) */
  | 'EN_BZ'
  /** English (Canada) */
  | 'EN_CA'
  /** English (Cocos (Keeling) Islands) */
  | 'EN_CC'
  /** English (Switzerland) */
  | 'EN_CH'
  /** English (Cook Islands) */
  | 'EN_CK'
  /** English (Cameroon) */
  | 'EN_CM'
  /** English (Christmas Island) */
  | 'EN_CX'
  /** English (Cyprus) */
  | 'EN_CY'
  /** English (Germany) */
  | 'EN_DE'
  /** English (Diego Garcia) */
  | 'EN_DG'
  /** English (Denmark) */
  | 'EN_DK'
  /** English (Dominica) */
  | 'EN_DM'
  /** English (Eritrea) */
  | 'EN_ER'
  /** English (Finland) */
  | 'EN_FI'
  /** English (Fiji) */
  | 'EN_FJ'
  /** English (Falkland Islands) */
  | 'EN_FK'
  /** English (Micronesia) */
  | 'EN_FM'
  /** English (United Kingdom) */
  | 'EN_GB'
  /** English (Grenada) */
  | 'EN_GD'
  /** English (Guernsey) */
  | 'EN_GG'
  /** English (Ghana) */
  | 'EN_GH'
  /** English (Gibraltar) */
  | 'EN_GI'
  /** English (Gambia) */
  | 'EN_GM'
  /** English (Guam) */
  | 'EN_GU'
  /** English (Guyana) */
  | 'EN_GY'
  /** English (Hong Kong SAR China) */
  | 'EN_HK'
  /** English (Ireland) */
  | 'EN_IE'
  /** English (Israel) */
  | 'EN_IL'
  /** English (Isle of Man) */
  | 'EN_IM'
  /** English (India) */
  | 'EN_IN'
  /** English (British Indian Ocean Territory) */
  | 'EN_IO'
  /** English (Jersey) */
  | 'EN_JE'
  /** English (Jamaica) */
  | 'EN_JM'
  /** English (Kenya) */
  | 'EN_KE'
  /** English (Kiribati) */
  | 'EN_KI'
  /** English (St. Kitts & Nevis) */
  | 'EN_KN'
  /** English (Cayman Islands) */
  | 'EN_KY'
  /** English (St. Lucia) */
  | 'EN_LC'
  /** English (Liberia) */
  | 'EN_LR'
  /** English (Lesotho) */
  | 'EN_LS'
  /** English (Madagascar) */
  | 'EN_MG'
  /** English (Marshall Islands) */
  | 'EN_MH'
  /** English (Macao SAR China) */
  | 'EN_MO'
  /** English (Northern Mariana Islands) */
  | 'EN_MP'
  /** English (Montserrat) */
  | 'EN_MS'
  /** English (Malta) */
  | 'EN_MT'
  /** English (Mauritius) */
  | 'EN_MU'
  /** English (Malawi) */
  | 'EN_MW'
  /** English (Malaysia) */
  | 'EN_MY'
  /** English (Namibia) */
  | 'EN_NA'
  /** English (Norfolk Island) */
  | 'EN_NF'
  /** English (Nigeria) */
  | 'EN_NG'
  /** English (Netherlands) */
  | 'EN_NL'
  /** English (Nauru) */
  | 'EN_NR'
  /** English (Niue) */
  | 'EN_NU'
  /** English (New Zealand) */
  | 'EN_NZ'
  /** English (Papua New Guinea) */
  | 'EN_PG'
  /** English (Philippines) */
  | 'EN_PH'
  /** English (Pakistan) */
  | 'EN_PK'
  /** English (Pitcairn Islands) */
  | 'EN_PN'
  /** English (Puerto Rico) */
  | 'EN_PR'
  /** English (Palau) */
  | 'EN_PW'
  /** English (Rwanda) */
  | 'EN_RW'
  /** English (Solomon Islands) */
  | 'EN_SB'
  /** English (Seychelles) */
  | 'EN_SC'
  /** English (Sudan) */
  | 'EN_SD'
  /** English (Sweden) */
  | 'EN_SE'
  /** English (Singapore) */
  | 'EN_SG'
  /** English (St. Helena) */
  | 'EN_SH'
  /** English (Slovenia) */
  | 'EN_SI'
  /** English (Sierra Leone) */
  | 'EN_SL'
  /** English (South Sudan) */
  | 'EN_SS'
  /** English (Sint Maarten) */
  | 'EN_SX'
  /** English (Eswatini) */
  | 'EN_SZ'
  /** English (Turks & Caicos Islands) */
  | 'EN_TC'
  /** English (Tokelau) */
  | 'EN_TK'
  /** English (Tonga) */
  | 'EN_TO'
  /** English (Trinidad & Tobago) */
  | 'EN_TT'
  /** English (Tuvalu) */
  | 'EN_TV'
  /** English (Tanzania) */
  | 'EN_TZ'
  /** English (Uganda) */
  | 'EN_UG'
  /** English (U.S. Outlying Islands) */
  | 'EN_UM'
  /** English (United States) */
  | 'EN_US'
  /** English (St. Vincent & Grenadines) */
  | 'EN_VC'
  /** English (British Virgin Islands) */
  | 'EN_VG'
  /** English (U.S. Virgin Islands) */
  | 'EN_VI'
  /** English (Vanuatu) */
  | 'EN_VU'
  /** English (Samoa) */
  | 'EN_WS'
  /** English (South Africa) */
  | 'EN_ZA'
  /** English (Zambia) */
  | 'EN_ZM'
  /** English (Zimbabwe) */
  | 'EN_ZW'
  /** Esperanto */
  | 'EO'
  /** Spanish */
  | 'ES'
  /** Spanish (Argentina) */
  | 'ES_AR'
  /** Spanish (Bolivia) */
  | 'ES_BO'
  /** Spanish (Brazil) */
  | 'ES_BR'
  /** Spanish (Belize) */
  | 'ES_BZ'
  /** Spanish (Chile) */
  | 'ES_CL'
  /** Spanish (Colombia) */
  | 'ES_CO'
  /** Spanish (Costa Rica) */
  | 'ES_CR'
  /** Spanish (Cuba) */
  | 'ES_CU'
  /** Spanish (Dominican Republic) */
  | 'ES_DO'
  /** Spanish (Ceuta & Melilla) */
  | 'ES_EA'
  /** Spanish (Ecuador) */
  | 'ES_EC'
  /** Spanish (Spain) */
  | 'ES_ES'
  /** Spanish (Equatorial Guinea) */
  | 'ES_GQ'
  /** Spanish (Guatemala) */
  | 'ES_GT'
  /** Spanish (Honduras) */
  | 'ES_HN'
  /** Spanish (Canary Islands) */
  | 'ES_IC'
  /** Spanish (Mexico) */
  | 'ES_MX'
  /** Spanish (Nicaragua) */
  | 'ES_NI'
  /** Spanish (Panama) */
  | 'ES_PA'
  /** Spanish (Peru) */
  | 'ES_PE'
  /** Spanish (Philippines) */
  | 'ES_PH'
  /** Spanish (Puerto Rico) */
  | 'ES_PR'
  /** Spanish (Paraguay) */
  | 'ES_PY'
  /** Spanish (El Salvador) */
  | 'ES_SV'
  /** Spanish (United States) */
  | 'ES_US'
  /** Spanish (Uruguay) */
  | 'ES_UY'
  /** Spanish (Venezuela) */
  | 'ES_VE'
  /** Estonian */
  | 'ET'
  /** Estonian (Estonia) */
  | 'ET_EE'
  /** Basque */
  | 'EU'
  /** Basque (Spain) */
  | 'EU_ES'
  /** Ewondo */
  | 'EWO'
  /** Ewondo (Cameroon) */
  | 'EWO_CM'
  /** Persian */
  | 'FA'
  /** Persian (Afghanistan) */
  | 'FA_AF'
  /** Persian (Iran) */
  | 'FA_IR'
  /** Fulah */
  | 'FF'
  /** Fulah (Adlam) */
  | 'FF_ADLM'
  /** Fulah (Adlam, Burkina Faso) */
  | 'FF_ADLM_BF'
  /** Fulah (Adlam, Cameroon) */
  | 'FF_ADLM_CM'
  /** Fulah (Adlam, Ghana) */
  | 'FF_ADLM_GH'
  /** Fulah (Adlam, Gambia) */
  | 'FF_ADLM_GM'
  /** Fulah (Adlam, Guinea) */
  | 'FF_ADLM_GN'
  /** Fulah (Adlam, Guinea-Bissau) */
  | 'FF_ADLM_GW'
  /** Fulah (Adlam, Liberia) */
  | 'FF_ADLM_LR'
  /** Fulah (Adlam, Mauritania) */
  | 'FF_ADLM_MR'
  /** Fulah (Adlam, Niger) */
  | 'FF_ADLM_NE'
  /** Fulah (Adlam, Nigeria) */
  | 'FF_ADLM_NG'
  /** Fulah (Adlam, Sierra Leone) */
  | 'FF_ADLM_SL'
  /** Fulah (Adlam, Senegal) */
  | 'FF_ADLM_SN'
  /** Fulah (Latin) */
  | 'FF_LATN'
  /** Fulah (Latin, Burkina Faso) */
  | 'FF_LATN_BF'
  /** Fulah (Latin, Cameroon) */
  | 'FF_LATN_CM'
  /** Fulah (Latin, Ghana) */
  | 'FF_LATN_GH'
  /** Fulah (Latin, Gambia) */
  | 'FF_LATN_GM'
  /** Fulah (Latin, Guinea) */
  | 'FF_LATN_GN'
  /** Fulah (Latin, Guinea-Bissau) */
  | 'FF_LATN_GW'
  /** Fulah (Latin, Liberia) */
  | 'FF_LATN_LR'
  /** Fulah (Latin, Mauritania) */
  | 'FF_LATN_MR'
  /** Fulah (Latin, Niger) */
  | 'FF_LATN_NE'
  /** Fulah (Latin, Nigeria) */
  | 'FF_LATN_NG'
  /** Fulah (Latin, Sierra Leone) */
  | 'FF_LATN_SL'
  /** Fulah (Latin, Senegal) */
  | 'FF_LATN_SN'
  /** Finnish */
  | 'FI'
  /** Filipino */
  | 'FIL'
  /** Filipino (Philippines) */
  | 'FIL_PH'
  /** Finnish (Finland) */
  | 'FI_FI'
  /** Faroese */
  | 'FO'
  /** Faroese (Denmark) */
  | 'FO_DK'
  /** Faroese (Faroe Islands) */
  | 'FO_FO'
  /** French */
  | 'FR'
  /** French (Belgium) */
  | 'FR_BE'
  /** French (Burkina Faso) */
  | 'FR_BF'
  /** French (Burundi) */
  | 'FR_BI'
  /** French (Benin) */
  | 'FR_BJ'
  /** French (St. Barthlemy) */
  | 'FR_BL'
  /** French (Canada) */
  | 'FR_CA'
  /** French (Congo - Kinshasa) */
  | 'FR_CD'
  /** French (Central African Republic) */
  | 'FR_CF'
  /** French (Congo - Brazzaville) */
  | 'FR_CG'
  /** French (Switzerland) */
  | 'FR_CH'
  /** French (Cte dIvoire) */
  | 'FR_CI'
  /** French (Cameroon) */
  | 'FR_CM'
  /** French (Djibouti) */
  | 'FR_DJ'
  /** French (Algeria) */
  | 'FR_DZ'
  /** French (France) */
  | 'FR_FR'
  /** French (Gabon) */
  | 'FR_GA'
  /** French (French Guiana) */
  | 'FR_GF'
  /** French (Guinea) */
  | 'FR_GN'
  /** French (Guadeloupe) */
  | 'FR_GP'
  /** French (Equatorial Guinea) */
  | 'FR_GQ'
  /** French (Haiti) */
  | 'FR_HT'
  /** French (Comoros) */
  | 'FR_KM'
  /** French (Luxembourg) */
  | 'FR_LU'
  /** French (Morocco) */
  | 'FR_MA'
  /** French (Monaco) */
  | 'FR_MC'
  /** French (St. Martin) */
  | 'FR_MF'
  /** French (Madagascar) */
  | 'FR_MG'
  /** French (Mali) */
  | 'FR_ML'
  /** French (Martinique) */
  | 'FR_MQ'
  /** French (Mauritania) */
  | 'FR_MR'
  /** French (Mauritius) */
  | 'FR_MU'
  /** French (New Caledonia) */
  | 'FR_NC'
  /** French (Niger) */
  | 'FR_NE'
  /** French (French Polynesia) */
  | 'FR_PF'
  /** French (St. Pierre & Miquelon) */
  | 'FR_PM'
  /** French (Runion) */
  | 'FR_RE'
  /** French (Rwanda) */
  | 'FR_RW'
  /** French (Seychelles) */
  | 'FR_SC'
  /** French (Senegal) */
  | 'FR_SN'
  /** French (Syria) */
  | 'FR_SY'
  /** French (Chad) */
  | 'FR_TD'
  /** French (Togo) */
  | 'FR_TG'
  /** French (Tunisia) */
  | 'FR_TN'
  /** French (Vanuatu) */
  | 'FR_VU'
  /** French (Wallis & Futuna) */
  | 'FR_WF'
  /** French (Mayotte) */
  | 'FR_YT'
  /** Friulian */
  | 'FUR'
  /** Friulian (Italy) */
  | 'FUR_IT'
  /** Western Frisian */
  | 'FY'
  /** Western Frisian (Netherlands) */
  | 'FY_NL'
  /** Irish */
  | 'GA'
  /** Irish (United Kingdom) */
  | 'GA_GB'
  /** Irish (Ireland) */
  | 'GA_IE'
  /** Scottish Gaelic */
  | 'GD'
  /** Scottish Gaelic (United Kingdom) */
  | 'GD_GB'
  /** Galician */
  | 'GL'
  /** Galician (Spain) */
  | 'GL_ES'
  /** Swiss German */
  | 'GSW'
  /** Swiss German (Switzerland) */
  | 'GSW_CH'
  /** Swiss German (France) */
  | 'GSW_FR'
  /** Swiss German (Liechtenstein) */
  | 'GSW_LI'
  /** Gujarati */
  | 'GU'
  /** Gusii */
  | 'GUZ'
  /** Gusii (Kenya) */
  | 'GUZ_KE'
  /** Gujarati (India) */
  | 'GU_IN'
  /** Manx */
  | 'GV'
  /** Manx (Isle of Man) */
  | 'GV_IM'
  /** Hausa */
  | 'HA'
  /** Hawaiian */
  | 'HAW'
  /** Hawaiian (United States) */
  | 'HAW_US'
  /** Hausa (Ghana) */
  | 'HA_GH'
  /** Hausa (Niger) */
  | 'HA_NE'
  /** Hausa (Nigeria) */
  | 'HA_NG'
  /** Hebrew */
  | 'HE'
  /** Hebrew (Israel) */
  | 'HE_IL'
  /** Hindi */
  | 'HI'
  /** Hindi (India) */
  | 'HI_IN'
  /** Croatian */
  | 'HR'
  /** Croatian (Bosnia & Herzegovina) */
  | 'HR_BA'
  /** Croatian (Croatia) */
  | 'HR_HR'
  /** Upper Sorbian */
  | 'HSB'
  /** Upper Sorbian (Germany) */
  | 'HSB_DE'
  /** Hungarian */
  | 'HU'
  /** Hungarian (Hungary) */
  | 'HU_HU'
  /** Armenian */
  | 'HY'
  /** Armenian (Armenia) */
  | 'HY_AM'
  /** Interlingua */
  | 'IA'
  /** Indonesian */
  | 'ID'
  /** Indonesian (Indonesia) */
  | 'ID_ID'
  /** Igbo */
  | 'IG'
  /** Igbo (Nigeria) */
  | 'IG_NG'
  /** Sichuan Yi */
  | 'II'
  /** Sichuan Yi (China) */
  | 'II_CN'
  /** Icelandic */
  | 'IS'
  /** Icelandic (Iceland) */
  | 'IS_IS'
  /** Italian */
  | 'IT'
  /** Italian (Switzerland) */
  | 'IT_CH'
  /** Italian (Italy) */
  | 'IT_IT'
  /** Italian (San Marino) */
  | 'IT_SM'
  /** Italian (Vatican City) */
  | 'IT_VA'
  /** Japanese */
  | 'JA'
  /** Japanese (Japan) */
  | 'JA_JP'
  /** Ngomba */
  | 'JGO'
  /** Ngomba (Cameroon) */
  | 'JGO_CM'
  /** Machame */
  | 'JMC'
  /** Machame (Tanzania) */
  | 'JMC_TZ'
  /** Javanese */
  | 'JV'
  /** Javanese (Indonesia) */
  | 'JV_ID'
  /** Georgian */
  | 'KA'
  /** Kabyle */
  | 'KAB'
  /** Kabyle (Algeria) */
  | 'KAB_DZ'
  /** Kamba */
  | 'KAM'
  /** Kamba (Kenya) */
  | 'KAM_KE'
  /** Georgian (Georgia) */
  | 'KA_GE'
  /** Makonde */
  | 'KDE'
  /** Makonde (Tanzania) */
  | 'KDE_TZ'
  /** Kabuverdianu */
  | 'KEA'
  /** Kabuverdianu (Cape Verde) */
  | 'KEA_CV'
  /** Koyra Chiini */
  | 'KHQ'
  /** Koyra Chiini (Mali) */
  | 'KHQ_ML'
  /** Kikuyu */
  | 'KI'
  /** Kikuyu (Kenya) */
  | 'KI_KE'
  /** Kazakh */
  | 'KK'
  /** Kako */
  | 'KKJ'
  /** Kako (Cameroon) */
  | 'KKJ_CM'
  /** Kazakh (Kazakhstan) */
  | 'KK_KZ'
  /** Kalaallisut */
  | 'KL'
  /** Kalenjin */
  | 'KLN'
  /** Kalenjin (Kenya) */
  | 'KLN_KE'
  /** Kalaallisut (Greenland) */
  | 'KL_GL'
  /** Khmer */
  | 'KM'
  /** Khmer (Cambodia) */
  | 'KM_KH'
  /** Kannada */
  | 'KN'
  /** Kannada (India) */
  | 'KN_IN'
  /** Korean */
  | 'KO'
  /** Konkani */
  | 'KOK'
  /** Konkani (India) */
  | 'KOK_IN'
  /** Korean (North Korea) */
  | 'KO_KP'
  /** Korean (South Korea) */
  | 'KO_KR'
  /** Kashmiri */
  | 'KS'
  /** Shambala */
  | 'KSB'
  /** Shambala (Tanzania) */
  | 'KSB_TZ'
  /** Bafia */
  | 'KSF'
  /** Bafia (Cameroon) */
  | 'KSF_CM'
  /** Colognian */
  | 'KSH'
  /** Colognian (Germany) */
  | 'KSH_DE'
  /** Kashmiri (Arabic) */
  | 'KS_ARAB'
  /** Kashmiri (Arabic, India) */
  | 'KS_ARAB_IN'
  /** Kurdish */
  | 'KU'
  /** Kurdish (Turkey) */
  | 'KU_TR'
  /** Cornish */
  | 'KW'
  /** Cornish (United Kingdom) */
  | 'KW_GB'
  /** Kyrgyz */
  | 'KY'
  /** Kyrgyz (Kyrgyzstan) */
  | 'KY_KG'
  /** Langi */
  | 'LAG'
  /** Langi (Tanzania) */
  | 'LAG_TZ'
  /** Luxembourgish */
  | 'LB'
  /** Luxembourgish (Luxembourg) */
  | 'LB_LU'
  /** Ganda */
  | 'LG'
  /** Ganda (Uganda) */
  | 'LG_UG'
  /** Lakota */
  | 'LKT'
  /** Lakota (United States) */
  | 'LKT_US'
  /** Lingala */
  | 'LN'
  /** Lingala (Angola) */
  | 'LN_AO'
  /** Lingala (Congo - Kinshasa) */
  | 'LN_CD'
  /** Lingala (Central African Republic) */
  | 'LN_CF'
  /** Lingala (Congo - Brazzaville) */
  | 'LN_CG'
  /** Lao */
  | 'LO'
  /** Lao (Laos) */
  | 'LO_LA'
  /** Northern Luri */
  | 'LRC'
  /** Northern Luri (Iraq) */
  | 'LRC_IQ'
  /** Northern Luri (Iran) */
  | 'LRC_IR'
  /** Lithuanian */
  | 'LT'
  /** Lithuanian (Lithuania) */
  | 'LT_LT'
  /** Luba-Katanga */
  | 'LU'
  /** Luo */
  | 'LUO'
  /** Luo (Kenya) */
  | 'LUO_KE'
  /** Luyia */
  | 'LUY'
  /** Luyia (Kenya) */
  | 'LUY_KE'
  /** Luba-Katanga (Congo - Kinshasa) */
  | 'LU_CD'
  /** Latvian */
  | 'LV'
  /** Latvian (Latvia) */
  | 'LV_LV'
  /** Maithili */
  | 'MAI'
  /** Maithili (India) */
  | 'MAI_IN'
  /** Masai */
  | 'MAS'
  /** Masai (Kenya) */
  | 'MAS_KE'
  /** Masai (Tanzania) */
  | 'MAS_TZ'
  /** Meru */
  | 'MER'
  /** Meru (Kenya) */
  | 'MER_KE'
  /** Morisyen */
  | 'MFE'
  /** Morisyen (Mauritius) */
  | 'MFE_MU'
  /** Malagasy */
  | 'MG'
  /** Makhuwa-Meetto */
  | 'MGH'
  /** Makhuwa-Meetto (Mozambique) */
  | 'MGH_MZ'
  /** Meta */
  | 'MGO'
  /** Meta (Cameroon) */
  | 'MGO_CM'
  /** Malagasy (Madagascar) */
  | 'MG_MG'
  /** Maori */
  | 'MI'
  /** Maori (New Zealand) */
  | 'MI_NZ'
  /** Macedonian */
  | 'MK'
  /** Macedonian (North Macedonia) */
  | 'MK_MK'
  /** Malayalam */
  | 'ML'
  /** Malayalam (India) */
  | 'ML_IN'
  /** Mongolian */
  | 'MN'
  /** Manipuri */
  | 'MNI'
  /** Manipuri (Bangla) */
  | 'MNI_BENG'
  /** Manipuri (Bangla, India) */
  | 'MNI_BENG_IN'
  /** Mongolian (Mongolia) */
  | 'MN_MN'
  /** Marathi */
  | 'MR'
  /** Marathi (India) */
  | 'MR_IN'
  /** Malay */
  | 'MS'
  /** Malay (Brunei) */
  | 'MS_BN'
  /** Malay (Indonesia) */
  | 'MS_ID'
  /** Malay (Malaysia) */
  | 'MS_MY'
  /** Malay (Singapore) */
  | 'MS_SG'
  /** Maltese */
  | 'MT'
  /** Maltese (Malta) */
  | 'MT_MT'
  /** Mundang */
  | 'MUA'
  /** Mundang (Cameroon) */
  | 'MUA_CM'
  /** Burmese */
  | 'MY'
  /** Burmese (Myanmar (Burma)) */
  | 'MY_MM'
  /** Mazanderani */
  | 'MZN'
  /** Mazanderani (Iran) */
  | 'MZN_IR'
  /** Nama */
  | 'NAQ'
  /** Nama (Namibia) */
  | 'NAQ_NA'
  /** Norwegian Bokml */
  | 'NB'
  /** Norwegian Bokml (Norway) */
  | 'NB_NO'
  /** Norwegian Bokml (Svalbard & Jan Mayen) */
  | 'NB_SJ'
  /** North Ndebele */
  | 'ND'
  /** Low German */
  | 'NDS'
  /** Low German (Germany) */
  | 'NDS_DE'
  /** Low German (Netherlands) */
  | 'NDS_NL'
  /** North Ndebele (Zimbabwe) */
  | 'ND_ZW'
  /** Nepali */
  | 'NE'
  /** Nepali (India) */
  | 'NE_IN'
  /** Nepali (Nepal) */
  | 'NE_NP'
  /** Dutch */
  | 'NL'
  /** Dutch (Aruba) */
  | 'NL_AW'
  /** Dutch (Belgium) */
  | 'NL_BE'
  /** Dutch (Caribbean Netherlands) */
  | 'NL_BQ'
  /** Dutch (Curaao) */
  | 'NL_CW'
  /** Dutch (Netherlands) */
  | 'NL_NL'
  /** Dutch (Suriname) */
  | 'NL_SR'
  /** Dutch (Sint Maarten) */
  | 'NL_SX'
  /** Kwasio */
  | 'NMG'
  /** Kwasio (Cameroon) */
  | 'NMG_CM'
  /** Norwegian Nynorsk */
  | 'NN'
  /** Ngiemboon */
  | 'NNH'
  /** Ngiemboon (Cameroon) */
  | 'NNH_CM'
  /** Norwegian Nynorsk (Norway) */
  | 'NN_NO'
  /** Nuer */
  | 'NUS'
  /** Nuer (South Sudan) */
  | 'NUS_SS'
  /** Nyankole */
  | 'NYN'
  /** Nyankole (Uganda) */
  | 'NYN_UG'
  /** Oromo */
  | 'OM'
  /** Oromo (Ethiopia) */
  | 'OM_ET'
  /** Oromo (Kenya) */
  | 'OM_KE'
  /** Odia */
  | 'OR'
  /** Odia (India) */
  | 'OR_IN'
  /** Ossetic */
  | 'OS'
  /** Ossetic (Georgia) */
  | 'OS_GE'
  /** Ossetic (Russia) */
  | 'OS_RU'
  /** Punjabi */
  | 'PA'
  /** Punjabi (Arabic) */
  | 'PA_ARAB'
  /** Punjabi (Arabic, Pakistan) */
  | 'PA_ARAB_PK'
  /** Punjabi (Gurmukhi) */
  | 'PA_GURU'
  /** Punjabi (Gurmukhi, India) */
  | 'PA_GURU_IN'
  /** Nigerian Pidgin */
  | 'PCM'
  /** Nigerian Pidgin (Nigeria) */
  | 'PCM_NG'
  /** Polish */
  | 'PL'
  /** Polish (Poland) */
  | 'PL_PL'
  /** Prussian */
  | 'PRG'
  /** Pashto */
  | 'PS'
  /** Pashto (Afghanistan) */
  | 'PS_AF'
  /** Pashto (Pakistan) */
  | 'PS_PK'
  /** Portuguese */
  | 'PT'
  /** Portuguese (Angola) */
  | 'PT_AO'
  /** Portuguese (Brazil) */
  | 'PT_BR'
  /** Portuguese (Switzerland) */
  | 'PT_CH'
  /** Portuguese (Cape Verde) */
  | 'PT_CV'
  /** Portuguese (Equatorial Guinea) */
  | 'PT_GQ'
  /** Portuguese (Guinea-Bissau) */
  | 'PT_GW'
  /** Portuguese (Luxembourg) */
  | 'PT_LU'
  /** Portuguese (Macao SAR China) */
  | 'PT_MO'
  /** Portuguese (Mozambique) */
  | 'PT_MZ'
  /** Portuguese (Portugal) */
  | 'PT_PT'
  /** Portuguese (So Tom & Prncipe) */
  | 'PT_ST'
  /** Portuguese (Timor-Leste) */
  | 'PT_TL'
  /** Quechua */
  | 'QU'
  /** Quechua (Bolivia) */
  | 'QU_BO'
  /** Quechua (Ecuador) */
  | 'QU_EC'
  /** Quechua (Peru) */
  | 'QU_PE'
  /** Romansh */
  | 'RM'
  /** Romansh (Switzerland) */
  | 'RM_CH'
  /** Rundi */
  | 'RN'
  /** Rundi (Burundi) */
  | 'RN_BI'
  /** Romanian */
  | 'RO'
  /** Rombo */
  | 'ROF'
  /** Rombo (Tanzania) */
  | 'ROF_TZ'
  /** Romanian (Moldova) */
  | 'RO_MD'
  /** Romanian (Romania) */
  | 'RO_RO'
  /** Russian */
  | 'RU'
  /** Russian (Belarus) */
  | 'RU_BY'
  /** Russian (Kyrgyzstan) */
  | 'RU_KG'
  /** Russian (Kazakhstan) */
  | 'RU_KZ'
  /** Russian (Moldova) */
  | 'RU_MD'
  /** Russian (Russia) */
  | 'RU_RU'
  /** Russian (Ukraine) */
  | 'RU_UA'
  /** Kinyarwanda */
  | 'RW'
  /** Rwa */
  | 'RWK'
  /** Rwa (Tanzania) */
  | 'RWK_TZ'
  /** Kinyarwanda (Rwanda) */
  | 'RW_RW'
  /** Sakha */
  | 'SAH'
  /** Sakha (Russia) */
  | 'SAH_RU'
  /** Samburu */
  | 'SAQ'
  /** Samburu (Kenya) */
  | 'SAQ_KE'
  /** Santali */
  | 'SAT'
  /** Santali (Ol Chiki) */
  | 'SAT_OLCK'
  /** Santali (Ol Chiki, India) */
  | 'SAT_OLCK_IN'
  /** Sangu */
  | 'SBP'
  /** Sangu (Tanzania) */
  | 'SBP_TZ'
  /** Sindhi */
  | 'SD'
  /** Sindhi (Arabic) */
  | 'SD_ARAB'
  /** Sindhi (Arabic, Pakistan) */
  | 'SD_ARAB_PK'
  /** Sindhi (Devanagari) */
  | 'SD_DEVA'
  /** Sindhi (Devanagari, India) */
  | 'SD_DEVA_IN'
  /** Northern Sami */
  | 'SE'
  /** Sena */
  | 'SEH'
  /** Sena (Mozambique) */
  | 'SEH_MZ'
  /** Koyraboro Senni */
  | 'SES'
  /** Koyraboro Senni (Mali) */
  | 'SES_ML'
  /** Northern Sami (Finland) */
  | 'SE_FI'
  /** Northern Sami (Norway) */
  | 'SE_NO'
  /** Northern Sami (Sweden) */
  | 'SE_SE'
  /** Sango */
  | 'SG'
  /** Sango (Central African Republic) */
  | 'SG_CF'
  /** Tachelhit */
  | 'SHI'
  /** Tachelhit (Latin) */
  | 'SHI_LATN'
  /** Tachelhit (Latin, Morocco) */
  | 'SHI_LATN_MA'
  /** Tachelhit (Tifinagh) */
  | 'SHI_TFNG'
  /** Tachelhit (Tifinagh, Morocco) */
  | 'SHI_TFNG_MA'
  /** Sinhala */
  | 'SI'
  /** Sinhala (Sri Lanka) */
  | 'SI_LK'
  /** Slovak */
  | 'SK'
  /** Slovak (Slovakia) */
  | 'SK_SK'
  /** Slovenian */
  | 'SL'
  /** Slovenian (Slovenia) */
  | 'SL_SI'
  /** Inari Sami */
  | 'SMN'
  /** Inari Sami (Finland) */
  | 'SMN_FI'
  /** Shona */
  | 'SN'
  /** Shona (Zimbabwe) */
  | 'SN_ZW'
  /** Somali */
  | 'SO'
  /** Somali (Djibouti) */
  | 'SO_DJ'
  /** Somali (Ethiopia) */
  | 'SO_ET'
  /** Somali (Kenya) */
  | 'SO_KE'
  /** Somali (Somalia) */
  | 'SO_SO'
  /** Albanian */
  | 'SQ'
  /** Albanian (Albania) */
  | 'SQ_AL'
  /** Albanian (North Macedonia) */
  | 'SQ_MK'
  /** Albanian (Kosovo) */
  | 'SQ_XK'
  /** Serbian */
  | 'SR'
  /** Serbian (Cyrillic) */
  | 'SR_CYRL'
  /** Serbian (Cyrillic, Bosnia & Herzegovina) */
  | 'SR_CYRL_BA'
  /** Serbian (Cyrillic, Montenegro) */
  | 'SR_CYRL_ME'
  /** Serbian (Cyrillic, Serbia) */
  | 'SR_CYRL_RS'
  /** Serbian (Cyrillic, Kosovo) */
  | 'SR_CYRL_XK'
  /** Serbian (Latin) */
  | 'SR_LATN'
  /** Serbian (Latin, Bosnia & Herzegovina) */
  | 'SR_LATN_BA'
  /** Serbian (Latin, Montenegro) */
  | 'SR_LATN_ME'
  /** Serbian (Latin, Serbia) */
  | 'SR_LATN_RS'
  /** Serbian (Latin, Kosovo) */
  | 'SR_LATN_XK'
  /** Sundanese */
  | 'SU'
  /** Sundanese (Latin) */
  | 'SU_LATN'
  /** Sundanese (Latin, Indonesia) */
  | 'SU_LATN_ID'
  /** Swedish */
  | 'SV'
  /** Swedish (land Islands) */
  | 'SV_AX'
  /** Swedish (Finland) */
  | 'SV_FI'
  /** Swedish (Sweden) */
  | 'SV_SE'
  /** Swahili */
  | 'SW'
  /** Swahili (Congo - Kinshasa) */
  | 'SW_CD'
  /** Swahili (Kenya) */
  | 'SW_KE'
  /** Swahili (Tanzania) */
  | 'SW_TZ'
  /** Swahili (Uganda) */
  | 'SW_UG'
  /** Tamil */
  | 'TA'
  /** Tamil (India) */
  | 'TA_IN'
  /** Tamil (Sri Lanka) */
  | 'TA_LK'
  /** Tamil (Malaysia) */
  | 'TA_MY'
  /** Tamil (Singapore) */
  | 'TA_SG'
  /** Telugu */
  | 'TE'
  /** Teso */
  | 'TEO'
  /** Teso (Kenya) */
  | 'TEO_KE'
  /** Teso (Uganda) */
  | 'TEO_UG'
  /** Telugu (India) */
  | 'TE_IN'
  /** Tajik */
  | 'TG'
  /** Tajik (Tajikistan) */
  | 'TG_TJ'
  /** Thai */
  | 'TH'
  /** Thai (Thailand) */
  | 'TH_TH'
  /** Tigrinya */
  | 'TI'
  /** Tigrinya (Eritrea) */
  | 'TI_ER'
  /** Tigrinya (Ethiopia) */
  | 'TI_ET'
  /** Turkmen */
  | 'TK'
  /** Turkmen (Turkmenistan) */
  | 'TK_TM'
  /** Tongan */
  | 'TO'
  /** Tongan (Tonga) */
  | 'TO_TO'
  /** Turkish */
  | 'TR'
  /** Turkish (Cyprus) */
  | 'TR_CY'
  /** Turkish (Turkey) */
  | 'TR_TR'
  /** Tatar */
  | 'TT'
  /** Tatar (Russia) */
  | 'TT_RU'
  /** Tasawaq */
  | 'TWQ'
  /** Tasawaq (Niger) */
  | 'TWQ_NE'
  /** Central Atlas Tamazight */
  | 'TZM'
  /** Central Atlas Tamazight (Morocco) */
  | 'TZM_MA'
  /** Uyghur */
  | 'UG'
  /** Uyghur (China) */
  | 'UG_CN'
  /** Ukrainian */
  | 'UK'
  /** Ukrainian (Ukraine) */
  | 'UK_UA'
  /** Urdu */
  | 'UR'
  /** Urdu (India) */
  | 'UR_IN'
  /** Urdu (Pakistan) */
  | 'UR_PK'
  /** Uzbek */
  | 'UZ'
  /** Uzbek (Arabic) */
  | 'UZ_ARAB'
  /** Uzbek (Arabic, Afghanistan) */
  | 'UZ_ARAB_AF'
  /** Uzbek (Cyrillic) */
  | 'UZ_CYRL'
  /** Uzbek (Cyrillic, Uzbekistan) */
  | 'UZ_CYRL_UZ'
  /** Uzbek (Latin) */
  | 'UZ_LATN'
  /** Uzbek (Latin, Uzbekistan) */
  | 'UZ_LATN_UZ'
  /** Vai */
  | 'VAI'
  /** Vai (Latin) */
  | 'VAI_LATN'
  /** Vai (Latin, Liberia) */
  | 'VAI_LATN_LR'
  /** Vai (Vai) */
  | 'VAI_VAII'
  /** Vai (Vai, Liberia) */
  | 'VAI_VAII_LR'
  /** Vietnamese */
  | 'VI'
  /** Vietnamese (Vietnam) */
  | 'VI_VN'
  /** Volapk */
  | 'VO'
  /** Vunjo */
  | 'VUN'
  /** Vunjo (Tanzania) */
  | 'VUN_TZ'
  /** Walser */
  | 'WAE'
  /** Walser (Switzerland) */
  | 'WAE_CH'
  /** Wolof */
  | 'WO'
  /** Wolof (Senegal) */
  | 'WO_SN'
  /** Xhosa */
  | 'XH'
  /** Xhosa (South Africa) */
  | 'XH_ZA'
  /** Soga */
  | 'XOG'
  /** Soga (Uganda) */
  | 'XOG_UG'
  /** Yangben */
  | 'YAV'
  /** Yangben (Cameroon) */
  | 'YAV_CM'
  /** Yiddish */
  | 'YI'
  /** Yoruba */
  | 'YO'
  /** Yoruba (Benin) */
  | 'YO_BJ'
  /** Yoruba (Nigeria) */
  | 'YO_NG'
  /** Cantonese */
  | 'YUE'
  /** Cantonese (Simplified) */
  | 'YUE_HANS'
  /** Cantonese (Simplified, China) */
  | 'YUE_HANS_CN'
  /** Cantonese (Traditional) */
  | 'YUE_HANT'
  /** Cantonese (Traditional, Hong Kong SAR China) */
  | 'YUE_HANT_HK'
  /** Standard Moroccan Tamazight */
  | 'ZGH'
  /** Standard Moroccan Tamazight (Morocco) */
  | 'ZGH_MA'
  /** Chinese */
  | 'ZH'
  /** Chinese (Simplified) */
  | 'ZH_HANS'
  /** Chinese (Simplified, China) */
  | 'ZH_HANS_CN'
  /** Chinese (Simplified, Hong Kong SAR China) */
  | 'ZH_HANS_HK'
  /** Chinese (Simplified, Macao SAR China) */
  | 'ZH_HANS_MO'
  /** Chinese (Simplified, Singapore) */
  | 'ZH_HANS_SG'
  /** Chinese (Traditional) */
  | 'ZH_HANT'
  /** Chinese (Traditional, Hong Kong SAR China) */
  | 'ZH_HANT_HK'
  /** Chinese (Traditional, Macao SAR China) */
  | 'ZH_HANT_MO'
  /** Chinese (Traditional, Taiwan) */
  | 'ZH_HANT_TW'
  /** Zulu */
  | 'ZU'
  /** Zulu (South Africa) */
  | 'ZU_ZA';

export type LanguageDisplay = {
  __typename: 'LanguageDisplay';
  /** ISO 639 representation of the language name. */
  code: LanguageCodeEnum;
  /** Full name of the language. */
  language: Scalars['String'];
};

/** Store the current and allowed usage. */
export type LimitInfo = {
  __typename: 'LimitInfo';
  /** Defines the allowed maximum resource usage, null means unlimited. */
  allowedUsage: Limits;
  /** Defines the current resource usage. */
  currentUsage: Limits;
};

export type Limits = {
  __typename: 'Limits';
  /** Defines the number of channels. */
  channels: Maybe<Scalars['Int']>;
  /** Defines the number of order. */
  orders: Maybe<Scalars['Int']>;
  /** Defines the number of product variants. */
  productVariants: Maybe<Scalars['Int']>;
  /** Defines the number of staff users. */
  staffUsers: Maybe<Scalars['Int']>;
  /** Defines the number of warehouses. */
  warehouses: Maybe<Scalars['Int']>;
};

/** Filter input for order lines data. */
export type LinesFilterInput = {
  /** Filter by metadata fields of order lines. */
  metadata: InputMaybe<MetadataFilterInput>;
};

/**
 * List payment methods stored for the user by payment gateway.
 *
 * Note: this API is currently in Feature Preview and can be subject to changes at later point.
 */
export type ListStoredPaymentMethods = Event & {
  __typename: 'ListStoredPaymentMethods';
  /** Channel in context which was used to fetch the list of payment methods. */
  channel: Channel;
  /** Time of the event. */
  issuedAt: Maybe<Scalars['DateTime']>;
  /** The user or application that triggered the event. */
  issuingPrincipal: Maybe<IssuingPrincipal>;
  /** The application receiving the webhook. */
  recipient: Maybe<App>;
  /** The user for which the app should return a list of payment methods. */
  user: User;
  /** Saleor version that triggered the event. */
  version: Maybe<Scalars['String']>;
};

/** The manifest definition. */
export type Manifest = {
  __typename: 'Manifest';
  /** Description of the app displayed in the dashboard. */
  about: Maybe<Scalars['String']>;
  /** App website rendered in the dashboard. */
  appUrl: Maybe<Scalars['String']>;
  /** The audience that will be included in all JWT tokens for the app. */
  audience: Maybe<Scalars['String']>;
  /** The App's author name. */
  author: Maybe<Scalars['String']>;
  /** App's brand data. */
  brand: Maybe<AppManifestBrand>;
  /**
   * URL to iframe with the configuration for the app.
   * @deprecated Use `appUrl` instead.
   */
  configurationUrl: Maybe<Scalars['String']>;
  /**
   * Description of the data privacy defined for this app.
   * @deprecated Use `dataPrivacyUrl` instead.
   */
  dataPrivacy: Maybe<Scalars['String']>;
  /** URL to the full privacy policy. */
  dataPrivacyUrl: Maybe<Scalars['String']>;
  /** List of extensions that will be mounted in Saleor's dashboard. For details, please [see the extension section.](https://docs.saleor.io/developer/extending/apps/extending-dashboard-with-apps#key-concepts) */
  extensions: Array<AppManifestExtension>;
  /** External URL to the app homepage. */
  homepageUrl: Maybe<Scalars['String']>;
  /** The identifier of the manifest for the app. */
  identifier: Scalars['String'];
  /** The name of the manifest for the app . */
  name: Scalars['String'];
  /** The array permissions required for the app. */
  permissions: Maybe<Array<Permission>>;
  /** Determines the app's required Saleor version as semver range. */
  requiredSaleorVersion: Maybe<AppManifestRequiredSaleorVersion>;
  /** External URL to the page where app users can find support. */
  supportUrl: Maybe<Scalars['String']>;
  /** Endpoint used during process of app installation, [see installing an app.](https://docs.saleor.io/developer/extending/apps/installing-apps#installing-an-app) */
  tokenTargetUrl: Maybe<Scalars['String']>;
  /** The version of the manifest for the app. */
  version: Scalars['String'];
  /** List of the app's webhooks. */
  webhooks: Array<AppManifestWebhook>;
};

/** Metadata for the Margin class. */
export type Margin = {
  __typename: 'Margin';
  /** The starting value of the margin. */
  start: Maybe<Scalars['Int']>;
  /** The ending value of the margin. */
  stop: Maybe<Scalars['Int']>;
};

/**
 * Determine the mark as paid strategy for the channel.
 *
 *     TRANSACTION_FLOW - new orders marked as paid will receive a
 *     `TransactionItem` object, that will cover the `order.total`.
 *
 *     PAYMENT_FLOW - new orders marked as paid will receive a
 *     `Payment` object, that will cover the `order.total`.
 */
export type MarkAsPaidStrategyEnum =
  | 'PAYMENT_FLOW'
  | 'TRANSACTION_FLOW';

export type MeasurementUnitsEnum =
  | 'ACRE_FT'
  | 'ACRE_IN'
  | 'CM'
  | 'CUBIC_CENTIMETER'
  | 'CUBIC_DECIMETER'
  | 'CUBIC_FOOT'
  | 'CUBIC_INCH'
  | 'CUBIC_METER'
  | 'CUBIC_MILLIMETER'
  | 'CUBIC_YARD'
  | 'DM'
  | 'FL_OZ'
  | 'FT'
  | 'G'
  | 'INCH'
  | 'KG'
  | 'KM'
  | 'LB'
  | 'LITER'
  | 'M'
  | 'MM'
  | 'OZ'
  | 'PINT'
  | 'QT'
  | 'SQ_CM'
  | 'SQ_DM'
  | 'SQ_FT'
  | 'SQ_INCH'
  | 'SQ_KM'
  | 'SQ_M'
  | 'SQ_MM'
  | 'SQ_YD'
  | 'TONNE'
  | 'YD';

export type MeasurementUnitsEnumFilterInput = {
  /** The value equal to. */
  eq: InputMaybe<MeasurementUnitsEnum>;
  /** The value included in. */
  oneOf: InputMaybe<Array<MeasurementUnitsEnum>>;
};

export type MediaChoicesSortField =
  /** Sort media by ID. */
  | 'ID';

export type MediaInput = {
  /** Alt text for a product media. */
  alt: InputMaybe<Scalars['String']>;
  /** Represents an image file in a multipart request. */
  image: InputMaybe<Scalars['Upload']>;
  /** Represents an URL to an external media. */
  mediaUrl: InputMaybe<Scalars['String']>;
};

export type MediaSortingInput = {
  /** Specifies the direction in which to sort media. */
  direction: OrderDirection;
  /** Sort media by the selected field. */
  field: MediaChoicesSortField;
};

/** Represents a single menu - an object that is used to help navigate through the store. */
export type Menu = Node & ObjectWithMetadata & {
  __typename: 'Menu';
  /** The ID of the menu. */
  id: Scalars['ID'];
  /** Menu items associated with this menu. */
  items: Maybe<Array<MenuItem>>;
  /** List of public metadata items. Can be accessed without permissions. */
  metadata: Array<MetadataItem>;
  /**
   * A single key from public metadata.
   *
   * Tip: Use GraphQL aliases to fetch multiple keys.
   */
  metafield: Maybe<Scalars['String']>;
  /** Public metadata. Use `keys` to control which fields you want to include. The default is to include everything. */
  metafields: Maybe<Scalars['Metadata']>;
  /** The name of the menu. */
  name: Scalars['String'];
  /** List of private metadata items. Requires staff permissions to access. */
  privateMetadata: Array<MetadataItem>;
  /**
   * A single key from private metadata. Requires staff permissions to access.
   *
   * Tip: Use GraphQL aliases to fetch multiple keys.
   */
  privateMetafield: Maybe<Scalars['String']>;
  /** Private metadata. Requires staff permissions to access. Use `keys` to control which fields you want to include. The default is to include everything. */
  privateMetafields: Maybe<Scalars['Metadata']>;
  /** Slug of the menu. */
  slug: Scalars['String'];
};


/** Represents a single menu - an object that is used to help navigate through the store. */
export type MenuMetafieldArgs = {
  key: Scalars['String'];
};


/** Represents a single menu - an object that is used to help navigate through the store. */
export type MenuMetafieldsArgs = {
  keys: InputMaybe<Array<Scalars['String']>>;
};


/** Represents a single menu - an object that is used to help navigate through the store. */
export type MenuPrivateMetafieldArgs = {
  key: Scalars['String'];
};


/** Represents a single menu - an object that is used to help navigate through the store. */
export type MenuPrivateMetafieldsArgs = {
  keys: InputMaybe<Array<Scalars['String']>>;
};

/**
 * Deletes menus.
 *
 * Requires one of the following permissions: MANAGE_MENUS.
 *
 * Triggers the following webhook events:
 * - MENU_DELETED (async): A menu was deleted.
 */
export type MenuBulkDelete = {
  __typename: 'MenuBulkDelete';
  /** Returns how many objects were affected. */
  count: Scalars['Int'];
  errors: Array<MenuError>;
  /** @deprecated Use `errors` field instead. */
  menuErrors: Array<MenuError>;
};

export type MenuCountableConnection = {
  __typename: 'MenuCountableConnection';
  edges: Array<MenuCountableEdge>;
  /** Pagination data for this connection. */
  pageInfo: PageInfo;
  /** A total count of items in the collection. */
  totalCount: Maybe<Scalars['Int']>;
};

export type MenuCountableEdge = {
  __typename: 'MenuCountableEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node: Menu;
};

/**
 * Creates a new Menu.
 *
 * Requires one of the following permissions: MANAGE_MENUS.
 *
 * Triggers the following webhook events:
 * - MENU_CREATED (async): A menu was created.
 */
export type MenuCreate = {
  __typename: 'MenuCreate';
  errors: Array<MenuError>;
  menu: Maybe<Menu>;
  /** @deprecated Use `errors` field instead. */
  menuErrors: Array<MenuError>;
};

export type MenuCreateInput = {
  /** List of menu items. */
  items: InputMaybe<Array<MenuItemInput>>;
  /** Name of the menu. */
  name: Scalars['String'];
  /** Slug of the menu. Will be generated if not provided. */
  slug: InputMaybe<Scalars['String']>;
};

/** Event sent when new menu is created. */
export type MenuCreated = Event & {
  __typename: 'MenuCreated';
  /** Time of the event. */
  issuedAt: Maybe<Scalars['DateTime']>;
  /** The user or application that triggered the event. */
  issuingPrincipal: Maybe<IssuingPrincipal>;
  /** The menu the event relates to. */
  menu: Maybe<Menu>;
  /** The application receiving the webhook. */
  recipient: Maybe<App>;
  /** Saleor version that triggered the event. */
  version: Maybe<Scalars['String']>;
};


/** Event sent when new menu is created. */
export type MenuCreatedMenuArgs = {
  channel: InputMaybe<Scalars['String']>;
};

/**
 * Deletes a menu.
 *
 * Requires one of the following permissions: MANAGE_MENUS.
 *
 * Triggers the following webhook events:
 * - MENU_DELETED (async): A menu was deleted.
 */
export type MenuDelete = {
  __typename: 'MenuDelete';
  errors: Array<MenuError>;
  menu: Maybe<Menu>;
  /** @deprecated Use `errors` field instead. */
  menuErrors: Array<MenuError>;
};

/** Event sent when menu is deleted. */
export type MenuDeleted = Event & {
  __typename: 'MenuDeleted';
  /** Time of the event. */
  issuedAt: Maybe<Scalars['DateTime']>;
  /** The user or application that triggered the event. */
  issuingPrincipal: Maybe<IssuingPrincipal>;
  /** The menu the event relates to. */
  menu: Maybe<Menu>;
  /** The application receiving the webhook. */
  recipient: Maybe<App>;
  /** Saleor version that triggered the event. */
  version: Maybe<Scalars['String']>;
};


/** Event sent when menu is deleted. */
export type MenuDeletedMenuArgs = {
  channel: InputMaybe<Scalars['String']>;
};

export type MenuError = {
  __typename: 'MenuError';
  /** The error code. */
  code: MenuErrorCode;
  /** Name of a field that caused the error. A value of `null` indicates that the error isn't associated with a particular field. */
  field: Maybe<Scalars['String']>;
  /** The error message. */
  message: Maybe<Scalars['String']>;
};

export type MenuErrorCode =
  | 'CANNOT_ASSIGN_NODE'
  | 'GRAPHQL_ERROR'
  | 'INVALID'
  | 'INVALID_MENU_ITEM'
  | 'NOT_FOUND'
  | 'NO_MENU_ITEM_PROVIDED'
  | 'REQUIRED'
  | 'TOO_MANY_MENU_ITEMS'
  | 'UNIQUE';

export type MenuFilterInput = {
  metadata: InputMaybe<Array<MetadataFilter>>;
  search: InputMaybe<Scalars['String']>;
  slug: InputMaybe<Array<Scalars['String']>>;
  slugs: InputMaybe<Array<Scalars['String']>>;
};

export type MenuInput = {
  /** Name of the menu. */
  name: InputMaybe<Scalars['String']>;
  /** Slug of the menu. */
  slug: InputMaybe<Scalars['String']>;
};

/** Represents a single item of the related menu. Can store categories, collection or pages. */
export type MenuItem = Node & ObjectWithMetadata & {
  __typename: 'MenuItem';
  /** Category associated with the menu item. */
  category: Maybe<Category>;
  /** Represents the child items of the current menu item. */
  children: Maybe<Array<MenuItem>>;
  /** A collection associated with this menu item. Requires one of the following permissions to include the unpublished items: MANAGE_ORDERS, MANAGE_DISCOUNTS, MANAGE_PRODUCTS. */
  collection: Maybe<Collection>;
  /** The ID of the menu item. */
  id: Scalars['ID'];
  /** Indicates the position of the menu item within the menu structure. */
  level: Scalars['Int'];
  /** Represents the menu to which the menu item belongs. */
  menu: Menu;
  /** List of public metadata items. Can be accessed without permissions. */
  metadata: Array<MetadataItem>;
  /**
   * A single key from public metadata.
   *
   * Tip: Use GraphQL aliases to fetch multiple keys.
   */
  metafield: Maybe<Scalars['String']>;
  /** Public metadata. Use `keys` to control which fields you want to include. The default is to include everything. */
  metafields: Maybe<Scalars['Metadata']>;
  /** The name of the menu item. */
  name: Scalars['String'];
  /** A page associated with this menu item. Requires one of the following permissions to include unpublished items: MANAGE_PAGES. */
  page: Maybe<Page>;
  /** ID of parent menu item. If empty, menu will be top level menu. */
  parent: Maybe<MenuItem>;
  /** List of private metadata items. Requires staff permissions to access. */
  privateMetadata: Array<MetadataItem>;
  /**
   * A single key from private metadata. Requires staff permissions to access.
   *
   * Tip: Use GraphQL aliases to fetch multiple keys.
   */
  privateMetafield: Maybe<Scalars['String']>;
  /** Private metadata. Requires staff permissions to access. Use `keys` to control which fields you want to include. The default is to include everything. */
  privateMetafields: Maybe<Scalars['Metadata']>;
  /** Returns translated menu item fields for the given language code. */
  translation: Maybe<MenuItemTranslation>;
  /** URL to the menu item. */
  url: Maybe<Scalars['String']>;
};


/** Represents a single item of the related menu. Can store categories, collection or pages. */
export type MenuItemMetafieldArgs = {
  key: Scalars['String'];
};


/** Represents a single item of the related menu. Can store categories, collection or pages. */
export type MenuItemMetafieldsArgs = {
  keys: InputMaybe<Array<Scalars['String']>>;
};


/** Represents a single item of the related menu. Can store categories, collection or pages. */
export type MenuItemPrivateMetafieldArgs = {
  key: Scalars['String'];
};


/** Represents a single item of the related menu. Can store categories, collection or pages. */
export type MenuItemPrivateMetafieldsArgs = {
  keys: InputMaybe<Array<Scalars['String']>>;
};


/** Represents a single item of the related menu. Can store categories, collection or pages. */
export type MenuItemTranslationArgs = {
  languageCode: LanguageCodeEnum;
};

/**
 * Deletes menu items.
 *
 * Requires one of the following permissions: MANAGE_MENUS.
 *
 * Triggers the following webhook events:
 * - MENU_ITEM_DELETED (async): A menu item was deleted.
 */
export type MenuItemBulkDelete = {
  __typename: 'MenuItemBulkDelete';
  /** Returns how many objects were affected. */
  count: Scalars['Int'];
  errors: Array<MenuError>;
  /** @deprecated Use `errors` field instead. */
  menuErrors: Array<MenuError>;
};

export type MenuItemCountableConnection = {
  __typename: 'MenuItemCountableConnection';
  edges: Array<MenuItemCountableEdge>;
  /** Pagination data for this connection. */
  pageInfo: PageInfo;
  /** A total count of items in the collection. */
  totalCount: Maybe<Scalars['Int']>;
};

export type MenuItemCountableEdge = {
  __typename: 'MenuItemCountableEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node: MenuItem;
};

/**
 * Creates a new menu item.
 *
 * Requires one of the following permissions: MANAGE_MENUS.
 *
 * Triggers the following webhook events:
 * - MENU_ITEM_CREATED (async): A menu item was created.
 */
export type MenuItemCreate = {
  __typename: 'MenuItemCreate';
  errors: Array<MenuError>;
  /** @deprecated Use `errors` field instead. */
  menuErrors: Array<MenuError>;
  menuItem: Maybe<MenuItem>;
};

export type MenuItemCreateInput = {
  /** Category to which item points. */
  category: InputMaybe<Scalars['ID']>;
  /** Collection to which item points. */
  collection: InputMaybe<Scalars['ID']>;
  /** Menu to which item belongs. */
  menu: Scalars['ID'];
  /** Name of the menu item. */
  name: Scalars['String'];
  /** Page to which item points. */
  page: InputMaybe<Scalars['ID']>;
  /** ID of the parent menu. If empty, menu will be top level menu. */
  parent: InputMaybe<Scalars['ID']>;
  /** URL of the pointed item. */
  url: InputMaybe<Scalars['String']>;
};

/** Event sent when new menu item is created. */
export type MenuItemCreated = Event & {
  __typename: 'MenuItemCreated';
  /** Time of the event. */
  issuedAt: Maybe<Scalars['DateTime']>;
  /** The user or application that triggered the event. */
  issuingPrincipal: Maybe<IssuingPrincipal>;
  /** The menu item the event relates to. */
  menuItem: Maybe<MenuItem>;
  /** The application receiving the webhook. */
  recipient: Maybe<App>;
  /** Saleor version that triggered the event. */
  version: Maybe<Scalars['String']>;
};


/** Event sent when new menu item is created. */
export type MenuItemCreatedMenuItemArgs = {
  channel: InputMaybe<Scalars['String']>;
};

/**
 * Deletes a menu item.
 *
 * Requires one of the following permissions: MANAGE_MENUS.
 *
 * Triggers the following webhook events:
 * - MENU_ITEM_DELETED (async): A menu item was deleted.
 */
export type MenuItemDelete = {
  __typename: 'MenuItemDelete';
  errors: Array<MenuError>;
  /** @deprecated Use `errors` field instead. */
  menuErrors: Array<MenuError>;
  menuItem: Maybe<MenuItem>;
};

/** Event sent when menu item is deleted. */
export type MenuItemDeleted = Event & {
  __typename: 'MenuItemDeleted';
  /** Time of the event. */
  issuedAt: Maybe<Scalars['DateTime']>;
  /** The user or application that triggered the event. */
  issuingPrincipal: Maybe<IssuingPrincipal>;
  /** The menu item the event relates to. */
  menuItem: Maybe<MenuItem>;
  /** The application receiving the webhook. */
  recipient: Maybe<App>;
  /** Saleor version that triggered the event. */
  version: Maybe<Scalars['String']>;
};


/** Event sent when menu item is deleted. */
export type MenuItemDeletedMenuItemArgs = {
  channel: InputMaybe<Scalars['String']>;
};

export type MenuItemFilterInput = {
  metadata: InputMaybe<Array<MetadataFilter>>;
  search: InputMaybe<Scalars['String']>;
};

export type MenuItemInput = {
  /** Category to which item points. */
  category: InputMaybe<Scalars['ID']>;
  /** Collection to which item points. */
  collection: InputMaybe<Scalars['ID']>;
  /** Name of the menu item. */
  name: InputMaybe<Scalars['String']>;
  /** Page to which item points. */
  page: InputMaybe<Scalars['ID']>;
  /** URL of the pointed item. */
  url: InputMaybe<Scalars['String']>;
};

/**
 * Moves items of menus.
 *
 * Requires one of the following permissions: MANAGE_MENUS.
 *
 * Triggers the following webhook events:
 * - MENU_ITEM_UPDATED (async): Optionally triggered when sort order or parent changed for menu item.
 */
export type MenuItemMove = {
  __typename: 'MenuItemMove';
  errors: Array<MenuError>;
  /** Assigned menu to move within. */
  menu: Maybe<Menu>;
  /** @deprecated Use `errors` field instead. */
  menuErrors: Array<MenuError>;
};

export type MenuItemMoveInput = {
  /** The menu item ID to move. */
  itemId: Scalars['ID'];
  /** ID of the parent menu. If empty, menu will be top level menu. */
  parentId: InputMaybe<Scalars['ID']>;
  /** The new relative sorting position of the item (from -inf to +inf). 1 moves the item one position forward, -1 moves the item one position backward, 0 leaves the item unchanged. */
  sortOrder: InputMaybe<Scalars['Int']>;
};

export type MenuItemSortingInput = {
  /** Specifies the direction in which to sort menu items. */
  direction: OrderDirection;
  /** Sort menu items by the selected field. */
  field: MenuItemsSortField;
};

/** Represents menu item's original translatable fields and related translations. */
export type MenuItemTranslatableContent = Node & {
  __typename: 'MenuItemTranslatableContent';
  /** The ID of the menu item translatable content. */
  id: Scalars['ID'];
  /**
   * Represents a single item of the related menu. Can store categories, collection or pages.
   * @deprecated Get model fields from the root level queries.
   */
  menuItem: Maybe<MenuItem>;
  /** The ID of the menu item to translate. */
  menuItemId: Scalars['ID'];
  /** Name of the menu item to translate. */
  name: Scalars['String'];
  /** Returns translated menu item fields for the given language code. */
  translation: Maybe<MenuItemTranslation>;
};


/** Represents menu item's original translatable fields and related translations. */
export type MenuItemTranslatableContentTranslationArgs = {
  languageCode: LanguageCodeEnum;
};

/**
 * Creates/updates translations for a menu item.
 *
 * Requires one of the following permissions: MANAGE_TRANSLATIONS.
 */
export type MenuItemTranslate = {
  __typename: 'MenuItemTranslate';
  errors: Array<TranslationError>;
  menuItem: Maybe<MenuItem>;
  /** @deprecated Use `errors` field instead. */
  translationErrors: Array<TranslationError>;
};

/** Represents menu item translations. */
export type MenuItemTranslation = Node & {
  __typename: 'MenuItemTranslation';
  /** The ID of the menu item translation. */
  id: Scalars['ID'];
  /** Translation language. */
  language: LanguageDisplay;
  /** Translated menu item name. */
  name: Scalars['String'];
  /** Represents the menu item fields to translate. */
  translatableContent: Maybe<MenuItemTranslatableContent>;
};

/**
 * Updates a menu item.
 *
 * Requires one of the following permissions: MANAGE_MENUS.
 *
 * Triggers the following webhook events:
 * - MENU_ITEM_UPDATED (async): A menu item was updated.
 */
export type MenuItemUpdate = {
  __typename: 'MenuItemUpdate';
  errors: Array<MenuError>;
  /** @deprecated Use `errors` field instead. */
  menuErrors: Array<MenuError>;
  menuItem: Maybe<MenuItem>;
};

/** Event sent when menu item is updated. */
export type MenuItemUpdated = Event & {
  __typename: 'MenuItemUpdated';
  /** Time of the event. */
  issuedAt: Maybe<Scalars['DateTime']>;
  /** The user or application that triggered the event. */
  issuingPrincipal: Maybe<IssuingPrincipal>;
  /** The menu item the event relates to. */
  menuItem: Maybe<MenuItem>;
  /** The application receiving the webhook. */
  recipient: Maybe<App>;
  /** Saleor version that triggered the event. */
  version: Maybe<Scalars['String']>;
};


/** Event sent when menu item is updated. */
export type MenuItemUpdatedMenuItemArgs = {
  channel: InputMaybe<Scalars['String']>;
};

export type MenuItemsSortField =
  /** Sort menu items by name. */
  | 'NAME';

export type MenuSortField =
  /** Sort menus by items count. */
  | 'ITEMS_COUNT'
  /** Sort menus by name. */
  | 'NAME';

export type MenuSortingInput = {
  /** Specifies the direction in which to sort menus. */
  direction: OrderDirection;
  /** Sort menus by the selected field. */
  field: MenuSortField;
};

/**
 * Updates a menu.
 *
 * Requires one of the following permissions: MANAGE_MENUS.
 *
 * Triggers the following webhook events:
 * - MENU_UPDATED (async): A menu was updated.
 */
export type MenuUpdate = {
  __typename: 'MenuUpdate';
  errors: Array<MenuError>;
  menu: Maybe<Menu>;
  /** @deprecated Use `errors` field instead. */
  menuErrors: Array<MenuError>;
};

/** Event sent when menu is updated. */
export type MenuUpdated = Event & {
  __typename: 'MenuUpdated';
  /** Time of the event. */
  issuedAt: Maybe<Scalars['DateTime']>;
  /** The user or application that triggered the event. */
  issuingPrincipal: Maybe<IssuingPrincipal>;
  /** The menu the event relates to. */
  menu: Maybe<Menu>;
  /** The application receiving the webhook. */
  recipient: Maybe<App>;
  /** Saleor version that triggered the event. */
  version: Maybe<Scalars['String']>;
};


/** Event sent when menu is updated. */
export type MenuUpdatedMenuArgs = {
  channel: InputMaybe<Scalars['String']>;
};

export type MetadataError = {
  __typename: 'MetadataError';
  /** The error code. */
  code: MetadataErrorCode;
  /** Name of a field that caused the error. A value of `null` indicates that the error isn't associated with a particular field. */
  field: Maybe<Scalars['String']>;
  /** The error message. */
  message: Maybe<Scalars['String']>;
};

export type MetadataErrorCode =
  | 'GRAPHQL_ERROR'
  | 'INVALID'
  | 'NOT_FOUND'
  | 'NOT_UPDATED'
  | 'REQUIRED';

export type MetadataFilter = {
  /** Key of a metadata item. */
  key: Scalars['String'];
  /** Value of a metadata item. */
  value: InputMaybe<Scalars['String']>;
};

/**
 * Allows filtering based on metadata key/value pairs.
 *
 *         Examples:
 *         - `{key: "size"}`
 *           Matches objects where the metadata key "size" exists, regardless of its value.
 *         - `{key: "color", value: {oneOf: ["blue", "green"]}}`
 *           Matches objects where the metadata key "color" is set to either "blue" or "green".
 *         - `{key: "status", value: {eq: "active"}}`
 *           Matches objects where the metadata key "status" is set to "active".
 */
export type MetadataFilterInput = {
  /** Key to filter by. If not other fields provided - checking the existence of the key in metadata. */
  key: Scalars['String'];
  /** Value to filter by. */
  value: InputMaybe<MetadataValueFilterInput>;
};

export type MetadataInput = {
  /** Key of a metadata item. */
  key: Scalars['String'];
  /** Value of a metadata item. */
  value: Scalars['String'];
};

export type MetadataItem = {
  __typename: 'MetadataItem';
  /** Key of a metadata item. */
  key: Scalars['String'];
  /** Value of a metadata item. */
  value: Scalars['String'];
};

/** Define the filtering options for metadata value fields. */
export type MetadataValueFilterInput = {
  /** The value equal to. */
  eq: InputMaybe<Scalars['String']>;
  /** The value included in. */
  oneOf: InputMaybe<Array<Scalars['String']>>;
};

/** Represents amount of money in specific currency. */
export type Money = {
  __typename: 'Money';
  /** Amount of money. */
  amount: Scalars['Float'];
  /** Currency code. */
  currency: Scalars['String'];
  /** Number of digits after the decimal point in the currency. */
  fractionDigits: Scalars['Int'];
  /** Amount of money represented as an integer in the smallest currency unit. */
  fractionalAmount: Scalars['Int'];
};

export type MoneyInput = {
  /** Amount of money. */
  amount: Scalars['PositiveDecimal'];
  /** Currency code. */
  currency: Scalars['String'];
};

/** Represents a range of amounts of money. */
export type MoneyRange = {
  __typename: 'MoneyRange';
  /** Lower bound of a price range. */
  start: Maybe<Money>;
  /** Upper bound of a price range. */
  stop: Maybe<Money>;
};

export type MoveProductInput = {
  /** The ID of the product to move. */
  productId: Scalars['ID'];
  /** The relative sorting position of the product (from -inf to +inf) starting from the first given product's actual position.1 moves the item one position forward, -1 moves the item one position backward, 0 leaves the item unchanged. */
  sortOrder: InputMaybe<Scalars['Int']>;
};

export type Mutation = {
  __typename: 'Mutation';
  /**
   * Create a new address for the customer.
   *
   * Requires one of following set of permissions: AUTHENTICATED_USER or AUTHENTICATED_APP + IMPERSONATE_USER.
   *
   * Triggers the following webhook events:
   * - CUSTOMER_UPDATED (async): A customer account was updated.
   * - ADDRESS_CREATED (async): An address was created.
   */
  accountAddressCreate: Maybe<AccountAddressCreate>;
  /**
   * Deletes an address of the logged-in user. Requires one of the following permissions: MANAGE_USERS, IS_OWNER.
   *
   * Triggers the following webhook events:
   * - ADDRESS_DELETED (async): An address was deleted.
   */
  accountAddressDelete: Maybe<AccountAddressDelete>;
  /**
   * Updates an address of the logged-in user. Requires one of the following permissions: MANAGE_USERS, IS_OWNER.
   *
   * Triggers the following webhook events:
   * - ADDRESS_UPDATED (async): An address was updated.
   */
  accountAddressUpdate: Maybe<AccountAddressUpdate>;
  /**
   * Remove user account.
   *
   * Requires one of the following permissions: AUTHENTICATED_USER.
   *
   * Triggers the following webhook events:
   * - ACCOUNT_DELETED (async): Account was deleted.
   */
  accountDelete: Maybe<AccountDelete>;
  /**
   * Register a new user.
   *
   * Triggers the following webhook events:
   * - CUSTOMER_CREATED (async): A new customer account was created.
   * - NOTIFY_USER (async): A notification for account confirmation.
   * - ACCOUNT_CONFIRMATION_REQUESTED (async): An user confirmation was requested. This event is always sent regardless of settings.
   */
  accountRegister: Maybe<AccountRegister>;
  /**
   * Sends an email with the account removal link for the logged-in user.
   *
   * Requires one of the following permissions: AUTHENTICATED_USER.
   *
   * Triggers the following webhook events:
   * - NOTIFY_USER (async): A notification for account delete request.
   * - ACCOUNT_DELETE_REQUESTED (async): An account delete requested.
   */
  accountRequestDeletion: Maybe<AccountRequestDeletion>;
  /**
   * Sets a default address for the authenticated user.
   *
   * Requires one of the following permissions: AUTHENTICATED_USER.
   *
   * Triggers the following webhook events:
   * - CUSTOMER_UPDATED (async): A customer's address was updated.
   */
  accountSetDefaultAddress: Maybe<AccountSetDefaultAddress>;
  /**
   * Updates the account of the logged-in user.
   *
   * Requires one of following set of permissions: AUTHENTICATED_USER or AUTHENTICATED_APP + IMPERSONATE_USER.
   *
   * Triggers the following webhook events:
   * - CUSTOMER_UPDATED (async): A customer account was updated.
   * - CUSTOMER_METADATA_UPDATED (async): Optionally called when customer's metadata was updated.
   */
  accountUpdate: Maybe<AccountUpdate>;
  /**
   * Creates user address.
   *
   * Requires one of the following permissions: MANAGE_USERS.
   *
   * Triggers the following webhook events:
   * - ADDRESS_CREATED (async): A new address was created.
   */
  addressCreate: Maybe<AddressCreate>;
  /**
   * Deletes an address.
   *
   * Requires one of the following permissions: MANAGE_USERS.
   *
   * Triggers the following webhook events:
   * - ADDRESS_DELETED (async): An address was deleted.
   */
  addressDelete: Maybe<AddressDelete>;
  /**
   * Sets a default address for the given user.
   *
   * Requires one of the following permissions: MANAGE_USERS.
   *
   * Triggers the following webhook events:
   * - CUSTOMER_UPDATED (async): A customer was updated.
   */
  addressSetDefault: Maybe<AddressSetDefault>;
  /**
   * Updates an address.
   *
   * Requires one of the following permissions: MANAGE_USERS.
   *
   * Triggers the following webhook events:
   * - ADDRESS_UPDATED (async): An address was updated.
   */
  addressUpdate: Maybe<AddressUpdate>;
  /**
   * Activate the app.
   *
   * Requires one of the following permissions: MANAGE_APPS.
   *
   * Triggers the following webhook events:
   * - APP_STATUS_CHANGED (async): An app was activated.
   */
  appActivate: Maybe<AppActivate>;
  /**
   * Creates a new app. Requires the following permissions: AUTHENTICATED_STAFF_USER and MANAGE_APPS.
   *
   * Triggers the following webhook events:
   * - APP_INSTALLED (async): An app was installed.
   */
  appCreate: Maybe<AppCreate>;
  /**
   * Deactivate the app.
   *
   * Requires one of the following permissions: MANAGE_APPS.
   *
   * Triggers the following webhook events:
   * - APP_STATUS_CHANGED (async): An app was deactivated.
   */
  appDeactivate: Maybe<AppDeactivate>;
  /**
   * Deletes an app.
   *
   * Requires one of the following permissions: MANAGE_APPS.
   *
   * Triggers the following webhook events:
   * - APP_DELETED (async): An app was deleted.
   */
  appDelete: Maybe<AppDelete>;
  /**
   * Deletes failed installation.
   *
   * Requires one of the following permissions: MANAGE_APPS.
   */
  appDeleteFailedInstallation: Maybe<AppDeleteFailedInstallation>;
  /**
   * Fetch and validate manifest.
   *
   * Requires one of the following permissions: MANAGE_APPS.
   */
  appFetchManifest: Maybe<AppFetchManifest>;
  /** Install new app by using app manifest. Requires the following permissions: AUTHENTICATED_STAFF_USER and MANAGE_APPS. */
  appInstall: Maybe<AppInstall>;
  /**
   * Add a problem to the calling app.
   *
   * Added in Saleor 3.22.
   *
   * Requires one of the following permissions: AUTHENTICATED_APP.
   */
  appProblemCreate: Maybe<AppProblemCreate>;
  /**
   * Dismiss problems for an app.
   *
   * Added in Saleor 3.22.
   *
   * Requires one of the following permissions: MANAGE_APPS, AUTHENTICATED_APP.
   */
  appProblemDismiss: Maybe<AppProblemDismiss>;
  /**
   * Re-enable sync webhooks for provided app. Can be used to manually re-enable sync webhooks for the app before the cooldown period ends.
   *
   * Added in Saleor 3.21.
   *
   * Requires one of the following permissions: MANAGE_APPS.
   */
  appReenableSyncWebhooks: Maybe<AppReenableSyncWebhooks>;
  /**
   * Retry failed installation of new app.
   *
   * Requires one of the following permissions: MANAGE_APPS.
   *
   * Triggers the following webhook events:
   * - APP_INSTALLED (async): An app was installed.
   */
  appRetryInstall: Maybe<AppRetryInstall>;
  /**
   * Creates a new token.
   *
   * Requires one of the following permissions: MANAGE_APPS.
   */
  appTokenCreate: Maybe<AppTokenCreate>;
  /**
   * Deletes an authentication token assigned to app.
   *
   * Requires one of the following permissions: MANAGE_APPS.
   */
  appTokenDelete: Maybe<AppTokenDelete>;
  /** Verify provided app token. */
  appTokenVerify: Maybe<AppTokenVerify>;
  /**
   * Updates an existing app.
   *
   * Requires one of the following permissions: MANAGE_APPS.
   *
   * Triggers the following webhook events:
   * - APP_UPDATED (async): An app was updated.
   */
  appUpdate: Maybe<AppUpdate>;
  /**
   * Assigns storefront's navigation menus.
   *
   * Requires one of the following permissions: MANAGE_MENUS, MANAGE_SETTINGS.
   */
  assignNavigation: Maybe<AssignNavigation>;
  /**
   * Add shipping zone to given warehouse.
   *
   * Requires one of the following permissions: MANAGE_PRODUCTS.
   */
  assignWarehouseShippingZone: Maybe<WarehouseShippingZoneAssign>;
  /**
   * Creates attributes.
   *
   * Triggers the following webhook events:
   * - ATTRIBUTE_CREATED (async): An attribute was created.
   */
  attributeBulkCreate: Maybe<AttributeBulkCreate>;
  /**
   * Deletes attributes.
   *
   * Requires one of the following permissions: MANAGE_PAGE_TYPES_AND_ATTRIBUTES.
   *
   * Triggers the following webhook events:
   * - ATTRIBUTE_DELETED (async): An attribute was deleted.
   */
  attributeBulkDelete: Maybe<AttributeBulkDelete>;
  /**
   * Creates/updates translations for attributes.
   *
   * Requires one of the following permissions: MANAGE_TRANSLATIONS.
   */
  attributeBulkTranslate: Maybe<AttributeBulkTranslate>;
  /**
   * Updates attributes.
   *
   * Triggers the following webhook events:
   * - ATTRIBUTE_UPDATED (async): An attribute was updated. Optionally called when new attribute value was created or deleted.
   * - ATTRIBUTE_VALUE_CREATED (async): Called optionally when an attribute value was created.
   * - ATTRIBUTE_VALUE_DELETED (async): Called optionally when an attribute value was deleted.
   */
  attributeBulkUpdate: Maybe<AttributeBulkUpdate>;
  /**
   * Creates an attribute.
   *
   * Triggers the following webhook events:
   * - ATTRIBUTE_CREATED (async): An attribute was created.
   */
  attributeCreate: Maybe<AttributeCreate>;
  /**
   * Deletes an attribute.
   *
   * Requires one of the following permissions: MANAGE_PRODUCT_TYPES_AND_ATTRIBUTES.
   *
   * Triggers the following webhook events:
   * - ATTRIBUTE_DELETED (async): An attribute was deleted.
   */
  attributeDelete: Maybe<AttributeDelete>;
  /**
   * Reorder the values of an attribute.
   *
   * Requires one of the following permissions: MANAGE_PRODUCT_TYPES_AND_ATTRIBUTES.
   *
   * Triggers the following webhook events:
   * - ATTRIBUTE_VALUE_UPDATED (async): An attribute value was updated.
   * - ATTRIBUTE_UPDATED (async): An attribute was updated.
   */
  attributeReorderValues: Maybe<AttributeReorderValues>;
  /**
   * Creates/updates translations for an attribute.
   *
   * Requires one of the following permissions: MANAGE_TRANSLATIONS.
   */
  attributeTranslate: Maybe<AttributeTranslate>;
  /**
   * Updates attribute.
   *
   * Requires one of the following permissions: MANAGE_PRODUCT_TYPES_AND_ATTRIBUTES.
   *
   * Triggers the following webhook events:
   * - ATTRIBUTE_UPDATED (async): An attribute was updated.
   */
  attributeUpdate: Maybe<AttributeUpdate>;
  /**
   * Deletes values of attributes.
   *
   * Requires one of the following permissions: MANAGE_PAGE_TYPES_AND_ATTRIBUTES.
   *
   * Triggers the following webhook events:
   * - ATTRIBUTE_VALUE_DELETED (async): An attribute value was deleted.
   * - ATTRIBUTE_UPDATED (async): An attribute was updated.
   */
  attributeValueBulkDelete: Maybe<AttributeValueBulkDelete>;
  /**
   * Creates/updates translations for attribute values.
   *
   * Requires one of the following permissions: MANAGE_TRANSLATIONS.
   */
  attributeValueBulkTranslate: Maybe<AttributeValueBulkTranslate>;
  /**
   * Creates a value for an attribute.
   *
   * Requires one of the following permissions: MANAGE_PRODUCTS.
   *
   * Triggers the following webhook events:
   * - ATTRIBUTE_VALUE_CREATED (async): An attribute value was created.
   * - ATTRIBUTE_UPDATED (async): An attribute was updated.
   */
  attributeValueCreate: Maybe<AttributeValueCreate>;
  /**
   * Deletes a value of an attribute.
   *
   * Requires one of the following permissions: MANAGE_PRODUCT_TYPES_AND_ATTRIBUTES.
   *
   * Triggers the following webhook events:
   * - ATTRIBUTE_VALUE_DELETED (async): An attribute value was deleted.
   * - ATTRIBUTE_UPDATED (async): An attribute was updated.
   */
  attributeValueDelete: Maybe<AttributeValueDelete>;
  /**
   * Creates/updates translations for an attribute value.
   *
   * Requires one of the following permissions: MANAGE_TRANSLATIONS.
   */
  attributeValueTranslate: Maybe<AttributeValueTranslate>;
  /**
   * Updates value of an attribute.
   *
   * Requires one of the following permissions: MANAGE_PRODUCT_TYPES_AND_ATTRIBUTES.
   *
   * Triggers the following webhook events:
   * - ATTRIBUTE_VALUE_UPDATED (async): An attribute value was updated.
   * - ATTRIBUTE_UPDATED (async): An attribute was updated.
   */
  attributeValueUpdate: Maybe<AttributeValueUpdate>;
  /**
   * Deletes categories.
   *
   * Requires one of the following permissions: MANAGE_PRODUCTS.
   */
  categoryBulkDelete: Maybe<CategoryBulkDelete>;
  /**
   * Creates a new category.
   *
   * Requires one of the following permissions: MANAGE_PRODUCTS.
   */
  categoryCreate: Maybe<CategoryCreate>;
  /**
   * Deletes a category.
   *
   * Requires one of the following permissions: MANAGE_PRODUCTS.
   */
  categoryDelete: Maybe<CategoryDelete>;
  /**
   * Creates/updates translations for a category.
   *
   * Requires one of the following permissions: MANAGE_TRANSLATIONS.
   */
  categoryTranslate: Maybe<CategoryTranslate>;
  /**
   * Updates a category.
   *
   * Requires one of the following permissions: MANAGE_PRODUCTS.
   */
  categoryUpdate: Maybe<CategoryUpdate>;
  /**
   * Activate a channel.
   *
   * Requires one of the following permissions: MANAGE_CHANNELS.
   *
   * Triggers the following webhook events:
   * - CHANNEL_STATUS_CHANGED (async): A channel was activated.
   */
  channelActivate: Maybe<ChannelActivate>;
  /**
   * Creates a new channel.
   *
   * Requires one of the following permissions: MANAGE_CHANNELS.
   *
   * Triggers the following webhook events:
   * - CHANNEL_CREATED (async): A channel was created.
   */
  channelCreate: Maybe<ChannelCreate>;
  /**
   * Deactivate a channel.
   *
   * Requires one of the following permissions: MANAGE_CHANNELS.
   *
   * Triggers the following webhook events:
   * - CHANNEL_STATUS_CHANGED (async): A channel was deactivated.
   */
  channelDeactivate: Maybe<ChannelDeactivate>;
  /**
   * Deletes a channel. Orders associated with the deleted channel will be moved to the target channel. Checkouts, product availability, and pricing will be removed.
   *
   * Requires one of the following permissions: MANAGE_CHANNELS.
   *
   * Triggers the following webhook events:
   * - CHANNEL_DELETED (async): A channel was deleted.
   */
  channelDelete: Maybe<ChannelDelete>;
  /**
   * Reorder the warehouses of a channel.
   *
   * Requires one of the following permissions: MANAGE_CHANNELS.
   */
  channelReorderWarehouses: Maybe<ChannelReorderWarehouses>;
  /**
   * Update a channel.
   *
   * Requires one of the following permissions: MANAGE_CHANNELS.
   * Requires one of the following permissions when updating only `orderSettings` field: `MANAGE_CHANNELS`, `MANAGE_ORDERS`.
   * Requires one of the following permissions when updating only `checkoutSettings` field: `MANAGE_CHANNELS`, `MANAGE_CHECKOUTS`.
   * Requires one of the following permissions when updating only `paymentSettings` field: `MANAGE_CHANNELS`, `HANDLE_PAYMENTS`.
   *
   * Triggers the following webhook events:
   * - CHANNEL_UPDATED (async): A channel was updated.
   * - CHANNEL_METADATA_UPDATED (async): Optionally triggered when public or private metadata is updated.
   */
  channelUpdate: Maybe<ChannelUpdate>;
  /**
   * Adds a gift card or a voucher to a checkout.
   *
   * Triggers the following webhook events:
   * - CHECKOUT_UPDATED (async): A checkout was updated.
   */
  checkoutAddPromoCode: Maybe<CheckoutAddPromoCode>;
  /**
   * Updates billing address in the existing checkout.
   *
   * Triggers the following webhook events:
   * - CHECKOUT_UPDATED (async): A checkout was updated.
   */
  checkoutBillingAddressUpdate: Maybe<CheckoutBillingAddressUpdate>;
  /**
   * Completes the checkout. As a result a new order is created. The mutation allows to create the unpaid order when setting `orderSettings.allowUnpaidOrders` for given `Channel` is set to `true`. When `orderSettings.allowUnpaidOrders` is set to `false`, checkout can be completed only when attached `Payment`/`TransactionItem`s fully cover the checkout's total. When processing the checkout with `Payment`, in case of required additional confirmation step like 3D secure, the `confirmationNeeded` flag will be set to True and no order will be created until payment is confirmed with second call of this mutation.
   *
   * Triggers the following webhook events:
   * - SHIPPING_LIST_METHODS_FOR_CHECKOUT (sync): Optionally triggered when cached external shipping methods are invalid.
   * - CHECKOUT_FILTER_SHIPPING_METHODS (sync): Optionally triggered when cached filtered shipping methods are invalid.
   * - CHECKOUT_CALCULATE_TAXES (sync): Optionally triggered when checkout prices are expired.
   * - ORDER_CREATED (async): Triggered when order is created.
   * - NOTIFY_USER (async): A notification for order placement.
   * - NOTIFY_USER (async): A staff notification for order placement.
   * - ORDER_UPDATED (async): Triggered when order received the update after placement.
   * - ORDER_PAID (async): Triggered when newly created order is paid.
   * - ORDER_FULLY_PAID (async): Triggered when newly created order is fully paid.
   * - ORDER_CONFIRMED (async): Optionally triggered when newly created order are automatically marked as confirmed.
   */
  checkoutComplete: Maybe<CheckoutComplete>;
  /**
   * Create a new checkout.
   *
   * `skipValidation` field requires HANDLE_CHECKOUTS and AUTHENTICATED_APP permissions.
   *
   * Triggers the following webhook events:
   * - CHECKOUT_CREATED (async): A checkout was created.
   */
  checkoutCreate: Maybe<CheckoutCreate>;
  /** Creates a new checkout from existing order. */
  checkoutCreateFromOrder: Maybe<CheckoutCreateFromOrder>;
  /**
   * Sets the customer as the owner of the checkout.
   *
   * Requires one of the following permissions: AUTHENTICATED_APP, AUTHENTICATED_USER.
   *
   * Triggers the following webhook events:
   * - CHECKOUT_UPDATED (async): A checkout was updated.
   */
  checkoutCustomerAttach: Maybe<CheckoutCustomerAttach>;
  /**
   * Removes the user assigned as the owner of the checkout.
   *
   * Requires one of the following permissions: AUTHENTICATED_APP, AUTHENTICATED_USER.
   *
   * Triggers the following webhook events:
   * - CHECKOUT_UPDATED (async): A checkout was updated.
   */
  checkoutCustomerDetach: Maybe<CheckoutCustomerDetach>;
  /**
   * Updates customer note in the existing checkout object.
   *
   * Added in Saleor 3.21.
   *
   * Triggers the following webhook events:
   * - CHECKOUT_UPDATED (async): A checkout was updated.
   */
  checkoutCustomerNoteUpdate: Maybe<CheckoutCustomerNoteUpdate>;
  /**
   * Updates the delivery method (shipping method or pick up point) of the checkout. Updates the checkout shipping_address for click and collect delivery for a warehouse address.
   *
   * Triggers the following webhook events:
   * - SHIPPING_LIST_METHODS_FOR_CHECKOUT (sync): Triggered when updating the checkout delivery method with the external one.
   * - CHECKOUT_UPDATED (async): A checkout was updated.
   */
  checkoutDeliveryMethodUpdate: Maybe<CheckoutDeliveryMethodUpdate>;
  /**
   * Updates email address in the existing checkout object.
   *
   * Triggers the following webhook events:
   * - CHECKOUT_UPDATED (async): A checkout was updated.
   */
  checkoutEmailUpdate: Maybe<CheckoutEmailUpdate>;
  /**
   * Updates language code in the existing checkout.
   *
   * Triggers the following webhook events:
   * - CHECKOUT_UPDATED (async): A checkout was updated.
   */
  checkoutLanguageCodeUpdate: Maybe<CheckoutLanguageCodeUpdate>;
  /**
   * Deletes a CheckoutLine.
   *
   * Triggers the following webhook events:
   * - CHECKOUT_UPDATED (async): A checkout was updated.
   * @deprecated Use `checkoutLinesDelete` instead.
   */
  checkoutLineDelete: Maybe<CheckoutLineDelete>;
  /**
   * Adds a checkout line to the existing checkout.If line was already in checkout, its quantity will be increased.
   *
   * Triggers the following webhook events:
   * - CHECKOUT_UPDATED (async): A checkout was updated.
   */
  checkoutLinesAdd: Maybe<CheckoutLinesAdd>;
  /**
   * Deletes checkout lines.
   *
   * Triggers the following webhook events:
   * - CHECKOUT_UPDATED (async): A checkout was updated.
   */
  checkoutLinesDelete: Maybe<CheckoutLinesDelete>;
  /**
   * Updates checkout line in the existing checkout.
   *
   * Triggers the following webhook events:
   * - CHECKOUT_UPDATED (async): A checkout was updated.
   */
  checkoutLinesUpdate: Maybe<CheckoutLinesUpdate>;
  /** Creates a new payment for given checkout. */
  checkoutPaymentCreate: Maybe<CheckoutPaymentCreate>;
  /**
   * Remove a gift card or a voucher from a checkout.
   *
   * Triggers the following webhook events:
   * - CHECKOUT_UPDATED (async): A checkout was updated.
   */
  checkoutRemovePromoCode: Maybe<CheckoutRemovePromoCode>;
  /**
   * Updates shipping address in the existing checkout.
   *
   * Triggers the following webhook events:
   * - CHECKOUT_UPDATED (async): A checkout was updated.
   */
  checkoutShippingAddressUpdate: Maybe<CheckoutShippingAddressUpdate>;
  /**
   * Updates the shipping method of the checkout.
   *
   * Triggers the following webhook events:
   * - SHIPPING_LIST_METHODS_FOR_CHECKOUT (sync): Triggered when updating the checkout shipping method with the external one.
   * - CHECKOUT_UPDATED (async): A checkout was updated.
   * @deprecated Use `checkoutDeliveryMethodUpdate` instead.
   */
  checkoutShippingMethodUpdate: Maybe<CheckoutShippingMethodUpdate>;
  /**
   * Adds products to a collection.
   *
   * Requires one of the following permissions: MANAGE_PRODUCTS.
   */
  collectionAddProducts: Maybe<CollectionAddProducts>;
  /**
   * Deletes collections.
   *
   * Requires one of the following permissions: MANAGE_PRODUCTS.
   */
  collectionBulkDelete: Maybe<CollectionBulkDelete>;
  /**
   * Manage collection's availability in channels.
   *
   * Requires one of the following permissions: MANAGE_PRODUCTS.
   */
  collectionChannelListingUpdate: Maybe<CollectionChannelListingUpdate>;
  /**
   * Creates a new collection.
   *
   * Requires one of the following permissions: MANAGE_PRODUCTS.
   */
  collectionCreate: Maybe<CollectionCreate>;
  /**
   * Deletes a collection.
   *
   * Requires one of the following permissions: MANAGE_PRODUCTS.
   */
  collectionDelete: Maybe<CollectionDelete>;
  /**
   * Remove products from a collection.
   *
   * Requires one of the following permissions: MANAGE_PRODUCTS.
   */
  collectionRemoveProducts: Maybe<CollectionRemoveProducts>;
  /**
   * Reorder the products of a collection.
   *
   * Requires one of the following permissions: MANAGE_PRODUCTS.
   */
  collectionReorderProducts: Maybe<CollectionReorderProducts>;
  /**
   * Creates/updates translations for a collection.
   *
   * Requires one of the following permissions: MANAGE_TRANSLATIONS.
   */
  collectionTranslate: Maybe<CollectionTranslate>;
  /**
   * Updates a collection.
   *
   * Requires one of the following permissions: MANAGE_PRODUCTS.
   */
  collectionUpdate: Maybe<CollectionUpdate>;
  /**
   * Confirm user account with token sent by email during registration.
   *
   * Triggers the following webhook events:
   * - ACCOUNT_CONFIRMED (async): Account was confirmed.
   */
  confirmAccount: Maybe<ConfirmAccount>;
  /**
   * Confirm the email change of the logged-in user.
   *
   * Requires one of the following permissions: AUTHENTICATED_USER.
   *
   * Triggers the following webhook events:
   * - CUSTOMER_UPDATED (async): A customer account was updated.
   * - NOTIFY_USER (async): A notification that account email change was confirmed.
   * - ACCOUNT_EMAIL_CHANGED (async): An account email was changed.
   */
  confirmEmailChange: Maybe<ConfirmEmailChange>;
  /**
   * Creates a new warehouse.
   *
   * Requires one of the following permissions: MANAGE_PRODUCTS.
   */
  createWarehouse: Maybe<WarehouseCreate>;
  /**
   * Deletes customers.
   *
   * Requires one of the following permissions: MANAGE_USERS.
   *
   * Triggers the following webhook events:
   * - CUSTOMER_DELETED (async): A customer account was deleted.
   */
  customerBulkDelete: Maybe<CustomerBulkDelete>;
  /**
   * Updates customers.
   *
   * Requires one of the following permissions: MANAGE_USERS.
   *
   * Triggers the following webhook events:
   * - CUSTOMER_UPDATED (async): A customer account was updated.
   * - CUSTOMER_METADATA_UPDATED (async): Optionally called when customer's metadata was updated.
   */
  customerBulkUpdate: Maybe<CustomerBulkUpdate>;
  /**
   * Creates a new customer.
   *
   * Requires one of the following permissions: MANAGE_USERS.
   *
   * Triggers the following webhook events:
   * - CUSTOMER_CREATED (async): A new customer account was created.
   * - CUSTOMER_METADATA_UPDATED (async): Optionally called when customer's metadata was updated.
   * - NOTIFY_USER (async): A notification for setting the password.
   * - ACCOUNT_SET_PASSWORD_REQUESTED (async): Setting a new password for the account is requested.
   */
  customerCreate: Maybe<CustomerCreate>;
  /**
   * Deletes a customer.
   *
   * Requires one of the following permissions: MANAGE_USERS.
   *
   * Triggers the following webhook events:
   * - CUSTOMER_DELETED (async): A customer account was deleted.
   */
  customerDelete: Maybe<CustomerDelete>;
  /**
   * Updates an existing customer.
   *
   * Requires one of the following permissions: MANAGE_USERS.
   *
   * Triggers the following webhook events:
   * - CUSTOMER_UPDATED (async): A new customer account was updated.
   * - CUSTOMER_METADATA_UPDATED (async): Optionally called when customer's metadata was updated.
   */
  customerUpdate: Maybe<CustomerUpdate>;
  /** Delete metadata of an object. To use it, you need to have access to the modified object. */
  deleteMetadata: Maybe<DeleteMetadata>;
  /** Delete object's private metadata. To use it, you need to be an authenticated staff user or an app and have access to the modified object. */
  deletePrivateMetadata: Maybe<DeletePrivateMetadata>;
  /**
   * Deletes selected warehouse.
   *
   * Requires one of the following permissions: MANAGE_PRODUCTS.
   */
  deleteWarehouse: Maybe<WarehouseDelete>;
  /**
   * Create new digital content. This mutation must be sent as a `multipart` request. More detailed specs of the upload format can be found here: https://github.com/jaydenseric/graphql-multipart-request-spec
   *
   * Requires one of the following permissions: MANAGE_PRODUCTS.
   * @deprecated Support for Digital Content is deprecated and will be removed in Saleor v3.23.0. This functionality is legacy and undocumented, and is not part of the supported API. Users should not rely on this behavior.
   */
  digitalContentCreate: Maybe<DigitalContentCreate>;
  /**
   * Remove digital content assigned to given variant.
   *
   * Requires one of the following permissions: MANAGE_PRODUCTS.
   * @deprecated Support for Digital Content is deprecated and will be removed in Saleor v3.23.0. This functionality is legacy and undocumented, and is not part of the supported API. Users should not rely on this behavior.
   */
  digitalContentDelete: Maybe<DigitalContentDelete>;
  /**
   * Updates digital content.
   *
   * Requires one of the following permissions: MANAGE_PRODUCTS.
   * @deprecated Support for Digital Content is deprecated and will be removed in Saleor v3.23.0. This functionality is legacy and undocumented, and is not part of the supported API. Users should not rely on this behavior.
   */
  digitalContentUpdate: Maybe<DigitalContentUpdate>;
  /**
   * Generate new URL to digital content.
   *
   * Requires one of the following permissions: MANAGE_PRODUCTS.
   * @deprecated Support for Digital Content is deprecated and will be removed in Saleor v3.23.0. This functionality is legacy and undocumented, and is not part of the supported API. Users should not rely on this behavior.
   */
  digitalContentUrlCreate: Maybe<DigitalContentUrlCreate>;
  /**
   * Deletes draft orders.
   *
   * Requires one of the following permissions: MANAGE_ORDERS.
   */
  draftOrderBulkDelete: Maybe<DraftOrderBulkDelete>;
  /**
   * Completes creating an order.
   *
   * Requires one of the following permissions: MANAGE_ORDERS.
   */
  draftOrderComplete: Maybe<DraftOrderComplete>;
  /**
   * Creates a new draft order.
   *
   * Requires one of the following permissions: MANAGE_ORDERS.
   */
  draftOrderCreate: Maybe<DraftOrderCreate>;
  /**
   * Deletes a draft order.
   *
   * Requires one of the following permissions: MANAGE_ORDERS.
   */
  draftOrderDelete: Maybe<DraftOrderDelete>;
  /**
   * Deletes order lines.
   *
   * Requires one of the following permissions: MANAGE_ORDERS.
   * @deprecated Field no longer supported
   */
  draftOrderLinesBulkDelete: Maybe<DraftOrderLinesBulkDelete>;
  /**
   * Updates a draft order.
   *
   * Requires one of the following permissions: MANAGE_ORDERS.
   */
  draftOrderUpdate: Maybe<DraftOrderUpdate>;
  /**
   * Retries event delivery.
   *
   * Requires one of the following permissions: MANAGE_APPS.
   */
  eventDeliveryRetry: Maybe<EventDeliveryRetry>;
  /**
   * Export gift cards to csv file.
   *
   * Requires one of the following permissions: MANAGE_GIFT_CARD.
   *
   * Triggers the following webhook events:
   * - NOTIFY_USER (async): A notification for the exported file.
   * - GIFT_CARD_EXPORT_COMPLETED (async): A notification for the exported file.
   */
  exportGiftCards: Maybe<ExportGiftCards>;
  /**
   * Export products to csv file.
   *
   * Requires one of the following permissions: MANAGE_PRODUCTS.
   *
   * Triggers the following webhook events:
   * - NOTIFY_USER (async): A notification for the exported file.
   * - PRODUCT_EXPORT_COMPLETED (async): A notification for the exported file.
   */
  exportProducts: Maybe<ExportProducts>;
  /**
   * Export voucher codes to csv/xlsx file.
   *
   * Added in Saleor 3.18.
   *
   * Note: this API is currently in Feature Preview and can be subject to changes at later point.
   *
   * Requires one of the following permissions: MANAGE_DISCOUNTS.
   *
   * Triggers the following webhook events:
   * - VOUCHER_CODE_EXPORT_COMPLETED (async): A notification for the exported file.
   */
  exportVoucherCodes: Maybe<ExportVoucherCodes>;
  /** Prepare external authentication URL for user by custom plugin. */
  externalAuthenticationUrl: Maybe<ExternalAuthenticationUrl>;
  /** Logout user by custom plugin. */
  externalLogout: Maybe<ExternalLogout>;
  /**
   * Trigger sending a notification with the notify plugin method. Serializes nodes provided as ids parameter and includes this data in the notification payload.
   * @deprecated Field no longer supported
   */
  externalNotificationTrigger: Maybe<ExternalNotificationTrigger>;
  /** Obtain external access tokens for user by custom plugin. */
  externalObtainAccessTokens: Maybe<ExternalObtainAccessTokens>;
  /** Refresh user's access by custom plugin. */
  externalRefresh: Maybe<ExternalRefresh>;
  /** Verify external authentication data by plugin. */
  externalVerify: Maybe<ExternalVerify>;
  /**
   * Upload a file. This mutation must be sent as a `multipart` request. More detailed specs of the upload format can be found here: https://github.com/jaydenseric/graphql-multipart-request-spec
   *
   * Requires one of the following permissions: AUTHENTICATED_APP, AUTHENTICATED_STAFF_USER.
   */
  fileUpload: Maybe<FileUpload>;
  /**
   * Activate a gift card.
   *
   * Requires one of the following permissions: MANAGE_GIFT_CARD.
   *
   * Triggers the following webhook events:
   * - GIFT_CARD_STATUS_CHANGED (async): A gift card was activated.
   */
  giftCardActivate: Maybe<GiftCardActivate>;
  /**
   * Adds note to the gift card.
   *
   * Requires one of the following permissions: MANAGE_GIFT_CARD.
   *
   * Triggers the following webhook events:
   * - GIFT_CARD_UPDATED (async): A gift card was updated.
   */
  giftCardAddNote: Maybe<GiftCardAddNote>;
  /**
   * Activate gift cards.
   *
   * Requires one of the following permissions: MANAGE_GIFT_CARD.
   *
   * Triggers the following webhook events:
   * - GIFT_CARD_STATUS_CHANGED (async): A gift card was activated.
   */
  giftCardBulkActivate: Maybe<GiftCardBulkActivate>;
  /**
   * Creates gift cards.
   *
   * Requires one of the following permissions: MANAGE_GIFT_CARD.
   *
   * Triggers the following webhook events:
   * - GIFT_CARD_CREATED (async): A gift card was created.
   * - NOTIFY_USER (async): A notification for created gift card.
   */
  giftCardBulkCreate: Maybe<GiftCardBulkCreate>;
  /**
   * Deactivate gift cards.
   *
   * Requires one of the following permissions: MANAGE_GIFT_CARD.
   *
   * Triggers the following webhook events:
   * - GIFT_CARD_STATUS_CHANGED (async): A gift card was deactivated.
   */
  giftCardBulkDeactivate: Maybe<GiftCardBulkDeactivate>;
  /**
   * Deletes gift cards.
   *
   * Requires one of the following permissions: MANAGE_GIFT_CARD.
   *
   * Triggers the following webhook events:
   * - GIFT_CARD_DELETED (async): A gift card was deleted.
   */
  giftCardBulkDelete: Maybe<GiftCardBulkDelete>;
  /**
   * Creates a new gift card.
   *
   * Requires one of the following permissions: MANAGE_GIFT_CARD.
   *
   * Triggers the following webhook events:
   * - GIFT_CARD_CREATED (async): A gift card was created.
   * - NOTIFY_USER (async): A notification for created gift card.
   */
  giftCardCreate: Maybe<GiftCardCreate>;
  /**
   * Deactivate a gift card.
   *
   * Requires one of the following permissions: MANAGE_GIFT_CARD.
   *
   * Triggers the following webhook events:
   * - GIFT_CARD_STATUS_CHANGED (async): A gift card was deactivated.
   */
  giftCardDeactivate: Maybe<GiftCardDeactivate>;
  /**
   * Deletes gift card.
   *
   * Requires one of the following permissions: MANAGE_GIFT_CARD.
   *
   * Triggers the following webhook events:
   * - GIFT_CARD_DELETED (async): A gift card was deleted.
   */
  giftCardDelete: Maybe<GiftCardDelete>;
  /**
   * Resend a gift card.
   *
   * Requires one of the following permissions: MANAGE_GIFT_CARD.
   *
   * Triggers the following webhook events:
   * - NOTIFY_USER (async): A notification for gift card resend.
   */
  giftCardResend: Maybe<GiftCardResend>;
  /**
   * Update gift card settings.
   *
   * Requires one of the following permissions: MANAGE_GIFT_CARD.
   */
  giftCardSettingsUpdate: Maybe<GiftCardSettingsUpdate>;
  /**
   * Update a gift card.
   *
   * Requires one of the following permissions: MANAGE_GIFT_CARD.
   *
   * Triggers the following webhook events:
   * - GIFT_CARD_UPDATED (async): A gift card was updated.
   */
  giftCardUpdate: Maybe<GiftCardUpdate>;
  /**
   * Creates a ready to send invoice.
   *
   * Requires one of the following permissions: MANAGE_ORDERS.
   */
  invoiceCreate: Maybe<InvoiceCreate>;
  /**
   * Deletes an invoice.
   *
   * Requires one of the following permissions: MANAGE_ORDERS.
   */
  invoiceDelete: Maybe<InvoiceDelete>;
  /**
   * Request an invoice for the order using plugin.
   *
   * Requires one of the following permissions: MANAGE_ORDERS.
   *
   * Triggers the following webhook events:
   * - INVOICE_REQUESTED (async): An invoice was requested.
   */
  invoiceRequest: Maybe<InvoiceRequest>;
  /**
   * Requests deletion of an invoice.
   *
   * Requires one of the following permissions: MANAGE_ORDERS.
   *
   * Triggers the following webhook events:
   * - INVOICE_DELETED (async): An invoice was requested to delete.
   */
  invoiceRequestDelete: Maybe<InvoiceRequestDelete>;
  /**
   * Send an invoice notification to the customer.
   *
   * Requires one of the following permissions: MANAGE_ORDERS.
   *
   * Triggers the following webhook events:
   * - INVOICE_SENT (async): A notification for invoice send
   * - NOTIFY_USER (async): A notification for invoice send
   */
  invoiceSendNotification: Maybe<InvoiceSendNotification>;
  /**
   * Updates an invoice.
   *
   * Requires one of the following permissions: MANAGE_ORDERS.
   */
  invoiceUpdate: Maybe<InvoiceUpdate>;
  /**
   * Deletes menus.
   *
   * Requires one of the following permissions: MANAGE_MENUS.
   *
   * Triggers the following webhook events:
   * - MENU_DELETED (async): A menu was deleted.
   */
  menuBulkDelete: Maybe<MenuBulkDelete>;
  /**
   * Creates a new Menu.
   *
   * Requires one of the following permissions: MANAGE_MENUS.
   *
   * Triggers the following webhook events:
   * - MENU_CREATED (async): A menu was created.
   */
  menuCreate: Maybe<MenuCreate>;
  /**
   * Deletes a menu.
   *
   * Requires one of the following permissions: MANAGE_MENUS.
   *
   * Triggers the following webhook events:
   * - MENU_DELETED (async): A menu was deleted.
   */
  menuDelete: Maybe<MenuDelete>;
  /**
   * Deletes menu items.
   *
   * Requires one of the following permissions: MANAGE_MENUS.
   *
   * Triggers the following webhook events:
   * - MENU_ITEM_DELETED (async): A menu item was deleted.
   */
  menuItemBulkDelete: Maybe<MenuItemBulkDelete>;
  /**
   * Creates a new menu item.
   *
   * Requires one of the following permissions: MANAGE_MENUS.
   *
   * Triggers the following webhook events:
   * - MENU_ITEM_CREATED (async): A menu item was created.
   */
  menuItemCreate: Maybe<MenuItemCreate>;
  /**
   * Deletes a menu item.
   *
   * Requires one of the following permissions: MANAGE_MENUS.
   *
   * Triggers the following webhook events:
   * - MENU_ITEM_DELETED (async): A menu item was deleted.
   */
  menuItemDelete: Maybe<MenuItemDelete>;
  /**
   * Moves items of menus.
   *
   * Requires one of the following permissions: MANAGE_MENUS.
   *
   * Triggers the following webhook events:
   * - MENU_ITEM_UPDATED (async): Optionally triggered when sort order or parent changed for menu item.
   */
  menuItemMove: Maybe<MenuItemMove>;
  /**
   * Creates/updates translations for a menu item.
   *
   * Requires one of the following permissions: MANAGE_TRANSLATIONS.
   */
  menuItemTranslate: Maybe<MenuItemTranslate>;
  /**
   * Updates a menu item.
   *
   * Requires one of the following permissions: MANAGE_MENUS.
   *
   * Triggers the following webhook events:
   * - MENU_ITEM_UPDATED (async): A menu item was updated.
   */
  menuItemUpdate: Maybe<MenuItemUpdate>;
  /**
   * Updates a menu.
   *
   * Requires one of the following permissions: MANAGE_MENUS.
   *
   * Triggers the following webhook events:
   * - MENU_UPDATED (async): A menu was updated.
   */
  menuUpdate: Maybe<MenuUpdate>;
  /**
   * Adds note to the order.
   *
   * Requires one of the following permissions: MANAGE_ORDERS.
   * @deprecated Use `orderNoteAdd` instead.
   */
  orderAddNote: Maybe<OrderAddNote>;
  /**
   * Cancels orders.
   *
   * Requires one of the following permissions: MANAGE_ORDERS.
   */
  orderBulkCancel: Maybe<OrderBulkCancel>;
  /**
   * Creates multiple orders.
   *
   * Requires one of the following permissions: MANAGE_ORDERS_IMPORT.
   */
  orderBulkCreate: Maybe<OrderBulkCreate>;
  /**
   * Cancel an order.
   *
   * Requires one of the following permissions: MANAGE_ORDERS.
   */
  orderCancel: Maybe<OrderCancel>;
  /**
   * Capture an order.
   *
   * Requires one of the following permissions: MANAGE_ORDERS.
   */
  orderCapture: Maybe<OrderCapture>;
  /**
   * Confirms an unconfirmed order by changing status to unfulfilled.
   *
   * Requires one of the following permissions: MANAGE_ORDERS.
   */
  orderConfirm: Maybe<OrderConfirm>;
  /**
   * Create new order from existing checkout. Requires the following permissions: AUTHENTICATED_APP and HANDLE_CHECKOUTS.
   *
   * Triggers the following webhook events:
   * - SHIPPING_LIST_METHODS_FOR_CHECKOUT (sync): Optionally triggered when cached external shipping methods are invalid.
   * - CHECKOUT_FILTER_SHIPPING_METHODS (sync): Optionally triggered when cached filtered shipping methods are invalid.
   * - CHECKOUT_CALCULATE_TAXES (sync): Optionally triggered when checkout prices are expired.
   * - ORDER_CREATED (async): Triggered when order is created.
   * - NOTIFY_USER (async): A notification for order placement.
   * - NOTIFY_USER (async): A staff notification for order placement.
   * - ORDER_UPDATED (async): Triggered when order received the update after placement.
   * - ORDER_PAID (async): Triggered when newly created order is paid.
   * - ORDER_FULLY_PAID (async): Triggered when newly created order is fully paid.
   * - ORDER_CONFIRMED (async): Optionally triggered when newly created order are automatically marked as confirmed.
   */
  orderCreateFromCheckout: Maybe<OrderCreateFromCheckout>;
  /**
   * Adds discount to the order.
   *
   * Requires one of the following permissions: MANAGE_ORDERS.
   */
  orderDiscountAdd: Maybe<OrderDiscountAdd>;
  /**
   * Remove discount from the order.
   *
   * Requires one of the following permissions: MANAGE_ORDERS.
   */
  orderDiscountDelete: Maybe<OrderDiscountDelete>;
  /**
   * Update discount for the order.
   *
   * Requires one of the following permissions: MANAGE_ORDERS.
   */
  orderDiscountUpdate: Maybe<OrderDiscountUpdate>;
  /**
   * Creates new fulfillments for an order.
   *
   * Requires one of the following permissions: MANAGE_ORDERS.
   *
   * Triggers the following webhook events:
   * - FULFILLMENT_CREATED (async): A new fulfillment is created.
   * - ORDER_FULFILLED (async): Order is fulfilled.
   * - FULFILLMENT_TRACKING_NUMBER_UPDATED (async): Sent when fulfillment tracking number is updated.
   * - FULFILLMENT_APPROVED (async): A fulfillment is approved.
   */
  orderFulfill: Maybe<OrderFulfill>;
  /**
   * Approve existing fulfillment.
   *
   * Requires one of the following permissions: MANAGE_ORDERS.
   *
   * Triggers the following webhook events:
   * - FULFILLMENT_APPROVED (async): Fulfillment is approved.
   */
  orderFulfillmentApprove: Maybe<FulfillmentApprove>;
  /**
   * Cancels existing fulfillment and optionally restocks items.
   *
   * Requires one of the following permissions: MANAGE_ORDERS.
   */
  orderFulfillmentCancel: Maybe<FulfillmentCancel>;
  /**
   * Refund products.
   *
   * Requires one of the following permissions: MANAGE_ORDERS.
   */
  orderFulfillmentRefundProducts: Maybe<FulfillmentRefundProducts>;
  /**
   * Return products.
   *
   * Requires one of the following permissions: MANAGE_ORDERS.
   */
  orderFulfillmentReturnProducts: Maybe<FulfillmentReturnProducts>;
  /**
   * Updates a fulfillment for an order.
   *
   * Requires one of the following permissions: MANAGE_ORDERS.
   *
   * Triggers the following webhook events:
   * - FULFILLMENT_TRACKING_NUMBER_UPDATED (async): Fulfillment tracking number is updated.
   */
  orderFulfillmentUpdateTracking: Maybe<FulfillmentUpdateTracking>;
  /**
   * Adds granted refund to the order.
   *
   * Requires one of the following permissions: MANAGE_ORDERS.
   */
  orderGrantRefundCreate: Maybe<OrderGrantRefundCreate>;
  /**
   * Updates granted refund.
   *
   * Requires one of the following permissions: MANAGE_ORDERS.
   */
  orderGrantRefundUpdate: Maybe<OrderGrantRefundUpdate>;
  /**
   * Deletes an order line from an order.
   *
   * Requires one of the following permissions: MANAGE_ORDERS.
   */
  orderLineDelete: Maybe<OrderLineDelete>;
  /**
   * Remove discount applied to the order line.
   *
   * Requires one of the following permissions: MANAGE_ORDERS.
   */
  orderLineDiscountRemove: Maybe<OrderLineDiscountRemove>;
  /**
   * Update discount for the order line.
   *
   * Requires one of the following permissions: MANAGE_ORDERS.
   */
  orderLineDiscountUpdate: Maybe<OrderLineDiscountUpdate>;
  /**
   * Updates an order line of an order.
   *
   * Requires one of the following permissions: MANAGE_ORDERS.
   */
  orderLineUpdate: Maybe<OrderLineUpdate>;
  /**
   * Creates order lines for an order.
   *
   * Requires one of the following permissions: MANAGE_ORDERS.
   */
  orderLinesCreate: Maybe<OrderLinesCreate>;
  /**
   * Mark order as manually paid.
   *
   * Requires one of the following permissions: MANAGE_ORDERS.
   */
  orderMarkAsPaid: Maybe<OrderMarkAsPaid>;
  /**
   * Adds note to the order.
   *
   * Requires one of the following permissions: MANAGE_ORDERS.
   */
  orderNoteAdd: Maybe<OrderNoteAdd>;
  /**
   * Updates note of an order.
   *
   * Requires one of the following permissions: MANAGE_ORDERS.
   */
  orderNoteUpdate: Maybe<OrderNoteUpdate>;
  /**
   * Refund an order.
   *
   * Requires one of the following permissions: MANAGE_ORDERS.
   */
  orderRefund: Maybe<OrderRefund>;
  /**
   * Update shop order settings across all channels. Returns `orderSettings` for the first `channel` in alphabetical order.
   *
   * Requires one of the following permissions: MANAGE_ORDERS.
   * @deprecated Use `channelUpdate` mutation instead.
   */
  orderSettingsUpdate: Maybe<OrderSettingsUpdate>;
  /**
   * Updates an order.
   *
   * Requires one of the following permissions: MANAGE_ORDERS.
   */
  orderUpdate: Maybe<OrderUpdate>;
  /**
   * Updates a shipping method of the order. Requires shipping method ID to update, when null is passed then currently assigned shipping method is removed.
   *
   * Requires one of the following permissions: MANAGE_ORDERS.
   */
  orderUpdateShipping: Maybe<OrderUpdateShipping>;
  /**
   * Void an order.
   *
   * Requires one of the following permissions: MANAGE_ORDERS.
   */
  orderVoid: Maybe<OrderVoid>;
  /**
   * Assign attributes to a given page type.
   *
   * Requires one of the following permissions: MANAGE_PAGE_TYPES_AND_ATTRIBUTES.
   */
  pageAttributeAssign: Maybe<PageAttributeAssign>;
  /**
   * Unassign attributes from a given page type.
   *
   * Requires one of the following permissions: MANAGE_PAGE_TYPES_AND_ATTRIBUTES.
   */
  pageAttributeUnassign: Maybe<PageAttributeUnassign>;
  /**
   * Deletes pages.
   *
   * Requires one of the following permissions: MANAGE_PAGES.
   */
  pageBulkDelete: Maybe<PageBulkDelete>;
  /**
   * Publish pages.
   *
   * Requires one of the following permissions: MANAGE_PAGES.
   */
  pageBulkPublish: Maybe<PageBulkPublish>;
  /**
   * Creates a new page.
   *
   * Requires one of the following permissions: MANAGE_PAGES.
   */
  pageCreate: Maybe<PageCreate>;
  /**
   * Deletes a page.
   *
   * Requires one of the following permissions: MANAGE_PAGES.
   */
  pageDelete: Maybe<PageDelete>;
  /**
   * Reorder page attribute values.
   *
   * Requires one of the following permissions: MANAGE_PAGES.
   */
  pageReorderAttributeValues: Maybe<PageReorderAttributeValues>;
  /**
   * Creates/updates translations for a page.
   *
   * Requires one of the following permissions: MANAGE_TRANSLATIONS.
   */
  pageTranslate: Maybe<PageTranslate>;
  /**
   * Deletes page types.
   *
   * Requires one of the following permissions: MANAGE_PAGE_TYPES_AND_ATTRIBUTES.
   */
  pageTypeBulkDelete: Maybe<PageTypeBulkDelete>;
  /**
   * Creates a new page type.
   *
   * Requires one of the following permissions: MANAGE_PAGE_TYPES_AND_ATTRIBUTES.
   */
  pageTypeCreate: Maybe<PageTypeCreate>;
  /**
   * Deletes a page type.
   *
   * Requires one of the following permissions: MANAGE_PAGE_TYPES_AND_ATTRIBUTES.
   */
  pageTypeDelete: Maybe<PageTypeDelete>;
  /**
   * Reorder the attributes of a page type.
   *
   * Requires one of the following permissions: MANAGE_PAGE_TYPES_AND_ATTRIBUTES.
   */
  pageTypeReorderAttributes: Maybe<PageTypeReorderAttributes>;
  /**
   * Updates page type.
   *
   * Requires one of the following permissions: MANAGE_PAGE_TYPES_AND_ATTRIBUTES.
   */
  pageTypeUpdate: Maybe<PageTypeUpdate>;
  /**
   * Updates an existing page.
   *
   * Requires one of the following permissions: MANAGE_PAGES.
   */
  pageUpdate: Maybe<PageUpdate>;
  /**
   * Change the password of the logged in user.
   *
   * Requires one of the following permissions: AUTHENTICATED_USER.
   */
  passwordChange: Maybe<PasswordChange>;
  /**
   * Captures the authorized payment amount.
   *
   * Requires one of the following permissions: MANAGE_ORDERS.
   */
  paymentCapture: Maybe<PaymentCapture>;
  /** Check payment balance. */
  paymentCheckBalance: Maybe<PaymentCheckBalance>;
  /** Initializes a payment gateway session. It triggers the webhook `PAYMENT_GATEWAY_INITIALIZE_SESSION`, to the requested `paymentGateways`. If `paymentGateways` is not provided, the webhook will be send to all subscribed payment gateways. There is a limit of 100 transaction items per checkout / order. */
  paymentGatewayInitialize: Maybe<PaymentGatewayInitialize>;
  /**
   * Initializes payment gateway for tokenizing payment method session.
   *
   * Requires one of the following permissions: AUTHENTICATED_USER.
   *
   * Triggers the following webhook events:
   * - PAYMENT_GATEWAY_INITIALIZE_TOKENIZATION_SESSION (sync): The customer requested to initialize payment gateway for tokenization.
   */
  paymentGatewayInitializeTokenization: Maybe<PaymentGatewayInitializeTokenization>;
  /** Initializes payment process when it is required by gateway. */
  paymentInitialize: Maybe<PaymentInitialize>;
  /**
   * Tokenize payment method.
   *
   * Requires one of the following permissions: AUTHENTICATED_USER.
   *
   * Triggers the following webhook events:
   * - PAYMENT_METHOD_INITIALIZE_TOKENIZATION_SESSION (sync): The customer requested to tokenize payment method.
   */
  paymentMethodInitializeTokenization: Maybe<PaymentMethodInitializeTokenization>;
  /**
   * Tokenize payment method.
   *
   * Requires one of the following permissions: AUTHENTICATED_USER.
   *
   * Triggers the following webhook events:
   * - PAYMENT_METHOD_PROCESS_TOKENIZATION_SESSION (sync): The customer continues payment method tokenization.
   */
  paymentMethodProcessTokenization: Maybe<PaymentMethodProcessTokenization>;
  /**
   * Refunds the captured payment amount.
   *
   * Requires one of the following permissions: MANAGE_ORDERS.
   */
  paymentRefund: Maybe<PaymentRefund>;
  /**
   * Voids the authorized payment.
   *
   * Requires one of the following permissions: MANAGE_ORDERS.
   */
  paymentVoid: Maybe<PaymentVoid>;
  /**
   * Create new permission group. Apps are not allowed to perform this mutation.
   *
   * Requires one of the following permissions: MANAGE_STAFF.
   *
   * Triggers the following webhook events:
   * - PERMISSION_GROUP_CREATED (async)
   */
  permissionGroupCreate: Maybe<PermissionGroupCreate>;
  /**
   * Delete permission group. Apps are not allowed to perform this mutation.
   *
   * Requires one of the following permissions: MANAGE_STAFF.
   *
   * Triggers the following webhook events:
   * - PERMISSION_GROUP_DELETED (async)
   */
  permissionGroupDelete: Maybe<PermissionGroupDelete>;
  /**
   * Update permission group. Apps are not allowed to perform this mutation.
   *
   * Requires one of the following permissions: MANAGE_STAFF.
   *
   * Triggers the following webhook events:
   * - PERMISSION_GROUP_UPDATED (async)
   */
  permissionGroupUpdate: Maybe<PermissionGroupUpdate>;
  /**
   * Update plugin configuration.
   *
   * Requires one of the following permissions: MANAGE_PLUGINS.
   */
  pluginUpdate: Maybe<PluginUpdate>;
  /**
   * Assign attributes to a given product type.
   *
   * Requires one of the following permissions: MANAGE_PRODUCT_TYPES_AND_ATTRIBUTES.
   */
  productAttributeAssign: Maybe<ProductAttributeAssign>;
  /**
   * Update attributes assigned to product variant for given product type.
   *
   * Requires one of the following permissions: MANAGE_PRODUCT_TYPES_AND_ATTRIBUTES.
   */
  productAttributeAssignmentUpdate: Maybe<ProductAttributeAssignmentUpdate>;
  /**
   * Un-assign attributes from a given product type.
   *
   * Requires one of the following permissions: MANAGE_PRODUCT_TYPES_AND_ATTRIBUTES.
   */
  productAttributeUnassign: Maybe<ProductAttributeUnassign>;
  /**
   * Creates products.
   *
   * Requires one of the following permissions: MANAGE_PRODUCTS.
   */
  productBulkCreate: Maybe<ProductBulkCreate>;
  /**
   * Deletes products.
   *
   * Requires one of the following permissions: MANAGE_PRODUCTS.
   */
  productBulkDelete: Maybe<ProductBulkDelete>;
  /**
   * Creates/updates translations for products.
   *
   * Requires one of the following permissions: MANAGE_TRANSLATIONS.
   *
   * Triggers the following webhook events:
   * - TRANSLATION_CREATED (async): Called when a translation was created.
   * - TRANSLATION_UPDATED (async): Called when a translation was updated.
   */
  productBulkTranslate: Maybe<ProductBulkTranslate>;
  /**
   * Manage product's availability in channels.
   *
   * Requires one of the following permissions: MANAGE_PRODUCTS.
   */
  productChannelListingUpdate: Maybe<ProductChannelListingUpdate>;
  /**
   * Creates a new product.
   *
   * Requires one of the following permissions: MANAGE_PRODUCTS.
   */
  productCreate: Maybe<ProductCreate>;
  /**
   * Deletes a product.
   *
   * Requires one of the following permissions: MANAGE_PRODUCTS.
   */
  productDelete: Maybe<ProductDelete>;
  /**
   * Deletes product media.
   *
   * Requires one of the following permissions: MANAGE_PRODUCTS.
   */
  productMediaBulkDelete: Maybe<ProductMediaBulkDelete>;
  /**
   * Create a media object (image or video URL) associated with product. For image, this mutation must be sent as a `multipart` request. More detailed specs of the upload format can be found here: https://github.com/jaydenseric/graphql-multipart-request-spec
   *
   * Requires one of the following permissions: MANAGE_PRODUCTS.
   */
  productMediaCreate: Maybe<ProductMediaCreate>;
  /**
   * Deletes a product media.
   *
   * Requires one of the following permissions: MANAGE_PRODUCTS.
   */
  productMediaDelete: Maybe<ProductMediaDelete>;
  /**
   * Changes ordering of the product media.
   *
   * Requires one of the following permissions: MANAGE_PRODUCTS.
   */
  productMediaReorder: Maybe<ProductMediaReorder>;
  /**
   * Updates a product media.
   *
   * Requires one of the following permissions: MANAGE_PRODUCTS.
   */
  productMediaUpdate: Maybe<ProductMediaUpdate>;
  /**
   * Reorder product attribute values.
   *
   * Requires one of the following permissions: MANAGE_PRODUCTS.
   */
  productReorderAttributeValues: Maybe<ProductReorderAttributeValues>;
  /**
   * Creates/updates translations for a product.
   *
   * Requires one of the following permissions: MANAGE_TRANSLATIONS.
   */
  productTranslate: Maybe<ProductTranslate>;
  /**
   * Deletes product types.
   *
   * Requires one of the following permissions: MANAGE_PRODUCT_TYPES_AND_ATTRIBUTES.
   */
  productTypeBulkDelete: Maybe<ProductTypeBulkDelete>;
  /**
   * Creates a new product type.
   *
   * Requires one of the following permissions: MANAGE_PRODUCT_TYPES_AND_ATTRIBUTES.
   */
  productTypeCreate: Maybe<ProductTypeCreate>;
  /**
   * Deletes a product type.
   *
   * Requires one of the following permissions: MANAGE_PRODUCT_TYPES_AND_ATTRIBUTES.
   */
  productTypeDelete: Maybe<ProductTypeDelete>;
  /**
   * Reorder the attributes of a product type.
   *
   * Requires one of the following permissions: MANAGE_PRODUCT_TYPES_AND_ATTRIBUTES.
   */
  productTypeReorderAttributes: Maybe<ProductTypeReorderAttributes>;
  /**
   * Updates an existing product type.
   *
   * Requires one of the following permissions: MANAGE_PRODUCT_TYPES_AND_ATTRIBUTES.
   */
  productTypeUpdate: Maybe<ProductTypeUpdate>;
  /**
   * Updates an existing product.
   *
   * Requires one of the following permissions: MANAGE_PRODUCTS.
   */
  productUpdate: Maybe<ProductUpdate>;
  /**
   * Creates product variants for a given product.
   *
   * Requires one of the following permissions: MANAGE_PRODUCTS.
   */
  productVariantBulkCreate: Maybe<ProductVariantBulkCreate>;
  /**
   * Deletes product variants.
   *
   * Requires one of the following permissions: MANAGE_PRODUCTS.
   */
  productVariantBulkDelete: Maybe<ProductVariantBulkDelete>;
  /**
   * Creates/updates translations for product variants.
   *
   * Requires one of the following permissions: MANAGE_TRANSLATIONS.
   *
   * Triggers the following webhook events:
   * - TRANSLATION_CREATED (async): A translation was created.
   * - TRANSLATION_UPDATED (async): A translation was updated.
   */
  productVariantBulkTranslate: Maybe<ProductVariantBulkTranslate>;
  /**
   * Updates multiple product variants.
   *
   * Requires one of the following permissions: MANAGE_PRODUCTS.
   */
  productVariantBulkUpdate: Maybe<ProductVariantBulkUpdate>;
  /**
   * Manage product variant prices in channels.
   *
   * Requires one of the following permissions: MANAGE_PRODUCTS.
   */
  productVariantChannelListingUpdate: Maybe<ProductVariantChannelListingUpdate>;
  /**
   * Creates a new variant for a product.
   *
   * Requires one of the following permissions: MANAGE_PRODUCTS.
   */
  productVariantCreate: Maybe<ProductVariantCreate>;
  /**
   * Deletes a product variant.
   *
   * Requires one of the following permissions: MANAGE_PRODUCTS.
   */
  productVariantDelete: Maybe<ProductVariantDelete>;
  /**
   * Deactivates product variant preorder. It changes all preorder allocation into regular allocation.
   *
   * Requires one of the following permissions: MANAGE_PRODUCTS.
   */
  productVariantPreorderDeactivate: Maybe<ProductVariantPreorderDeactivate>;
  /**
   * Reorder the variants of a product. Mutation updates updated_at on product and triggers PRODUCT_UPDATED webhook.
   *
   * Requires one of the following permissions: MANAGE_PRODUCTS.
   */
  productVariantReorder: Maybe<ProductVariantReorder>;
  /**
   * Reorder product variant attribute values.
   *
   * Requires one of the following permissions: MANAGE_PRODUCTS.
   */
  productVariantReorderAttributeValues: Maybe<ProductVariantReorderAttributeValues>;
  /**
   * Set default variant for a product. Mutation triggers PRODUCT_UPDATED webhook.
   *
   * Requires one of the following permissions: MANAGE_PRODUCTS.
   */
  productVariantSetDefault: Maybe<ProductVariantSetDefault>;
  /**
   * Creates stocks for product variant.
   *
   * Requires one of the following permissions: MANAGE_PRODUCTS.
   */
  productVariantStocksCreate: Maybe<ProductVariantStocksCreate>;
  /**
   * Deletes stocks from product variant.
   *
   * Requires one of the following permissions: MANAGE_PRODUCTS.
   */
  productVariantStocksDelete: Maybe<ProductVariantStocksDelete>;
  /**
   * Updates stocks for product variant.
   *
   * Requires one of the following permissions: MANAGE_PRODUCTS.
   */
  productVariantStocksUpdate: Maybe<ProductVariantStocksUpdate>;
  /**
   * Creates/updates translations for a product variant.
   *
   * Requires one of the following permissions: MANAGE_TRANSLATIONS.
   */
  productVariantTranslate: Maybe<ProductVariantTranslate>;
  /**
   * Updates an existing variant for product.
   *
   * Requires one of the following permissions: MANAGE_PRODUCTS.
   */
  productVariantUpdate: Maybe<ProductVariantUpdate>;
  /**
   * Deletes promotions.
   *
   * Requires one of the following permissions: MANAGE_DISCOUNTS.
   *
   * Triggers the following webhook events:
   * - PROMOTION_DELETED (async): A promotion was deleted.
   */
  promotionBulkDelete: Maybe<PromotionBulkDelete>;
  /**
   * Creates a new promotion.
   *
   * Requires one of the following permissions: MANAGE_DISCOUNTS.
   *
   * Triggers the following webhook events:
   * - PROMOTION_CREATED (async): A promotion was created.
   * - PROMOTION_STARTED (async): Optionally called if promotion was started.
   */
  promotionCreate: Maybe<PromotionCreate>;
  /**
   * Deletes a promotion.
   *
   * Requires one of the following permissions: MANAGE_DISCOUNTS.
   *
   * Triggers the following webhook events:
   * - PROMOTION_DELETED (async): A promotion was deleted.
   */
  promotionDelete: Maybe<PromotionDelete>;
  /**
   * Creates a new promotion rule.
   *
   * Requires one of the following permissions: MANAGE_DISCOUNTS.
   *
   * Triggers the following webhook events:
   * - PROMOTION_RULE_CREATED (async): A promotion rule was created.
   */
  promotionRuleCreate: Maybe<PromotionRuleCreate>;
  /**
   * Deletes a promotion rule.
   *
   * Requires one of the following permissions: MANAGE_DISCOUNTS.
   *
   * Triggers the following webhook events:
   * - PROMOTION_RULE_DELETED (async): A promotion rule was deleted.
   */
  promotionRuleDelete: Maybe<PromotionRuleDelete>;
  /**
   * Creates/updates translations for a promotion rule.
   *
   * Requires one of the following permissions: MANAGE_TRANSLATIONS.
   */
  promotionRuleTranslate: Maybe<PromotionRuleTranslate>;
  /**
   * Updates an existing promotion rule.
   *
   * Requires one of the following permissions: MANAGE_DISCOUNTS.
   *
   * Triggers the following webhook events:
   * - PROMOTION_RULE_UPDATED (async): A promotion rule was updated.
   */
  promotionRuleUpdate: Maybe<PromotionRuleUpdate>;
  /**
   * Creates/updates translations for a promotion.
   *
   * Requires one of the following permissions: MANAGE_TRANSLATIONS.
   */
  promotionTranslate: Maybe<PromotionTranslate>;
  /**
   * Updates an existing promotion.
   *
   * Requires one of the following permissions: MANAGE_DISCOUNTS.
   *
   * Triggers the following webhook events:
   * - PROMOTION_UPDATED (async): A promotion was updated.
   * - PROMOTION_STARTED (async): Optionally called if promotion was started.
   * - PROMOTION_ENDED (async): Optionally called if promotion was ended.
   */
  promotionUpdate: Maybe<PromotionUpdate>;
  /**
   * Updates RefundSettings. The `Page` (Model) Type will be cleared from `reasonReferenceType`. When it's cleared, passing reason reference to refund mutations is no longer accepted and will raise error.
   *
   * Added in Saleor 3.22.
   *
   * Requires one of the following permissions: MANAGE_SETTINGS.
   */
  refundReasonReferenceClear: Maybe<RefundReasonReferenceTypeClear>;
  /**
   * Update refund settings across all channels.
   *
   * Added in Saleor 3.22.
   *
   * Requires one of the following permissions: MANAGE_SETTINGS.
   */
  refundSettingsUpdate: Maybe<RefundSettingsUpdate>;
  /**
   * Request email change of the logged in user.
   *
   * Requires one of the following permissions: AUTHENTICATED_USER.
   *
   * Triggers the following webhook events:
   * - NOTIFY_USER (async): A notification for account email change.
   * - ACCOUNT_CHANGE_EMAIL_REQUESTED (async): An account email change was requested.
   */
  requestEmailChange: Maybe<RequestEmailChange>;
  /**
   * Sends an email with the account password modification link.
   *
   * Triggers the following webhook events:
   * - NOTIFY_USER (async): A notification for password reset.
   * - ACCOUNT_SET_PASSWORD_REQUESTED (async): Setting a new password for the account is requested.
   * - STAFF_SET_PASSWORD_REQUESTED (async): Setting a new password for the staff account is requested.
   */
  requestPasswordReset: Maybe<RequestPasswordReset>;
  /**
   * Deletes sales.
   *
   * Requires one of the following permissions: MANAGE_DISCOUNTS.
   *
   * Triggers the following webhook events:
   * - SALE_DELETED (async): A sale was deleted.
   */
  saleBulkDelete: Maybe<SaleBulkDelete>;
  /**
   * Adds products, categories, collections to a sale.
   *
   * Requires one of the following permissions: MANAGE_DISCOUNTS.
   *
   * Triggers the following webhook events:
   * - SALE_UPDATED (async): A sale was updated.
   * @deprecated Use `promotionRuleCreate` and `promotionRuleUpdate` mutations instead.
   */
  saleCataloguesAdd: Maybe<SaleAddCatalogues>;
  /**
   * Removes products, categories, collections from a sale.
   *
   * Requires one of the following permissions: MANAGE_DISCOUNTS.
   *
   * Triggers the following webhook events:
   * - SALE_UPDATED (async): A sale was updated.
   * @deprecated Use `promotionRuleUpdate` and `promotionRuleDelete` mutations instead.
   */
  saleCataloguesRemove: Maybe<SaleRemoveCatalogues>;
  /**
   * Manage sale's availability in channels.
   *
   * Requires one of the following permissions: MANAGE_DISCOUNTS.
   * @deprecated Use `promotionRuleUpdate` mutation instead.
   */
  saleChannelListingUpdate: Maybe<SaleChannelListingUpdate>;
  /**
   * Creates a new sale.
   *
   * Requires one of the following permissions: MANAGE_DISCOUNTS.
   *
   * Triggers the following webhook events:
   * - SALE_CREATED (async): A sale was created.
   * @deprecated Use `promotionCreate` mutation instead.
   */
  saleCreate: Maybe<SaleCreate>;
  /**
   * Deletes a sale.
   *
   * Requires one of the following permissions: MANAGE_DISCOUNTS.
   *
   * Triggers the following webhook events:
   * - SALE_DELETED (async): A sale was deleted.
   * @deprecated Use `promotionDelete` mutation instead.
   */
  saleDelete: Maybe<SaleDelete>;
  /**
   * Creates/updates translations for a sale.
   *
   * Requires one of the following permissions: MANAGE_TRANSLATIONS.
   * @deprecated Use `promotionTranslate` mutation instead.
   */
  saleTranslate: Maybe<SaleTranslate>;
  /**
   * Updates a sale.
   *
   * Requires one of the following permissions: MANAGE_DISCOUNTS.
   *
   * Triggers the following webhook events:
   * - SALE_UPDATED (async): A sale was updated.
   * - SALE_TOGGLE (async): Optionally triggered when a sale is started or stopped.
   * @deprecated Use `promotionUpdate` mutation instead.
   */
  saleUpdate: Maybe<SaleUpdate>;
  /**
   * Sends a notification confirmation.
   *
   * Requires one of the following permissions: AUTHENTICATED_USER.
   *
   * Triggers the following webhook events:
   * - NOTIFY_USER (async): A notification for account confirmation.
   * - ACCOUNT_CONFIRMATION_REQUESTED (async): An account confirmation was requested. This event is always sent regardless of settings.
   */
  sendConfirmationEmail: Maybe<SendConfirmationEmail>;
  /** Sets the user's password from the token sent by email using the RequestPasswordReset mutation. */
  setPassword: Maybe<SetPassword>;
  /**
   * Manage shipping method's availability in channels.
   *
   * Requires one of the following permissions: MANAGE_SHIPPING.
   */
  shippingMethodChannelListingUpdate: Maybe<ShippingMethodChannelListingUpdate>;
  /**
   * Deletes shipping prices.
   *
   * Requires one of the following permissions: MANAGE_SHIPPING.
   */
  shippingPriceBulkDelete: Maybe<ShippingPriceBulkDelete>;
  /**
   * Creates a new shipping price.
   *
   * Requires one of the following permissions: MANAGE_SHIPPING.
   */
  shippingPriceCreate: Maybe<ShippingPriceCreate>;
  /**
   * Deletes a shipping price.
   *
   * Requires one of the following permissions: MANAGE_SHIPPING.
   */
  shippingPriceDelete: Maybe<ShippingPriceDelete>;
  /**
   * Exclude products from shipping price.
   *
   * Requires one of the following permissions: MANAGE_SHIPPING.
   */
  shippingPriceExcludeProducts: Maybe<ShippingPriceExcludeProducts>;
  /**
   * Remove product from excluded list for shipping price.
   *
   * Requires one of the following permissions: MANAGE_SHIPPING.
   */
  shippingPriceRemoveProductFromExclude: Maybe<ShippingPriceRemoveProductFromExclude>;
  /**
   * Creates/updates translations for a shipping method.
   *
   * Requires one of the following permissions: MANAGE_TRANSLATIONS.
   */
  shippingPriceTranslate: Maybe<ShippingPriceTranslate>;
  /**
   * Updates a new shipping price.
   *
   * Requires one of the following permissions: MANAGE_SHIPPING.
   */
  shippingPriceUpdate: Maybe<ShippingPriceUpdate>;
  /**
   * Deletes shipping zones.
   *
   * Requires one of the following permissions: MANAGE_SHIPPING.
   */
  shippingZoneBulkDelete: Maybe<ShippingZoneBulkDelete>;
  /**
   * Creates a new shipping zone.
   *
   * Requires one of the following permissions: MANAGE_SHIPPING.
   */
  shippingZoneCreate: Maybe<ShippingZoneCreate>;
  /**
   * Deletes a shipping zone.
   *
   * Requires one of the following permissions: MANAGE_SHIPPING.
   */
  shippingZoneDelete: Maybe<ShippingZoneDelete>;
  /**
   * Updates a new shipping zone.
   *
   * Requires one of the following permissions: MANAGE_SHIPPING.
   */
  shippingZoneUpdate: Maybe<ShippingZoneUpdate>;
  /**
   * Update the shop's address. If the `null` value is passed, the currently selected address will be deleted.
   *
   * Requires one of the following permissions: MANAGE_SETTINGS.
   */
  shopAddressUpdate: Maybe<ShopAddressUpdate>;
  /**
   * Updates site domain of the shop.
   *
   * Requires one of the following permissions: MANAGE_SETTINGS.
   * @deprecated Use `PUBLIC_URL` environment variable instead.
   */
  shopDomainUpdate: Maybe<ShopDomainUpdate>;
  /**
   * Fetch tax rates.
   *
   * Requires one of the following permissions: MANAGE_SETTINGS.
   * @deprecated Field no longer supported
   */
  shopFetchTaxRates: Maybe<ShopFetchTaxRates>;
  /**
   * Creates/updates translations for shop settings.
   *
   * Requires one of the following permissions: MANAGE_TRANSLATIONS.
   */
  shopSettingsTranslate: Maybe<ShopSettingsTranslate>;
  /**
   * Updates shop settings.
   *
   * Requires one of the following permissions: MANAGE_SETTINGS.
   *
   * Triggers the following webhook events:
   * - SHOP_METADATA_UPDATED (async): Optionally triggered when public or private metadata is updated.
   */
  shopSettingsUpdate: Maybe<ShopSettingsUpdate>;
  /**
   * Deletes staff users. Apps are not allowed to perform this mutation.
   *
   * Requires one of the following permissions: MANAGE_STAFF.
   *
   * Triggers the following webhook events:
   * - STAFF_DELETED (async): A staff account was deleted.
   */
  staffBulkDelete: Maybe<StaffBulkDelete>;
  /**
   * Creates a new staff user. Apps are not allowed to perform this mutation.
   *
   * Requires one of the following permissions: MANAGE_STAFF.
   *
   * Triggers the following webhook events:
   * - STAFF_CREATED (async): A new staff account was created.
   * - NOTIFY_USER (async): A notification for setting the password.
   * - STAFF_SET_PASSWORD_REQUESTED (async): Setting a new password for the staff account is requested.
   */
  staffCreate: Maybe<StaffCreate>;
  /**
   * Deletes a staff user. Apps are not allowed to perform this mutation.
   *
   * Requires one of the following permissions: MANAGE_STAFF.
   *
   * Triggers the following webhook events:
   * - STAFF_DELETED (async): A staff account was deleted.
   */
  staffDelete: Maybe<StaffDelete>;
  /**
   * Creates a new staff notification recipient.
   *
   * Requires one of the following permissions: MANAGE_SETTINGS.
   */
  staffNotificationRecipientCreate: Maybe<StaffNotificationRecipientCreate>;
  /**
   * Deletes staff notification recipient.
   *
   * Requires one of the following permissions: MANAGE_SETTINGS.
   */
  staffNotificationRecipientDelete: Maybe<StaffNotificationRecipientDelete>;
  /**
   * Updates a staff notification recipient.
   *
   * Requires one of the following permissions: MANAGE_SETTINGS.
   */
  staffNotificationRecipientUpdate: Maybe<StaffNotificationRecipientUpdate>;
  /**
   * Updates an existing staff user. Apps are not allowed to perform this mutation.
   *
   * Requires one of the following permissions: MANAGE_STAFF.
   *
   * Triggers the following webhook events:
   * - STAFF_UPDATED (async): A staff account was updated.
   */
  staffUpdate: Maybe<StaffUpdate>;
  /**
   * Updates stocks for a given variant and warehouse. Variant and warehouse selectors have to be the same for all stock inputs. Is not allowed to use 'variantId' in one input and 'variantExternalReference' in another.
   *
   * Requires one of the following permissions: MANAGE_PRODUCTS.
   *
   * Triggers the following webhook events:
   * - PRODUCT_VARIANT_STOCK_UPDATED (async): A product variant stock details were updated.
   */
  stockBulkUpdate: Maybe<StockBulkUpdate>;
  /**
   * Request to delete a stored payment method on payment provider side.
   *
   * Requires one of the following permissions: AUTHENTICATED_USER.
   *
   * Triggers the following webhook events:
   * - STORED_PAYMENT_METHOD_DELETE_REQUESTED (sync): The customer requested to delete a payment method.
   */
  storedPaymentMethodRequestDelete: Maybe<StoredPaymentMethodRequestDelete>;
  /**
   * Creates a tax class.
   *
   * Requires one of the following permissions: MANAGE_TAXES.
   */
  taxClassCreate: Maybe<TaxClassCreate>;
  /**
   * Deletes a tax class. After deleting the tax class any products, product types or shipping methods using it are updated to use the default tax class.
   *
   * Requires one of the following permissions: MANAGE_TAXES.
   */
  taxClassDelete: Maybe<TaxClassDelete>;
  /**
   * Updates a tax class.
   *
   * Requires one of the following permissions: MANAGE_TAXES.
   */
  taxClassUpdate: Maybe<TaxClassUpdate>;
  /**
   * Updates tax configuration for a channel.
   *
   * Requires one of the following permissions: MANAGE_TAXES.
   */
  taxConfigurationUpdate: Maybe<TaxConfigurationUpdate>;
  /**
   * Remove all tax class rates for a specific country.
   *
   * Requires one of the following permissions: MANAGE_TAXES.
   */
  taxCountryConfigurationDelete: Maybe<TaxCountryConfigurationDelete>;
  /**
   * Updates tax class rates for a specific country.
   *
   * Requires one of the following permissions: MANAGE_TAXES.
   */
  taxCountryConfigurationUpdate: Maybe<TaxCountryConfigurationUpdate>;
  /**
   * Exempt checkout or order from charging the taxes. When tax exemption is enabled, taxes won't be charged for the checkout or order. Taxes may still be calculated in cases when product prices are entered with the tax included and the net price needs to be known.
   *
   * Requires one of the following permissions: MANAGE_TAXES.
   */
  taxExemptionManage: Maybe<TaxExemptionManage>;
  /** Create JWT token. */
  tokenCreate: Maybe<CreateToken>;
  /** Refresh JWT token. Mutation tries to take refreshToken from the input. If it fails it will try to take `refreshToken` from the http-only cookie `refreshToken`. `csrfToken` is required when `refreshToken` is provided as a cookie. */
  tokenRefresh: Maybe<RefreshToken>;
  /** Verify JWT token. */
  tokenVerify: Maybe<VerifyToken>;
  /**
   * Deactivate all JWT tokens of the currently authenticated user.
   *
   * Requires one of the following permissions: AUTHENTICATED_USER.
   */
  tokensDeactivateAll: Maybe<DeactivateAllUserTokens>;
  /**
   * Creates transaction for checkout or order.
   *
   * Requires one of the following permissions: HANDLE_PAYMENTS.
   */
  transactionCreate: Maybe<TransactionCreate>;
  /**
   * Report the event for the transaction.
   *
   * Requires the following permissions: OWNER and HANDLE_PAYMENTS for apps, HANDLE_PAYMENTS for staff users. Staff user cannot update a transaction that is owned by the app.
   *
   * Triggers the following webhook events:
   * - TRANSACTION_ITEM_METADATA_UPDATED (async): Optionally called when transaction's metadata was updated.
   * - CHECKOUT_FULLY_PAID (async): Optionally called when the checkout charge status changed to `FULL` or `OVERCHARGED`.
   * - ORDER_UPDATED (async): Optionally called when the transaction is related to the order and the order was updated.
   */
  transactionEventReport: Maybe<TransactionEventReport>;
  /** Initializes a transaction session. It triggers the webhook `TRANSACTION_INITIALIZE_SESSION`, to the requested `paymentGateways`. There is a limit of 100 transaction items per checkout / order. */
  transactionInitialize: Maybe<TransactionInitialize>;
  /** Processes a transaction session. It triggers the webhook `TRANSACTION_PROCESS_SESSION`, to the assigned `paymentGateways`. */
  transactionProcess: Maybe<TransactionProcess>;
  /**
   * Request an action for payment transaction.
   *
   * Requires one of the following permissions: HANDLE_PAYMENTS.
   */
  transactionRequestAction: Maybe<TransactionRequestAction>;
  /**
   * Request a refund for payment transaction based on granted refund.
   *
   * Requires one of the following permissions: HANDLE_PAYMENTS.
   */
  transactionRequestRefundForGrantedRefund: Maybe<TransactionRequestRefundForGrantedRefund>;
  /**
   * Update transaction.
   *
   * Requires the following permissions: OWNER and HANDLE_PAYMENTS for apps, HANDLE_PAYMENTS for staff users. Staff user cannot update a transaction that is owned by the app.
   */
  transactionUpdate: Maybe<TransactionUpdate>;
  /**
   * Remove shipping zone from given warehouse.
   *
   * Requires one of the following permissions: MANAGE_PRODUCTS.
   */
  unassignWarehouseShippingZone: Maybe<WarehouseShippingZoneUnassign>;
  /**
   * Updates metadata of an object.Requires permissions to modify and to read the metadata of the object it's attached to.
   *
   * Warning: never store sensitive information, including financial data such as credit card details.
   */
  updateMetadata: Maybe<UpdateMetadata>;
  /**
   * Updates private metadata of an object. Requires permissions to modify and to read the metadata of the object it's attached to.
   *
   * Warning: never store sensitive information, including financial data such as credit card details.
   */
  updatePrivateMetadata: Maybe<UpdatePrivateMetadata>;
  /**
   * Updates given warehouse.
   *
   * Requires one of the following permissions: MANAGE_PRODUCTS.
   */
  updateWarehouse: Maybe<WarehouseUpdate>;
  /**
   * Deletes a user avatar. Only for staff members.
   *
   * Requires one of the following permissions: AUTHENTICATED_STAFF_USER.
   */
  userAvatarDelete: Maybe<UserAvatarDelete>;
  /**
   * Create a user avatar. Only for staff members. This mutation must be sent as a `multipart` request. More detailed specs of the upload format can be found here: https://github.com/jaydenseric/graphql-multipart-request-spec
   *
   * Requires one of the following permissions: AUTHENTICATED_STAFF_USER.
   */
  userAvatarUpdate: Maybe<UserAvatarUpdate>;
  /**
   * Activate or deactivate users.
   *
   * Requires one of the following permissions: MANAGE_USERS.
   */
  userBulkSetActive: Maybe<UserBulkSetActive>;
  /**
   * Assign an media to a product variant.
   *
   * Requires one of the following permissions: MANAGE_PRODUCTS.
   */
  variantMediaAssign: Maybe<VariantMediaAssign>;
  /**
   * Unassign an media from a product variant.
   *
   * Requires one of the following permissions: MANAGE_PRODUCTS.
   */
  variantMediaUnassign: Maybe<VariantMediaUnassign>;
  /**
   * Deletes vouchers.
   *
   * Requires one of the following permissions: MANAGE_DISCOUNTS.
   *
   * Triggers the following webhook events:
   * - VOUCHER_DELETED (async): A voucher was deleted.
   */
  voucherBulkDelete: Maybe<VoucherBulkDelete>;
  /**
   * Adds products, categories, collections to a voucher.
   *
   * Requires one of the following permissions: MANAGE_DISCOUNTS.
   *
   * Triggers the following webhook events:
   * - VOUCHER_UPDATED (async): A voucher was updated.
   */
  voucherCataloguesAdd: Maybe<VoucherAddCatalogues>;
  /**
   * Removes products, categories, collections from a voucher.
   *
   * Requires one of the following permissions: MANAGE_DISCOUNTS.
   *
   * Triggers the following webhook events:
   * - VOUCHER_UPDATED (async): A voucher was updated.
   */
  voucherCataloguesRemove: Maybe<VoucherRemoveCatalogues>;
  /**
   * Manage voucher's availability in channels.
   *
   * Requires one of the following permissions: MANAGE_DISCOUNTS.
   *
   * Triggers the following webhook events:
   * - VOUCHER_UPDATED (async): A voucher was updated.
   */
  voucherChannelListingUpdate: Maybe<VoucherChannelListingUpdate>;
  /**
   * Deletes voucher codes.
   *
   * Added in Saleor 3.18.
   *
   * Requires one of the following permissions: MANAGE_DISCOUNTS.
   *
   * Triggers the following webhook events:
   * - VOUCHER_CODES_DELETED (async): A voucher codes were deleted.
   */
  voucherCodeBulkDelete: Maybe<VoucherCodeBulkDelete>;
  /**
   * Creates a new voucher.
   *
   * Requires one of the following permissions: MANAGE_DISCOUNTS.
   *
   * Triggers the following webhook events:
   * - VOUCHER_CREATED (async): A voucher was created.
   * - VOUCHER_CODES_CREATED (async): A voucher codes were created.
   */
  voucherCreate: Maybe<VoucherCreate>;
  /**
   * Deletes a voucher.
   *
   * Requires one of the following permissions: MANAGE_DISCOUNTS.
   *
   * Triggers the following webhook events:
   * - VOUCHER_DELETED (async): A voucher was deleted.
   */
  voucherDelete: Maybe<VoucherDelete>;
  /**
   * Creates/updates translations for a voucher.
   *
   * Requires one of the following permissions: MANAGE_TRANSLATIONS.
   */
  voucherTranslate: Maybe<VoucherTranslate>;
  /**
   * Updates a voucher.
   *
   * Requires one of the following permissions: MANAGE_DISCOUNTS.
   *
   * Triggers the following webhook events:
   * - VOUCHER_UPDATED (async): A voucher was updated.
   * - VOUCHER_CODES_CREATED (async): A voucher code was created.
   */
  voucherUpdate: Maybe<VoucherUpdate>;
  /**
   * Creates a new webhook subscription.
   *
   * Requires one of the following permissions: MANAGE_APPS, AUTHENTICATED_APP.
   */
  webhookCreate: Maybe<WebhookCreate>;
  /**
   * Deletes a webhook. Before the deletion, the webhook is deactivated to pause any deliveries that are already scheduled. The deletion might fail if delivery is in progress. In such a case, the webhook is not deleted but remains deactivated.
   *
   * Requires one of the following permissions: MANAGE_APPS, AUTHENTICATED_APP.
   */
  webhookDelete: Maybe<WebhookDelete>;
  /**
   * Performs a dry run of a webhook event. Supports a single event (the first, if multiple provided in the `query`). Requires permission relevant to processed event.
   *
   * Requires one of the following permissions: AUTHENTICATED_STAFF_USER.
   */
  webhookDryRun: Maybe<WebhookDryRun>;
  /**
   * Trigger a webhook event. Supports a single event (the first, if multiple provided in the `webhook.subscription_query`). Requires permission relevant to processed event. Successfully delivered webhook returns `delivery` with status='PENDING' and empty payload.
   *
   * Requires one of the following permissions: AUTHENTICATED_STAFF_USER.
   */
  webhookTrigger: Maybe<WebhookTrigger>;
  /**
   * Updates a webhook subscription.
   *
   * Requires one of the following permissions: MANAGE_APPS, AUTHENTICATED_APP.
   */
  webhookUpdate: Maybe<WebhookUpdate>;
};


export type MutationAccountAddressCreateArgs = {
  customerId: InputMaybe<Scalars['ID']>;
  input: AddressInput;
  type: InputMaybe<AddressTypeEnum>;
};


export type MutationAccountAddressDeleteArgs = {
  id: Scalars['ID'];
};


export type MutationAccountAddressUpdateArgs = {
  id: Scalars['ID'];
  input: AddressInput;
};


export type MutationAccountDeleteArgs = {
  token: Scalars['String'];
};


export type MutationAccountRegisterArgs = {
  input: AccountRegisterInput;
};


export type MutationAccountRequestDeletionArgs = {
  channel: InputMaybe<Scalars['String']>;
  redirectUrl: Scalars['String'];
};


export type MutationAccountSetDefaultAddressArgs = {
  id: Scalars['ID'];
  type: AddressTypeEnum;
};


export type MutationAccountUpdateArgs = {
  customerId: InputMaybe<Scalars['ID']>;
  input: AccountInput;
};


export type MutationAddressCreateArgs = {
  input: AddressInput;
  userId: Scalars['ID'];
};


export type MutationAddressDeleteArgs = {
  id: Scalars['ID'];
};


export type MutationAddressSetDefaultArgs = {
  addressId: Scalars['ID'];
  type: AddressTypeEnum;
  userId: Scalars['ID'];
};


export type MutationAddressUpdateArgs = {
  id: Scalars['ID'];
  input: AddressInput;
};


export type MutationAppActivateArgs = {
  id: Scalars['ID'];
};


export type MutationAppCreateArgs = {
  input: AppInput;
};


export type MutationAppDeactivateArgs = {
  id: Scalars['ID'];
};


export type MutationAppDeleteArgs = {
  id: Scalars['ID'];
};


export type MutationAppDeleteFailedInstallationArgs = {
  id: Scalars['ID'];
};


export type MutationAppFetchManifestArgs = {
  manifestUrl: Scalars['String'];
};


export type MutationAppInstallArgs = {
  input: AppInstallInput;
};


export type MutationAppProblemCreateArgs = {
  input: AppProblemCreateInput;
};


export type MutationAppProblemDismissArgs = {
  input: AppProblemDismissInput;
};


export type MutationAppReenableSyncWebhooksArgs = {
  appId: Scalars['ID'];
};


export type MutationAppRetryInstallArgs = {
  activateAfterInstallation?: InputMaybe<Scalars['Boolean']>;
  id: Scalars['ID'];
};


export type MutationAppTokenCreateArgs = {
  input: AppTokenInput;
};


export type MutationAppTokenDeleteArgs = {
  id: Scalars['ID'];
};


export type MutationAppTokenVerifyArgs = {
  token: Scalars['String'];
};


export type MutationAppUpdateArgs = {
  id: Scalars['ID'];
  input: AppInput;
};


export type MutationAssignNavigationArgs = {
  menu: InputMaybe<Scalars['ID']>;
  navigationType: NavigationType;
};


export type MutationAssignWarehouseShippingZoneArgs = {
  id: Scalars['ID'];
  shippingZoneIds: Array<Scalars['ID']>;
};


export type MutationAttributeBulkCreateArgs = {
  attributes: Array<AttributeCreateInput>;
  errorPolicy: InputMaybe<ErrorPolicyEnum>;
};


export type MutationAttributeBulkDeleteArgs = {
  ids: Array<Scalars['ID']>;
};


export type MutationAttributeBulkTranslateArgs = {
  errorPolicy: InputMaybe<ErrorPolicyEnum>;
  translations: Array<AttributeBulkTranslateInput>;
};


export type MutationAttributeBulkUpdateArgs = {
  attributes: Array<AttributeBulkUpdateInput>;
  errorPolicy: InputMaybe<ErrorPolicyEnum>;
};


export type MutationAttributeCreateArgs = {
  input: AttributeCreateInput;
};


export type MutationAttributeDeleteArgs = {
  externalReference: InputMaybe<Scalars['String']>;
  id: InputMaybe<Scalars['ID']>;
};


export type MutationAttributeReorderValuesArgs = {
  attributeId: Scalars['ID'];
  moves: Array<ReorderInput>;
};


export type MutationAttributeTranslateArgs = {
  id: Scalars['ID'];
  input: NameTranslationInput;
  languageCode: LanguageCodeEnum;
};


export type MutationAttributeUpdateArgs = {
  externalReference: InputMaybe<Scalars['String']>;
  id: InputMaybe<Scalars['ID']>;
  input: AttributeUpdateInput;
};


export type MutationAttributeValueBulkDeleteArgs = {
  ids: Array<Scalars['ID']>;
};


export type MutationAttributeValueBulkTranslateArgs = {
  errorPolicy: InputMaybe<ErrorPolicyEnum>;
  translations: Array<AttributeValueBulkTranslateInput>;
};


export type MutationAttributeValueCreateArgs = {
  attribute: Scalars['ID'];
  input: AttributeValueCreateInput;
};


export type MutationAttributeValueDeleteArgs = {
  externalReference: InputMaybe<Scalars['String']>;
  id: InputMaybe<Scalars['ID']>;
};


export type MutationAttributeValueTranslateArgs = {
  id: Scalars['ID'];
  input: AttributeValueTranslationInput;
  languageCode: LanguageCodeEnum;
};


export type MutationAttributeValueUpdateArgs = {
  externalReference: InputMaybe<Scalars['String']>;
  id: InputMaybe<Scalars['ID']>;
  input: AttributeValueUpdateInput;
};


export type MutationCategoryBulkDeleteArgs = {
  ids: Array<Scalars['ID']>;
};


export type MutationCategoryCreateArgs = {
  input: CategoryInput;
  parent: InputMaybe<Scalars['ID']>;
};


export type MutationCategoryDeleteArgs = {
  id: Scalars['ID'];
};


export type MutationCategoryTranslateArgs = {
  id: Scalars['ID'];
  input: TranslationInput;
  languageCode: LanguageCodeEnum;
};


export type MutationCategoryUpdateArgs = {
  id: Scalars['ID'];
  input: CategoryInput;
};


export type MutationChannelActivateArgs = {
  id: Scalars['ID'];
};


export type MutationChannelCreateArgs = {
  input: ChannelCreateInput;
};


export type MutationChannelDeactivateArgs = {
  id: Scalars['ID'];
};


export type MutationChannelDeleteArgs = {
  id: Scalars['ID'];
  input: InputMaybe<ChannelDeleteInput>;
};


export type MutationChannelReorderWarehousesArgs = {
  channelId: Scalars['ID'];
  moves: Array<ReorderInput>;
};


export type MutationChannelUpdateArgs = {
  id: Scalars['ID'];
  input: ChannelUpdateInput;
};


export type MutationCheckoutAddPromoCodeArgs = {
  checkoutId: InputMaybe<Scalars['ID']>;
  id: InputMaybe<Scalars['ID']>;
  promoCode: Scalars['String'];
  token: InputMaybe<Scalars['UUID']>;
};


export type MutationCheckoutBillingAddressUpdateArgs = {
  billingAddress: AddressInput;
  checkoutId: InputMaybe<Scalars['ID']>;
  id: InputMaybe<Scalars['ID']>;
  saveAddress?: InputMaybe<Scalars['Boolean']>;
  token: InputMaybe<Scalars['UUID']>;
  validationRules: InputMaybe<CheckoutAddressValidationRules>;
};


export type MutationCheckoutCompleteArgs = {
  checkoutId: InputMaybe<Scalars['ID']>;
  id: InputMaybe<Scalars['ID']>;
  metadata: InputMaybe<Array<MetadataInput>>;
  paymentData: InputMaybe<Scalars['JSONString']>;
  redirectUrl: InputMaybe<Scalars['String']>;
  storeSource?: InputMaybe<Scalars['Boolean']>;
  token: InputMaybe<Scalars['UUID']>;
};


export type MutationCheckoutCreateArgs = {
  input: CheckoutCreateInput;
};


export type MutationCheckoutCreateFromOrderArgs = {
  id: Scalars['ID'];
};


export type MutationCheckoutCustomerAttachArgs = {
  checkoutId: InputMaybe<Scalars['ID']>;
  customerId: InputMaybe<Scalars['ID']>;
  id: InputMaybe<Scalars['ID']>;
  token: InputMaybe<Scalars['UUID']>;
};


export type MutationCheckoutCustomerDetachArgs = {
  checkoutId: InputMaybe<Scalars['ID']>;
  id: InputMaybe<Scalars['ID']>;
  token: InputMaybe<Scalars['UUID']>;
};


export type MutationCheckoutCustomerNoteUpdateArgs = {
  customerNote: Scalars['String'];
  id: Scalars['ID'];
};


export type MutationCheckoutDeliveryMethodUpdateArgs = {
  deliveryMethodId: InputMaybe<Scalars['ID']>;
  id: InputMaybe<Scalars['ID']>;
  token: InputMaybe<Scalars['UUID']>;
};


export type MutationCheckoutEmailUpdateArgs = {
  checkoutId: InputMaybe<Scalars['ID']>;
  email: Scalars['String'];
  id: InputMaybe<Scalars['ID']>;
  token: InputMaybe<Scalars['UUID']>;
};


export type MutationCheckoutLanguageCodeUpdateArgs = {
  checkoutId: InputMaybe<Scalars['ID']>;
  id: InputMaybe<Scalars['ID']>;
  languageCode: LanguageCodeEnum;
  token: InputMaybe<Scalars['UUID']>;
};


export type MutationCheckoutLineDeleteArgs = {
  checkoutId: InputMaybe<Scalars['ID']>;
  id: InputMaybe<Scalars['ID']>;
  lineId: InputMaybe<Scalars['ID']>;
  token: InputMaybe<Scalars['UUID']>;
};


export type MutationCheckoutLinesAddArgs = {
  checkoutId: InputMaybe<Scalars['ID']>;
  id: InputMaybe<Scalars['ID']>;
  lines: Array<CheckoutLineInput>;
  token: InputMaybe<Scalars['UUID']>;
};


export type MutationCheckoutLinesDeleteArgs = {
  id: InputMaybe<Scalars['ID']>;
  linesIds: Array<Scalars['ID']>;
  token: InputMaybe<Scalars['UUID']>;
};


export type MutationCheckoutLinesUpdateArgs = {
  checkoutId: InputMaybe<Scalars['ID']>;
  id: InputMaybe<Scalars['ID']>;
  lines: Array<CheckoutLineUpdateInput>;
  token: InputMaybe<Scalars['UUID']>;
};


export type MutationCheckoutPaymentCreateArgs = {
  checkoutId: InputMaybe<Scalars['ID']>;
  id: InputMaybe<Scalars['ID']>;
  input: PaymentInput;
  token: InputMaybe<Scalars['UUID']>;
};


export type MutationCheckoutRemovePromoCodeArgs = {
  checkoutId: InputMaybe<Scalars['ID']>;
  id: InputMaybe<Scalars['ID']>;
  promoCode: InputMaybe<Scalars['String']>;
  promoCodeId: InputMaybe<Scalars['ID']>;
  token: InputMaybe<Scalars['UUID']>;
};


export type MutationCheckoutShippingAddressUpdateArgs = {
  checkoutId: InputMaybe<Scalars['ID']>;
  id: InputMaybe<Scalars['ID']>;
  saveAddress?: InputMaybe<Scalars['Boolean']>;
  shippingAddress: AddressInput;
  token: InputMaybe<Scalars['UUID']>;
  validationRules: InputMaybe<CheckoutAddressValidationRules>;
};


export type MutationCheckoutShippingMethodUpdateArgs = {
  checkoutId: InputMaybe<Scalars['ID']>;
  id: InputMaybe<Scalars['ID']>;
  shippingMethodId: InputMaybe<Scalars['ID']>;
  token: InputMaybe<Scalars['UUID']>;
};


export type MutationCollectionAddProductsArgs = {
  collectionId: Scalars['ID'];
  products: Array<Scalars['ID']>;
};


export type MutationCollectionBulkDeleteArgs = {
  ids: Array<Scalars['ID']>;
};


export type MutationCollectionChannelListingUpdateArgs = {
  id: Scalars['ID'];
  input: CollectionChannelListingUpdateInput;
};


export type MutationCollectionCreateArgs = {
  input: CollectionCreateInput;
};


export type MutationCollectionDeleteArgs = {
  id: Scalars['ID'];
};


export type MutationCollectionRemoveProductsArgs = {
  collectionId: Scalars['ID'];
  products: Array<Scalars['ID']>;
};


export type MutationCollectionReorderProductsArgs = {
  collectionId: Scalars['ID'];
  moves: Array<MoveProductInput>;
};


export type MutationCollectionTranslateArgs = {
  id: Scalars['ID'];
  input: TranslationInput;
  languageCode: LanguageCodeEnum;
};


export type MutationCollectionUpdateArgs = {
  id: Scalars['ID'];
  input: CollectionInput;
};


export type MutationConfirmAccountArgs = {
  email: Scalars['String'];
  token: Scalars['String'];
};


export type MutationConfirmEmailChangeArgs = {
  channel: InputMaybe<Scalars['String']>;
  token: Scalars['String'];
};


export type MutationCreateWarehouseArgs = {
  input: WarehouseCreateInput;
};


export type MutationCustomerBulkDeleteArgs = {
  ids: Array<Scalars['ID']>;
};


export type MutationCustomerBulkUpdateArgs = {
  customers: Array<CustomerBulkUpdateInput>;
  errorPolicy: InputMaybe<ErrorPolicyEnum>;
};


export type MutationCustomerCreateArgs = {
  input: UserCreateInput;
};


export type MutationCustomerDeleteArgs = {
  externalReference: InputMaybe<Scalars['String']>;
  id: InputMaybe<Scalars['ID']>;
};


export type MutationCustomerUpdateArgs = {
  externalReference: InputMaybe<Scalars['String']>;
  id: InputMaybe<Scalars['ID']>;
  input: CustomerInput;
};


export type MutationDeleteMetadataArgs = {
  id: Scalars['ID'];
  keys: Array<Scalars['String']>;
};


export type MutationDeletePrivateMetadataArgs = {
  id: Scalars['ID'];
  keys: Array<Scalars['String']>;
};


export type MutationDeleteWarehouseArgs = {
  id: Scalars['ID'];
};


export type MutationDigitalContentCreateArgs = {
  input: DigitalContentUploadInput;
  variantId: Scalars['ID'];
};


export type MutationDigitalContentDeleteArgs = {
  variantId: Scalars['ID'];
};


export type MutationDigitalContentUpdateArgs = {
  input: DigitalContentInput;
  variantId: Scalars['ID'];
};


export type MutationDigitalContentUrlCreateArgs = {
  input: DigitalContentUrlCreateInput;
};


export type MutationDraftOrderBulkDeleteArgs = {
  ids: Array<Scalars['ID']>;
};


export type MutationDraftOrderCompleteArgs = {
  id: Scalars['ID'];
};


export type MutationDraftOrderCreateArgs = {
  input: DraftOrderCreateInput;
};


export type MutationDraftOrderDeleteArgs = {
  externalReference: InputMaybe<Scalars['String']>;
  id: InputMaybe<Scalars['ID']>;
};


export type MutationDraftOrderLinesBulkDeleteArgs = {
  ids: Array<Scalars['ID']>;
};


export type MutationDraftOrderUpdateArgs = {
  externalReference: InputMaybe<Scalars['String']>;
  id: InputMaybe<Scalars['ID']>;
  input: DraftOrderInput;
};


export type MutationEventDeliveryRetryArgs = {
  id: Scalars['ID'];
};


export type MutationExportGiftCardsArgs = {
  input: ExportGiftCardsInput;
};


export type MutationExportProductsArgs = {
  input: ExportProductsInput;
};


export type MutationExportVoucherCodesArgs = {
  input: ExportVoucherCodesInput;
};


export type MutationExternalAuthenticationUrlArgs = {
  input: Scalars['JSONString'];
  pluginId: Scalars['String'];
};


export type MutationExternalLogoutArgs = {
  input: Scalars['JSONString'];
  pluginId: Scalars['String'];
};


export type MutationExternalNotificationTriggerArgs = {
  channel: Scalars['String'];
  input: ExternalNotificationTriggerInput;
  pluginId: InputMaybe<Scalars['String']>;
};


export type MutationExternalObtainAccessTokensArgs = {
  input: Scalars['JSONString'];
  pluginId: Scalars['String'];
};


export type MutationExternalRefreshArgs = {
  input: Scalars['JSONString'];
  pluginId: Scalars['String'];
};


export type MutationExternalVerifyArgs = {
  input: Scalars['JSONString'];
  pluginId: Scalars['String'];
};


export type MutationFileUploadArgs = {
  file: Scalars['Upload'];
};


export type MutationGiftCardActivateArgs = {
  id: Scalars['ID'];
};


export type MutationGiftCardAddNoteArgs = {
  id: Scalars['ID'];
  input: GiftCardAddNoteInput;
};


export type MutationGiftCardBulkActivateArgs = {
  ids: Array<Scalars['ID']>;
};


export type MutationGiftCardBulkCreateArgs = {
  input: GiftCardBulkCreateInput;
};


export type MutationGiftCardBulkDeactivateArgs = {
  ids: Array<Scalars['ID']>;
};


export type MutationGiftCardBulkDeleteArgs = {
  ids: Array<Scalars['ID']>;
};


export type MutationGiftCardCreateArgs = {
  input: GiftCardCreateInput;
};


export type MutationGiftCardDeactivateArgs = {
  id: Scalars['ID'];
};


export type MutationGiftCardDeleteArgs = {
  id: Scalars['ID'];
};


export type MutationGiftCardResendArgs = {
  input: GiftCardResendInput;
};


export type MutationGiftCardSettingsUpdateArgs = {
  input: GiftCardSettingsUpdateInput;
};


export type MutationGiftCardUpdateArgs = {
  id: Scalars['ID'];
  input: GiftCardUpdateInput;
};


export type MutationInvoiceCreateArgs = {
  input: InvoiceCreateInput;
  orderId: Scalars['ID'];
};


export type MutationInvoiceDeleteArgs = {
  id: Scalars['ID'];
};


export type MutationInvoiceRequestArgs = {
  number: InputMaybe<Scalars['String']>;
  orderId: Scalars['ID'];
};


export type MutationInvoiceRequestDeleteArgs = {
  id: Scalars['ID'];
};


export type MutationInvoiceSendNotificationArgs = {
  id: Scalars['ID'];
};


export type MutationInvoiceUpdateArgs = {
  id: Scalars['ID'];
  input: UpdateInvoiceInput;
};


export type MutationMenuBulkDeleteArgs = {
  ids: Array<Scalars['ID']>;
};


export type MutationMenuCreateArgs = {
  input: MenuCreateInput;
};


export type MutationMenuDeleteArgs = {
  id: Scalars['ID'];
};


export type MutationMenuItemBulkDeleteArgs = {
  ids: Array<Scalars['ID']>;
};


export type MutationMenuItemCreateArgs = {
  input: MenuItemCreateInput;
};


export type MutationMenuItemDeleteArgs = {
  id: Scalars['ID'];
};


export type MutationMenuItemMoveArgs = {
  menu: Scalars['ID'];
  moves: Array<MenuItemMoveInput>;
};


export type MutationMenuItemTranslateArgs = {
  id: Scalars['ID'];
  input: NameTranslationInput;
  languageCode: LanguageCodeEnum;
};


export type MutationMenuItemUpdateArgs = {
  id: Scalars['ID'];
  input: MenuItemInput;
};


export type MutationMenuUpdateArgs = {
  id: Scalars['ID'];
  input: MenuInput;
};


export type MutationOrderAddNoteArgs = {
  input: OrderAddNoteInput;
  order: Scalars['ID'];
};


export type MutationOrderBulkCancelArgs = {
  ids: Array<Scalars['ID']>;
};


export type MutationOrderBulkCreateArgs = {
  errorPolicy: InputMaybe<ErrorPolicyEnum>;
  orders: Array<OrderBulkCreateInput>;
  stockUpdatePolicy: InputMaybe<StockUpdatePolicyEnum>;
};


export type MutationOrderCancelArgs = {
  id: Scalars['ID'];
};


export type MutationOrderCaptureArgs = {
  amount: Scalars['PositiveDecimal'];
  id: Scalars['ID'];
};


export type MutationOrderConfirmArgs = {
  id: Scalars['ID'];
};


export type MutationOrderCreateFromCheckoutArgs = {
  id: Scalars['ID'];
  metadata: InputMaybe<Array<MetadataInput>>;
  privateMetadata: InputMaybe<Array<MetadataInput>>;
  removeCheckout?: InputMaybe<Scalars['Boolean']>;
};


export type MutationOrderDiscountAddArgs = {
  input: OrderDiscountCommonInput;
  orderId: Scalars['ID'];
};


export type MutationOrderDiscountDeleteArgs = {
  discountId: Scalars['ID'];
};


export type MutationOrderDiscountUpdateArgs = {
  discountId: Scalars['ID'];
  input: OrderDiscountCommonInput;
};


export type MutationOrderFulfillArgs = {
  input: OrderFulfillInput;
  order: InputMaybe<Scalars['ID']>;
};


export type MutationOrderFulfillmentApproveArgs = {
  allowStockToBeExceeded?: InputMaybe<Scalars['Boolean']>;
  id: Scalars['ID'];
  notifyCustomer: Scalars['Boolean'];
};


export type MutationOrderFulfillmentCancelArgs = {
  id: Scalars['ID'];
  input: InputMaybe<FulfillmentCancelInput>;
};


export type MutationOrderFulfillmentRefundProductsArgs = {
  input: OrderRefundProductsInput;
  order: Scalars['ID'];
};


export type MutationOrderFulfillmentReturnProductsArgs = {
  input: OrderReturnProductsInput;
  order: Scalars['ID'];
};


export type MutationOrderFulfillmentUpdateTrackingArgs = {
  id: Scalars['ID'];
  input: FulfillmentUpdateTrackingInput;
};


export type MutationOrderGrantRefundCreateArgs = {
  id: Scalars['ID'];
  input: OrderGrantRefundCreateInput;
};


export type MutationOrderGrantRefundUpdateArgs = {
  id: Scalars['ID'];
  input: OrderGrantRefundUpdateInput;
};


export type MutationOrderLineDeleteArgs = {
  id: Scalars['ID'];
};


export type MutationOrderLineDiscountRemoveArgs = {
  orderLineId: Scalars['ID'];
};


export type MutationOrderLineDiscountUpdateArgs = {
  input: OrderDiscountCommonInput;
  orderLineId: Scalars['ID'];
};


export type MutationOrderLineUpdateArgs = {
  id: Scalars['ID'];
  input: OrderLineInput;
};


export type MutationOrderLinesCreateArgs = {
  id: Scalars['ID'];
  input: Array<OrderLineCreateInput>;
};


export type MutationOrderMarkAsPaidArgs = {
  id: Scalars['ID'];
  transactionReference: InputMaybe<Scalars['String']>;
};


export type MutationOrderNoteAddArgs = {
  input: OrderNoteInput;
  order: Scalars['ID'];
};


export type MutationOrderNoteUpdateArgs = {
  input: OrderNoteInput;
  note: Scalars['ID'];
};


export type MutationOrderRefundArgs = {
  amount: Scalars['PositiveDecimal'];
  id: Scalars['ID'];
};


export type MutationOrderSettingsUpdateArgs = {
  input: OrderSettingsUpdateInput;
};


export type MutationOrderUpdateArgs = {
  externalReference: InputMaybe<Scalars['String']>;
  id: InputMaybe<Scalars['ID']>;
  input: OrderUpdateInput;
};


export type MutationOrderUpdateShippingArgs = {
  input: OrderUpdateShippingInput;
  order: Scalars['ID'];
};


export type MutationOrderVoidArgs = {
  id: Scalars['ID'];
};


export type MutationPageAttributeAssignArgs = {
  attributeIds: Array<Scalars['ID']>;
  pageTypeId: Scalars['ID'];
};


export type MutationPageAttributeUnassignArgs = {
  attributeIds: Array<Scalars['ID']>;
  pageTypeId: Scalars['ID'];
};


export type MutationPageBulkDeleteArgs = {
  ids: Array<Scalars['ID']>;
};


export type MutationPageBulkPublishArgs = {
  ids: Array<Scalars['ID']>;
  isPublished: Scalars['Boolean'];
};


export type MutationPageCreateArgs = {
  input: PageCreateInput;
};


export type MutationPageDeleteArgs = {
  id: Scalars['ID'];
};


export type MutationPageReorderAttributeValuesArgs = {
  attributeId: Scalars['ID'];
  moves: Array<ReorderInput>;
  pageId: Scalars['ID'];
};


export type MutationPageTranslateArgs = {
  id: Scalars['ID'];
  input: PageTranslationInput;
  languageCode: LanguageCodeEnum;
};


export type MutationPageTypeBulkDeleteArgs = {
  ids: Array<Scalars['ID']>;
};


export type MutationPageTypeCreateArgs = {
  input: PageTypeCreateInput;
};


export type MutationPageTypeDeleteArgs = {
  id: Scalars['ID'];
};


export type MutationPageTypeReorderAttributesArgs = {
  moves: Array<ReorderInput>;
  pageTypeId: Scalars['ID'];
};


export type MutationPageTypeUpdateArgs = {
  id: InputMaybe<Scalars['ID']>;
  input: PageTypeUpdateInput;
};


export type MutationPageUpdateArgs = {
  id: Scalars['ID'];
  input: PageInput;
};


export type MutationPasswordChangeArgs = {
  newPassword: Scalars['String'];
  oldPassword: InputMaybe<Scalars['String']>;
};


export type MutationPaymentCaptureArgs = {
  amount: InputMaybe<Scalars['PositiveDecimal']>;
  paymentId: Scalars['ID'];
};


export type MutationPaymentCheckBalanceArgs = {
  input: PaymentCheckBalanceInput;
};


export type MutationPaymentGatewayInitializeArgs = {
  amount: InputMaybe<Scalars['PositiveDecimal']>;
  id: Scalars['ID'];
  paymentGateways: InputMaybe<Array<PaymentGatewayToInitialize>>;
};


export type MutationPaymentGatewayInitializeTokenizationArgs = {
  channel: Scalars['String'];
  data: InputMaybe<Scalars['JSON']>;
  id: Scalars['String'];
};


export type MutationPaymentInitializeArgs = {
  channel: InputMaybe<Scalars['String']>;
  gateway: Scalars['String'];
  paymentData: InputMaybe<Scalars['JSONString']>;
};


export type MutationPaymentMethodInitializeTokenizationArgs = {
  channel: Scalars['String'];
  data: InputMaybe<Scalars['JSON']>;
  id: Scalars['String'];
  paymentFlowToSupport: TokenizedPaymentFlowEnum;
};


export type MutationPaymentMethodProcessTokenizationArgs = {
  channel: Scalars['String'];
  data: InputMaybe<Scalars['JSON']>;
  id: Scalars['String'];
};


export type MutationPaymentRefundArgs = {
  amount: InputMaybe<Scalars['PositiveDecimal']>;
  paymentId: Scalars['ID'];
};


export type MutationPaymentVoidArgs = {
  paymentId: Scalars['ID'];
};


export type MutationPermissionGroupCreateArgs = {
  input: PermissionGroupCreateInput;
};


export type MutationPermissionGroupDeleteArgs = {
  id: Scalars['ID'];
};


export type MutationPermissionGroupUpdateArgs = {
  id: Scalars['ID'];
  input: PermissionGroupUpdateInput;
};


export type MutationPluginUpdateArgs = {
  channelId: InputMaybe<Scalars['ID']>;
  id: Scalars['ID'];
  input: PluginUpdateInput;
};


export type MutationProductAttributeAssignArgs = {
  operations: Array<ProductAttributeAssignInput>;
  productTypeId: Scalars['ID'];
};


export type MutationProductAttributeAssignmentUpdateArgs = {
  operations: Array<ProductAttributeAssignmentUpdateInput>;
  productTypeId: Scalars['ID'];
};


export type MutationProductAttributeUnassignArgs = {
  attributeIds: Array<Scalars['ID']>;
  productTypeId: Scalars['ID'];
};


export type MutationProductBulkCreateArgs = {
  errorPolicy: InputMaybe<ErrorPolicyEnum>;
  products: Array<ProductBulkCreateInput>;
};


export type MutationProductBulkDeleteArgs = {
  ids: Array<Scalars['ID']>;
};


export type MutationProductBulkTranslateArgs = {
  errorPolicy: InputMaybe<ErrorPolicyEnum>;
  translations: Array<ProductBulkTranslateInput>;
};


export type MutationProductChannelListingUpdateArgs = {
  id: Scalars['ID'];
  input: ProductChannelListingUpdateInput;
};


export type MutationProductCreateArgs = {
  input: ProductCreateInput;
};


export type MutationProductDeleteArgs = {
  externalReference: InputMaybe<Scalars['String']>;
  id: InputMaybe<Scalars['ID']>;
};


export type MutationProductMediaBulkDeleteArgs = {
  ids: Array<Scalars['ID']>;
};


export type MutationProductMediaCreateArgs = {
  input: ProductMediaCreateInput;
};


export type MutationProductMediaDeleteArgs = {
  id: Scalars['ID'];
};


export type MutationProductMediaReorderArgs = {
  mediaIds: Array<Scalars['ID']>;
  productId: Scalars['ID'];
};


export type MutationProductMediaUpdateArgs = {
  id: Scalars['ID'];
  input: ProductMediaUpdateInput;
};


export type MutationProductReorderAttributeValuesArgs = {
  attributeId: Scalars['ID'];
  moves: Array<ReorderInput>;
  productId: Scalars['ID'];
};


export type MutationProductTranslateArgs = {
  id: Scalars['ID'];
  input: TranslationInput;
  languageCode: LanguageCodeEnum;
};


export type MutationProductTypeBulkDeleteArgs = {
  ids: Array<Scalars['ID']>;
};


export type MutationProductTypeCreateArgs = {
  input: ProductTypeInput;
};


export type MutationProductTypeDeleteArgs = {
  id: Scalars['ID'];
};


export type MutationProductTypeReorderAttributesArgs = {
  moves: Array<ReorderInput>;
  productTypeId: Scalars['ID'];
  type: ProductAttributeType;
};


export type MutationProductTypeUpdateArgs = {
  id: Scalars['ID'];
  input: ProductTypeInput;
};


export type MutationProductUpdateArgs = {
  externalReference: InputMaybe<Scalars['String']>;
  id: InputMaybe<Scalars['ID']>;
  input: ProductInput;
};


export type MutationProductVariantBulkCreateArgs = {
  errorPolicy: InputMaybe<ErrorPolicyEnum>;
  product: Scalars['ID'];
  variants: Array<ProductVariantBulkCreateInput>;
};


export type MutationProductVariantBulkDeleteArgs = {
  ids: InputMaybe<Array<Scalars['ID']>>;
  skus: InputMaybe<Array<Scalars['String']>>;
};


export type MutationProductVariantBulkTranslateArgs = {
  errorPolicy: InputMaybe<ErrorPolicyEnum>;
  translations: Array<ProductVariantBulkTranslateInput>;
};


export type MutationProductVariantBulkUpdateArgs = {
  errorPolicy: InputMaybe<ErrorPolicyEnum>;
  product: Scalars['ID'];
  variants: Array<ProductVariantBulkUpdateInput>;
};


export type MutationProductVariantChannelListingUpdateArgs = {
  id: InputMaybe<Scalars['ID']>;
  input: Array<ProductVariantChannelListingAddInput>;
  sku: InputMaybe<Scalars['String']>;
};


export type MutationProductVariantCreateArgs = {
  input: ProductVariantCreateInput;
};


export type MutationProductVariantDeleteArgs = {
  externalReference: InputMaybe<Scalars['String']>;
  id: InputMaybe<Scalars['ID']>;
  sku: InputMaybe<Scalars['String']>;
};


export type MutationProductVariantPreorderDeactivateArgs = {
  id: Scalars['ID'];
};


export type MutationProductVariantReorderArgs = {
  moves: Array<ReorderInput>;
  productId: Scalars['ID'];
};


export type MutationProductVariantReorderAttributeValuesArgs = {
  attributeId: Scalars['ID'];
  moves: Array<ReorderInput>;
  variantId: Scalars['ID'];
};


export type MutationProductVariantSetDefaultArgs = {
  productId: Scalars['ID'];
  variantId: Scalars['ID'];
};


export type MutationProductVariantStocksCreateArgs = {
  stocks: Array<StockInput>;
  variantId: Scalars['ID'];
};


export type MutationProductVariantStocksDeleteArgs = {
  sku: InputMaybe<Scalars['String']>;
  variantId: InputMaybe<Scalars['ID']>;
  warehouseIds: InputMaybe<Array<Scalars['ID']>>;
};


export type MutationProductVariantStocksUpdateArgs = {
  sku: InputMaybe<Scalars['String']>;
  stocks: Array<StockInput>;
  variantId: InputMaybe<Scalars['ID']>;
};


export type MutationProductVariantTranslateArgs = {
  id: Scalars['ID'];
  input: NameTranslationInput;
  languageCode: LanguageCodeEnum;
};


export type MutationProductVariantUpdateArgs = {
  externalReference: InputMaybe<Scalars['String']>;
  id: InputMaybe<Scalars['ID']>;
  input: ProductVariantInput;
  sku: InputMaybe<Scalars['String']>;
};


export type MutationPromotionBulkDeleteArgs = {
  ids: Array<Scalars['ID']>;
};


export type MutationPromotionCreateArgs = {
  input: PromotionCreateInput;
};


export type MutationPromotionDeleteArgs = {
  id: Scalars['ID'];
};


export type MutationPromotionRuleCreateArgs = {
  input: PromotionRuleCreateInput;
};


export type MutationPromotionRuleDeleteArgs = {
  id: Scalars['ID'];
};


export type MutationPromotionRuleTranslateArgs = {
  id: Scalars['ID'];
  input: PromotionRuleTranslationInput;
  languageCode: LanguageCodeEnum;
};


export type MutationPromotionRuleUpdateArgs = {
  id: Scalars['ID'];
  input: PromotionRuleUpdateInput;
};


export type MutationPromotionTranslateArgs = {
  id: Scalars['ID'];
  input: PromotionTranslationInput;
  languageCode: LanguageCodeEnum;
};


export type MutationPromotionUpdateArgs = {
  id: Scalars['ID'];
  input: PromotionUpdateInput;
};


export type MutationRefundSettingsUpdateArgs = {
  input: RefundSettingsUpdateInput;
};


export type MutationRequestEmailChangeArgs = {
  channel: InputMaybe<Scalars['String']>;
  newEmail: Scalars['String'];
  password: Scalars['String'];
  redirectUrl: Scalars['String'];
};


export type MutationRequestPasswordResetArgs = {
  channel: InputMaybe<Scalars['String']>;
  email: Scalars['String'];
  redirectUrl: Scalars['String'];
};


export type MutationSaleBulkDeleteArgs = {
  ids: Array<Scalars['ID']>;
};


export type MutationSaleCataloguesAddArgs = {
  id: Scalars['ID'];
  input: CatalogueInput;
};


export type MutationSaleCataloguesRemoveArgs = {
  id: Scalars['ID'];
  input: CatalogueInput;
};


export type MutationSaleChannelListingUpdateArgs = {
  id: Scalars['ID'];
  input: SaleChannelListingInput;
};


export type MutationSaleCreateArgs = {
  input: SaleInput;
};


export type MutationSaleDeleteArgs = {
  id: Scalars['ID'];
};


export type MutationSaleTranslateArgs = {
  id: Scalars['ID'];
  input: NameTranslationInput;
  languageCode: LanguageCodeEnum;
};


export type MutationSaleUpdateArgs = {
  id: Scalars['ID'];
  input: SaleInput;
};


export type MutationSendConfirmationEmailArgs = {
  channel: Scalars['String'];
  redirectUrl: Scalars['String'];
};


export type MutationSetPasswordArgs = {
  email: Scalars['String'];
  password: Scalars['String'];
  token: Scalars['String'];
};


export type MutationShippingMethodChannelListingUpdateArgs = {
  id: Scalars['ID'];
  input: ShippingMethodChannelListingInput;
};


export type MutationShippingPriceBulkDeleteArgs = {
  ids: Array<Scalars['ID']>;
};


export type MutationShippingPriceCreateArgs = {
  input: ShippingPriceInput;
};


export type MutationShippingPriceDeleteArgs = {
  id: Scalars['ID'];
};


export type MutationShippingPriceExcludeProductsArgs = {
  id: Scalars['ID'];
  input: ShippingPriceExcludeProductsInput;
};


export type MutationShippingPriceRemoveProductFromExcludeArgs = {
  id: Scalars['ID'];
  products: Array<Scalars['ID']>;
};


export type MutationShippingPriceTranslateArgs = {
  id: Scalars['ID'];
  input: ShippingPriceTranslationInput;
  languageCode: LanguageCodeEnum;
};


export type MutationShippingPriceUpdateArgs = {
  id: Scalars['ID'];
  input: ShippingPriceInput;
};


export type MutationShippingZoneBulkDeleteArgs = {
  ids: Array<Scalars['ID']>;
};


export type MutationShippingZoneCreateArgs = {
  input: ShippingZoneCreateInput;
};


export type MutationShippingZoneDeleteArgs = {
  id: Scalars['ID'];
};


export type MutationShippingZoneUpdateArgs = {
  id: Scalars['ID'];
  input: ShippingZoneUpdateInput;
};


export type MutationShopAddressUpdateArgs = {
  input: InputMaybe<AddressInput>;
};


export type MutationShopDomainUpdateArgs = {
  input: InputMaybe<SiteDomainInput>;
};


export type MutationShopSettingsTranslateArgs = {
  input: ShopSettingsTranslationInput;
  languageCode: LanguageCodeEnum;
};


export type MutationShopSettingsUpdateArgs = {
  input: ShopSettingsInput;
};


export type MutationStaffBulkDeleteArgs = {
  ids: Array<Scalars['ID']>;
};


export type MutationStaffCreateArgs = {
  input: StaffCreateInput;
};


export type MutationStaffDeleteArgs = {
  id: Scalars['ID'];
};


export type MutationStaffNotificationRecipientCreateArgs = {
  input: StaffNotificationRecipientInput;
};


export type MutationStaffNotificationRecipientDeleteArgs = {
  id: Scalars['ID'];
};


export type MutationStaffNotificationRecipientUpdateArgs = {
  id: Scalars['ID'];
  input: StaffNotificationRecipientInput;
};


export type MutationStaffUpdateArgs = {
  id: Scalars['ID'];
  input: StaffUpdateInput;
};


export type MutationStockBulkUpdateArgs = {
  errorPolicy: InputMaybe<ErrorPolicyEnum>;
  stocks: Array<StockBulkUpdateInput>;
};


export type MutationStoredPaymentMethodRequestDeleteArgs = {
  channel: Scalars['String'];
  id: Scalars['ID'];
};


export type MutationTaxClassCreateArgs = {
  input: TaxClassCreateInput;
};


export type MutationTaxClassDeleteArgs = {
  id: Scalars['ID'];
};


export type MutationTaxClassUpdateArgs = {
  id: Scalars['ID'];
  input: TaxClassUpdateInput;
};


export type MutationTaxConfigurationUpdateArgs = {
  id: Scalars['ID'];
  input: TaxConfigurationUpdateInput;
};


export type MutationTaxCountryConfigurationDeleteArgs = {
  countryCode: CountryCode;
};


export type MutationTaxCountryConfigurationUpdateArgs = {
  countryCode: CountryCode;
  updateTaxClassRates: Array<TaxClassRateInput>;
};


export type MutationTaxExemptionManageArgs = {
  id: Scalars['ID'];
  taxExemption: Scalars['Boolean'];
};


export type MutationTokenCreateArgs = {
  audience: InputMaybe<Scalars['String']>;
  email: Scalars['String'];
  password: Scalars['String'];
};


export type MutationTokenRefreshArgs = {
  csrfToken: InputMaybe<Scalars['String']>;
  refreshToken: InputMaybe<Scalars['String']>;
};


export type MutationTokenVerifyArgs = {
  token: Scalars['String'];
};


export type MutationTransactionCreateArgs = {
  id: Scalars['ID'];
  transaction: TransactionCreateInput;
  transactionEvent: InputMaybe<TransactionEventInput>;
};


export type MutationTransactionEventReportArgs = {
  amount: InputMaybe<Scalars['PositiveDecimal']>;
  availableActions: InputMaybe<Array<TransactionActionEnum>>;
  externalUrl: InputMaybe<Scalars['String']>;
  id: InputMaybe<Scalars['ID']>;
  message: InputMaybe<Scalars['String']>;
  paymentMethodDetails: InputMaybe<PaymentMethodDetailsInput>;
  pspReference: Scalars['String'];
  time: InputMaybe<Scalars['DateTime']>;
  token: InputMaybe<Scalars['UUID']>;
  transactionMetadata: InputMaybe<Array<MetadataInput>>;
  transactionPrivateMetadata: InputMaybe<Array<MetadataInput>>;
  type: TransactionEventTypeEnum;
};


export type MutationTransactionInitializeArgs = {
  action: InputMaybe<TransactionFlowStrategyEnum>;
  amount: InputMaybe<Scalars['PositiveDecimal']>;
  customerIpAddress: InputMaybe<Scalars['String']>;
  id: Scalars['ID'];
  idempotencyKey: InputMaybe<Scalars['String']>;
  paymentGateway: PaymentGatewayToInitialize;
};


export type MutationTransactionProcessArgs = {
  customerIpAddress: InputMaybe<Scalars['String']>;
  data: InputMaybe<Scalars['JSON']>;
  id: InputMaybe<Scalars['ID']>;
  token: InputMaybe<Scalars['UUID']>;
};


export type MutationTransactionRequestActionArgs = {
  actionType: TransactionActionEnum;
  amount: InputMaybe<Scalars['PositiveDecimal']>;
  id: InputMaybe<Scalars['ID']>;
  refundReason: InputMaybe<Scalars['String']>;
  refundReasonReference: InputMaybe<Scalars['ID']>;
  token: InputMaybe<Scalars['UUID']>;
};


export type MutationTransactionRequestRefundForGrantedRefundArgs = {
  grantedRefundId: Scalars['ID'];
  id: InputMaybe<Scalars['ID']>;
  token: InputMaybe<Scalars['UUID']>;
};


export type MutationTransactionUpdateArgs = {
  id: InputMaybe<Scalars['ID']>;
  token: InputMaybe<Scalars['UUID']>;
  transaction: InputMaybe<TransactionUpdateInput>;
  transactionEvent: InputMaybe<TransactionEventInput>;
};


export type MutationUnassignWarehouseShippingZoneArgs = {
  id: Scalars['ID'];
  shippingZoneIds: Array<Scalars['ID']>;
};


export type MutationUpdateMetadataArgs = {
  id: Scalars['ID'];
  input: Array<MetadataInput>;
};


export type MutationUpdatePrivateMetadataArgs = {
  id: Scalars['ID'];
  input: Array<MetadataInput>;
};


export type MutationUpdateWarehouseArgs = {
  externalReference: InputMaybe<Scalars['String']>;
  id: InputMaybe<Scalars['ID']>;
  input: WarehouseUpdateInput;
};


export type MutationUserAvatarUpdateArgs = {
  image: Scalars['Upload'];
};


export type MutationUserBulkSetActiveArgs = {
  ids: Array<Scalars['ID']>;
  isActive: Scalars['Boolean'];
};


export type MutationVariantMediaAssignArgs = {
  mediaId: Scalars['ID'];
  variantId: Scalars['ID'];
};


export type MutationVariantMediaUnassignArgs = {
  mediaId: Scalars['ID'];
  variantId: Scalars['ID'];
};


export type MutationVoucherBulkDeleteArgs = {
  ids: Array<Scalars['ID']>;
};


export type MutationVoucherCataloguesAddArgs = {
  id: Scalars['ID'];
  input: CatalogueInput;
};


export type MutationVoucherCataloguesRemoveArgs = {
  id: Scalars['ID'];
  input: CatalogueInput;
};


export type MutationVoucherChannelListingUpdateArgs = {
  id: Scalars['ID'];
  input: VoucherChannelListingInput;
};


export type MutationVoucherCodeBulkDeleteArgs = {
  ids: Array<Scalars['ID']>;
};


export type MutationVoucherCreateArgs = {
  input: VoucherInput;
};


export type MutationVoucherDeleteArgs = {
  id: Scalars['ID'];
};


export type MutationVoucherTranslateArgs = {
  id: Scalars['ID'];
  input: NameTranslationInput;
  languageCode: LanguageCodeEnum;
};


export type MutationVoucherUpdateArgs = {
  id: Scalars['ID'];
  input: VoucherInput;
};


export type MutationWebhookCreateArgs = {
  input: WebhookCreateInput;
};


export type MutationWebhookDeleteArgs = {
  id: Scalars['ID'];
};


export type MutationWebhookDryRunArgs = {
  objectId: Scalars['ID'];
  query: Scalars['String'];
};


export type MutationWebhookTriggerArgs = {
  objectId: Scalars['ID'];
  webhookId: Scalars['ID'];
};


export type MutationWebhookUpdateArgs = {
  id: Scalars['ID'];
  input: WebhookUpdateInput;
};

export type NameTranslationInput = {
  name: InputMaybe<Scalars['String']>;
};

export type NavigationType =
  /** Main storefront navigation. */
  | 'MAIN'
  /** Secondary storefront navigation. */
  | 'SECONDARY';

/** Represents the NEW_TAB target options for an app extension. */
export type NewTabTargetOptions = {
  __typename: 'NewTabTargetOptions';
  /**
   * HTTP method for New Tab target (GET or POST)
   * @deprecated Use `settings` field directly.
   */
  method: HttpMethod;
};

/** An object with an ID */
export type Node = {
  /** The ID of the object. */
  id: Scalars['ID'];
};

/**
 * An object with attributes.
 *
 * Added in Saleor 3.22.
 */
export type ObjectWithAttributes = {
  /**
   * Get a single attribute attached to the object by attribute slug.
   *
   * Added in Saleor 3.22.
   */
  assignedAttribute: Maybe<AssignedAttribute>;
  /**
   * List of attributes assigned to the object.
   *
   * Added in Saleor 3.22.
   */
  assignedAttributes: Array<AssignedAttribute>;
};


/**
 * An object with attributes.
 *
 * Added in Saleor 3.22.
 */
export type ObjectWithAttributesAssignedAttributeArgs = {
  slug: Scalars['String'];
};


/**
 * An object with attributes.
 *
 * Added in Saleor 3.22.
 */
export type ObjectWithAttributesAssignedAttributesArgs = {
  limit?: InputMaybe<Scalars['PositiveInt']>;
};

export type ObjectWithMetadata = {
  /** List of public metadata items. Can be accessed without permissions. */
  metadata: Array<MetadataItem>;
  /**
   * A single key from public metadata.
   *
   * Tip: Use GraphQL aliases to fetch multiple keys.
   */
  metafield: Maybe<Scalars['String']>;
  /** Public metadata. Use `keys` to control which fields you want to include. The default is to include everything. */
  metafields: Maybe<Scalars['Metadata']>;
  /** List of private metadata items. Requires staff permissions to access. */
  privateMetadata: Array<MetadataItem>;
  /**
   * A single key from private metadata. Requires staff permissions to access.
   *
   * Tip: Use GraphQL aliases to fetch multiple keys.
   */
  privateMetafield: Maybe<Scalars['String']>;
  /** Private metadata. Requires staff permissions to access. Use `keys` to control which fields you want to include. The default is to include everything. */
  privateMetafields: Maybe<Scalars['Metadata']>;
};


export type ObjectWithMetadataMetafieldArgs = {
  key: Scalars['String'];
};


export type ObjectWithMetadataMetafieldsArgs = {
  keys: InputMaybe<Array<Scalars['String']>>;
};


export type ObjectWithMetadataPrivateMetafieldArgs = {
  key: Scalars['String'];
};


export type ObjectWithMetadataPrivateMetafieldsArgs = {
  keys: InputMaybe<Array<Scalars['String']>>;
};

/** Represents an order in the shop. */
export type Order = Node & ObjectWithMetadata & {
  __typename: 'Order';
  /** List of actions that can be performed in the current state of an order. */
  actions: Array<OrderAction>;
  /** The authorize status of the order. */
  authorizeStatus: OrderAuthorizeStatusEnum;
  /** Collection points that can be used for this order. */
  availableCollectionPoints: Array<Warehouse>;
  /**
   * Shipping methods that can be used with this order.
   * @deprecated Use `shippingMethods`, this field will be removed in 4.0
   */
  availableShippingMethods: Maybe<Array<ShippingMethod>>;
  /** Billing address. The full data can be access for orders created in Saleor 3.2 and later, for other orders requires one of the following permissions: MANAGE_ORDERS, OWNER. */
  billingAddress: Maybe<Address>;
  /** Informs whether a draft order can be finalized(turned into a regular order). */
  canFinalize: Scalars['Boolean'];
  /** Channel through which the order was placed. */
  channel: Channel;
  /** The charge status of the order. */
  chargeStatus: OrderChargeStatusEnum;
  /** ID of the checkout that the order was created from. */
  checkoutId: Maybe<Scalars['ID']>;
  /** Name of the collection point where the order should be picked up by the customer. */
  collectionPointName: Maybe<Scalars['String']>;
  /** Date and time when the order was created. */
  created: Scalars['DateTime'];
  /** Additional information provided by the customer about the order. */
  customerNote: Scalars['String'];
  /** The delivery method selected for this order. */
  deliveryMethod: Maybe<DeliveryMethod>;
  /**
   * Returns applied discount.
   * @deprecated Use the `discounts` field instead.
   */
  discount: Maybe<Money>;
  /**
   * Discount name.
   * @deprecated Use the `discounts` field instead.
   */
  discountName: Maybe<Scalars['String']>;
  /** List of all discounts assigned to the order. */
  discounts: Array<OrderDiscount>;
  /** Determines whether displayed prices should include taxes. */
  displayGrossPrices: Scalars['Boolean'];
  /** List of errors that occurred during order validation. */
  errors: Array<OrderError>;
  /**
   * List of events associated with the order.
   *
   * Requires one of the following permissions: MANAGE_ORDERS.
   */
  events: Array<OrderEvent>;
  /** External ID of this order. */
  externalReference: Maybe<Scalars['String']>;
  /** List of shipments for the order. */
  fulfillments: Array<Fulfillment>;
  /** List of user gift cards. */
  giftCards: Array<GiftCard>;
  /**
   * List of granted refunds.
   *
   * Requires one of the following permissions: MANAGE_ORDERS.
   */
  grantedRefunds: Array<OrderGrantedRefund>;
  /** ID of the order. */
  id: Scalars['ID'];
  /** List of order invoices. Can be fetched for orders created in Saleor 3.2 and later, for other orders requires one of the following permissions: MANAGE_ORDERS, OWNER. */
  invoices: Array<Invoice>;
  /** Informs if an order is fully paid. */
  isPaid: Scalars['Boolean'];
  /** Returns True, if order requires shipping. */
  isShippingRequired: Scalars['Boolean'];
  /** @deprecated Use the `languageCodeEnum` field to fetch the language code. */
  languageCode: Scalars['String'];
  /** Order language code. */
  languageCodeEnum: LanguageCodeEnum;
  /** List of order lines. */
  lines: Array<OrderLine>;
  /** List of public metadata items. Can be accessed without permissions. */
  metadata: Array<MetadataItem>;
  /**
   * A single key from public metadata.
   *
   * Tip: Use GraphQL aliases to fetch multiple keys.
   */
  metafield: Maybe<Scalars['String']>;
  /** Public metadata. Use `keys` to control which fields you want to include. The default is to include everything. */
  metafields: Maybe<Scalars['Metadata']>;
  /** User-friendly number of an order. */
  number: Scalars['String'];
  /** The order origin. */
  origin: OrderOriginEnum;
  /** The ID of the order that was the base for this order. */
  original: Maybe<Scalars['ID']>;
  /** Internal payment status. */
  paymentStatus: PaymentChargeStatusEnum;
  /** User-friendly payment status. */
  paymentStatusDisplay: Scalars['String'];
  /** List of payments for the order. */
  payments: Array<Payment>;
  /** List of private metadata items. Requires staff permissions to access. */
  privateMetadata: Array<MetadataItem>;
  /**
   * A single key from private metadata. Requires staff permissions to access.
   *
   * Tip: Use GraphQL aliases to fetch multiple keys.
   */
  privateMetafield: Maybe<Scalars['String']>;
  /** Private metadata. Requires staff permissions to access. Use `keys` to control which fields you want to include. The default is to include everything. */
  privateMetafields: Maybe<Scalars['Metadata']>;
  /** URL to which user should be redirected after order is placed. */
  redirectUrl: Maybe<Scalars['String']>;
  /** Shipping address. The full data can be access for orders created in Saleor 3.2 and later, for other orders requires one of the following permissions: MANAGE_ORDERS, OWNER. */
  shippingAddress: Maybe<Address>;
  /**
   * Shipping method for this order.
   * @deprecated Use `deliveryMethod` instead.
   */
  shippingMethod: Maybe<ShippingMethod>;
  /** Method used for shipping. */
  shippingMethodName: Maybe<Scalars['String']>;
  /** Shipping methods related to this order. */
  shippingMethods: Array<ShippingMethod>;
  /** Total price of shipping. */
  shippingPrice: TaxedMoney;
  /**
   * Denormalized tax class assigned to the shipping method.
   *
   * Requires one of the following permissions: AUTHENTICATED_STAFF_USER, AUTHENTICATED_APP.
   */
  shippingTaxClass: Maybe<TaxClass>;
  /** Denormalized public metadata of the shipping method's tax class. */
  shippingTaxClassMetadata: Array<MetadataItem>;
  /** Denormalized name of the tax class assigned to the shipping method. */
  shippingTaxClassName: Maybe<Scalars['String']>;
  /** Denormalized private metadata of the shipping method's tax class. Requires staff permissions to access. */
  shippingTaxClassPrivateMetadata: Array<MetadataItem>;
  /** The shipping tax rate value. */
  shippingTaxRate: Scalars['Float'];
  /** Status of the order. */
  status: OrderStatus;
  /** User-friendly order status. */
  statusDisplay: Scalars['String'];
  /** The sum of line prices not including shipping. */
  subtotal: TaxedMoney;
  /** Returns True if order has to be exempt from taxes. */
  taxExemption: Scalars['Boolean'];
  /** @deprecated Use `id` instead. */
  token: Scalars['String'];
  /** Total amount of the order. */
  total: TaxedMoney;
  /**
   * Total amount of ongoing authorize requests for the order's transactions.
   *
   * Requires one of the following permissions: MANAGE_ORDERS.
   */
  totalAuthorizePending: Money;
  /** Amount authorized for the order. */
  totalAuthorized: Money;
  /** The difference between the paid and the order total amount. */
  totalBalance: Money;
  /**
   * Total amount of ongoing cancel requests for the order's transactions.
   *
   * Requires one of the following permissions: MANAGE_ORDERS.
   */
  totalCancelPending: Money;
  /** Amount canceled for the order. */
  totalCanceled: Money;
  /**
   * Amount captured for the order.
   * @deprecated Use `totalCharged` instead.
   */
  totalCaptured: Money;
  /**
   * Total amount of ongoing charge requests for the order's transactions.
   *
   * Requires one of the following permissions: MANAGE_ORDERS.
   */
  totalChargePending: Money;
  /** Amount charged for the order. */
  totalCharged: Money;
  /**
   * Total amount of granted refund.
   *
   * Requires one of the following permissions: MANAGE_ORDERS.
   */
  totalGrantedRefund: Money;
  /**
   * Total amount of ongoing refund requests for the order's transactions.
   *
   * Requires one of the following permissions: MANAGE_ORDERS.
   */
  totalRefundPending: Money;
  /** Total refund amount for the order. */
  totalRefunded: Money;
  /**
   * The difference amount between granted refund and the amounts that are pending and refunded.
   *
   * Requires one of the following permissions: MANAGE_ORDERS.
   */
  totalRemainingGrant: Money;
  /** Google Analytics tracking client ID. */
  trackingClientId: Scalars['String'];
  /** List of transactions for the order. Requires one of the following permissions: MANAGE_ORDERS, HANDLE_PAYMENTS. */
  transactions: Array<TransactionItem>;
  /**
   * Translated discount name.
   * @deprecated Use the `discounts` field instead.
   */
  translatedDiscountName: Maybe<Scalars['String']>;
  /**
   * Undiscounted total price of shipping.
   *
   * Added in Saleor 3.19.
   */
  undiscountedShippingPrice: Money;
  /** Undiscounted total amount of the order. */
  undiscountedTotal: TaxedMoney;
  /** Date and time when the order was created. */
  updatedAt: Scalars['DateTime'];
  /** User who placed the order. This field is set only for orders placed by authenticated users. Can be fetched for orders created in Saleor 3.2 and later, for other orders requires one of the following permissions: MANAGE_USERS, MANAGE_ORDERS, HANDLE_PAYMENTS, OWNER. */
  user: Maybe<User>;
  /** Email address of the customer. The full data can be access for orders created in Saleor 3.2 and later, for other orders requires one of the following permissions: MANAGE_ORDERS, OWNER. */
  userEmail: Maybe<Scalars['String']>;
  /** Voucher linked to the order. */
  voucher: Maybe<Voucher>;
  /**
   * Voucher code that was used for Order.
   *
   * Added in Saleor 3.18.
   */
  voucherCode: Maybe<Scalars['String']>;
  /** Weight of the order. */
  weight: Weight;
};


/** Represents an order in the shop. */
export type OrderMetafieldArgs = {
  key: Scalars['String'];
};


/** Represents an order in the shop. */
export type OrderMetafieldsArgs = {
  keys: InputMaybe<Array<Scalars['String']>>;
};


/** Represents an order in the shop. */
export type OrderPrivateMetafieldArgs = {
  key: Scalars['String'];
};


/** Represents an order in the shop. */
export type OrderPrivateMetafieldsArgs = {
  keys: InputMaybe<Array<Scalars['String']>>;
};

export type OrderAction =
  /** Represents the capture action. */
  | 'CAPTURE'
  /** Represents a mark-as-paid action. */
  | 'MARK_AS_PAID'
  /** Represents a refund action. */
  | 'REFUND'
  /** Represents a void action. */
  | 'VOID';

/**
 * Adds note to the order.
 *
 * Requires one of the following permissions: MANAGE_ORDERS.
 */
export type OrderAddNote = {
  __typename: 'OrderAddNote';
  errors: Array<OrderError>;
  /** Order note created. */
  event: Maybe<OrderEvent>;
  /** Order with the note added. */
  order: Maybe<Order>;
  /** @deprecated Use `errors` field instead. */
  orderErrors: Array<OrderError>;
};

export type OrderAddNoteInput = {
  /** Note message. */
  message: Scalars['String'];
};

/**
 * Determine a current authorize status for order.
 *
 *     We treat the order as fully authorized when the sum of authorized and charged funds
 *     cover the `order.total`-`order.totalGrantedRefund`.
 *     We treat the order as partially authorized when the sum of authorized and charged
 *     funds covers only part of the `order.total`-`order.totalGrantedRefund`.
 *     We treat the order as not authorized when the sum of authorized and charged funds is
 *     0.
 *
 *     NONE - the funds are not authorized
 *     PARTIAL - the funds that are authorized and charged don't cover fully the
 *     `order.total`-`order.totalGrantedRefund`
 *     FULL - the funds that are authorized and charged fully cover the
 *     `order.total`-`order.totalGrantedRefund`
 */
export type OrderAuthorizeStatusEnum =
  | 'FULL'
  | 'NONE'
  | 'PARTIAL';

/** Filter by authorize status. */
export type OrderAuthorizeStatusEnumFilterInput = {
  /** The value equal to. */
  eq: InputMaybe<OrderAuthorizeStatusEnum>;
  /** The value included in. */
  oneOf: InputMaybe<Array<OrderAuthorizeStatusEnum>>;
};

/**
 * Cancels orders.
 *
 * Requires one of the following permissions: MANAGE_ORDERS.
 */
export type OrderBulkCancel = {
  __typename: 'OrderBulkCancel';
  /** Returns how many objects were affected. */
  count: Scalars['Int'];
  errors: Array<OrderError>;
  /** @deprecated Use `errors` field instead. */
  orderErrors: Array<OrderError>;
};

/**
 * Creates multiple orders.
 *
 * Requires one of the following permissions: MANAGE_ORDERS_IMPORT.
 */
export type OrderBulkCreate = {
  __typename: 'OrderBulkCreate';
  /** Returns how many objects were created. */
  count: Scalars['Int'];
  errors: Array<OrderBulkCreateError>;
  /** List of the created orders. */
  results: Array<OrderBulkCreateResult>;
};

export type OrderBulkCreateDeliveryMethodInput = {
  /** The ID of the shipping method. */
  shippingMethodId: InputMaybe<Scalars['ID']>;
  /** The name of the shipping method. */
  shippingMethodName: InputMaybe<Scalars['String']>;
  /** The price of the shipping. */
  shippingPrice: InputMaybe<TaxedMoneyInput>;
  /** The ID of the tax class. */
  shippingTaxClassId: InputMaybe<Scalars['ID']>;
  /**
   * Metadata of the tax class. Can be read by any API client authorized to read the object it's attached to.
   *
   * Warning: never store sensitive information, including financial data such as credit card details.
   */
  shippingTaxClassMetadata: InputMaybe<Array<MetadataInput>>;
  /** The name of the tax class. */
  shippingTaxClassName: InputMaybe<Scalars['String']>;
  /**
   * Private metadata of the tax class. Requires permissions to modify and to read the metadata of the object it's attached to.
   *
   * Warning: never store sensitive information, including financial data such as credit card details.
   */
  shippingTaxClassPrivateMetadata: InputMaybe<Array<MetadataInput>>;
  /** Tax rate of the shipping. */
  shippingTaxRate: InputMaybe<Scalars['PositiveDecimal']>;
  /** The ID of the warehouse. */
  warehouseId: InputMaybe<Scalars['ID']>;
  /** The name of the warehouse. */
  warehouseName: InputMaybe<Scalars['String']>;
};

export type OrderBulkCreateError = {
  __typename: 'OrderBulkCreateError';
  /** The error code. */
  code: Maybe<OrderBulkCreateErrorCode>;
  /** The error message. */
  message: Maybe<Scalars['String']>;
  /** Path to field that caused the error. A value of `null` indicates that the error isn't associated with a particular field. */
  path: Maybe<Scalars['String']>;
};

export type OrderBulkCreateErrorCode =
  | 'BULK_LIMIT'
  | 'FUTURE_DATE'
  | 'GRAPHQL_ERROR'
  | 'INCORRECT_CURRENCY'
  | 'INSUFFICIENT_STOCK'
  | 'INVALID'
  | 'INVALID_QUANTITY'
  | 'METADATA_KEY_REQUIRED'
  | 'NEGATIVE_INDEX'
  | 'NON_EXISTING_STOCK'
  | 'NOTE_LENGTH'
  | 'NOT_FOUND'
  | 'NO_RELATED_ORDER_LINE'
  | 'ORDER_LINE_FULFILLMENT_LINE_MISMATCH'
  | 'PRICE_ERROR'
  | 'REQUIRED'
  | 'TOO_MANY_IDENTIFIERS'
  | 'UNIQUE';

export type OrderBulkCreateFulfillmentInput = {
  /** List of items informing how to fulfill the order. */
  lines: InputMaybe<Array<OrderBulkCreateFulfillmentLineInput>>;
  /** Fulfillment's tracking code. */
  trackingCode: InputMaybe<Scalars['String']>;
};

export type OrderBulkCreateFulfillmentLineInput = {
  /** 0-based index of order line, which the fulfillment line refers to. */
  orderLineIndex: Scalars['Int'];
  /** The number of line items to be fulfilled from given warehouse. */
  quantity: Scalars['Int'];
  /** The external ID of the product variant. */
  variantExternalReference: InputMaybe<Scalars['String']>;
  /** The ID of the product variant. */
  variantId: InputMaybe<Scalars['ID']>;
  /** The SKU of the product variant. */
  variantSku: InputMaybe<Scalars['String']>;
  /** ID of the warehouse from which the item will be fulfilled. */
  warehouse: Scalars['ID'];
};

export type OrderBulkCreateInput = {
  /** Billing address of the customer. */
  billingAddress: AddressInput;
  /** Slug of the channel associated with the order. */
  channel: Scalars['String'];
  /** The date, when the order was inserted to Saleor database. */
  createdAt: Scalars['DateTime'];
  /** Currency code. */
  currency: Scalars['String'];
  /** Note about customer. */
  customerNote: InputMaybe<Scalars['String']>;
  /** The delivery method selected for this order. */
  deliveryMethod: InputMaybe<OrderBulkCreateDeliveryMethodInput>;
  /** List of discounts. */
  discounts: InputMaybe<Array<OrderDiscountCommonInput>>;
  /** Determines whether displayed prices should include taxes. */
  displayGrossPrices: InputMaybe<Scalars['Boolean']>;
  /** External ID of the order. */
  externalReference: InputMaybe<Scalars['String']>;
  /** Fulfillments of the order. */
  fulfillments: InputMaybe<Array<OrderBulkCreateFulfillmentInput>>;
  /** List of gift card codes associated with the order. */
  giftCards: InputMaybe<Array<Scalars['String']>>;
  /** Invoices related to the order. */
  invoices: InputMaybe<Array<OrderBulkCreateInvoiceInput>>;
  /** Order language code. */
  languageCode: LanguageCodeEnum;
  /** List of order lines. */
  lines: Array<OrderBulkCreateOrderLineInput>;
  /**
   * Metadata of the order. Can be read by any API client authorized to read the object it's attached to.
   *
   * Warning: never store sensitive information, including financial data such as credit card details.
   */
  metadata: InputMaybe<Array<MetadataInput>>;
  /** Notes related to the order. */
  notes: InputMaybe<Array<OrderBulkCreateNoteInput>>;
  /**
   * Private metadata of the order. Requires permissions to modify and to read the metadata of the object it's attached to.
   *
   * Warning: never store sensitive information, including financial data such as credit card details.
   */
  privateMetadata: InputMaybe<Array<MetadataInput>>;
  /** URL of a view, where users should be redirected to see the order details. */
  redirectUrl: InputMaybe<Scalars['String']>;
  /** Shipping address of the customer. */
  shippingAddress: InputMaybe<AddressInput>;
  /** Status of the order. */
  status: InputMaybe<OrderStatus>;
  /** Transactions related to the order. */
  transactions: InputMaybe<Array<TransactionCreateInput>>;
  /** Customer associated with the order. */
  user: OrderBulkCreateUserInput;
  /**
   * Code of a voucher associated with the order.
   *
   * Added in Saleor 3.18.
   */
  voucherCode: InputMaybe<Scalars['String']>;
  /** Weight of the order in kg. */
  weight: InputMaybe<Scalars['WeightScalar']>;
};

export type OrderBulkCreateInvoiceInput = {
  /** The date, when the invoice was created. */
  createdAt: Scalars['DateTime'];
  /**
   * Metadata of the invoice. Can be read by any API client authorized to read the object it's attached to.
   *
   * Warning: never store sensitive information, including financial data such as credit card details.
   */
  metadata: InputMaybe<Array<MetadataInput>>;
  /** Invoice number. */
  number: InputMaybe<Scalars['String']>;
  /**
   * Private metadata of the invoice. Requires permissions to modify and to read the metadata of the object it's attached to.
   *
   * Warning: never store sensitive information, including financial data such as credit card details.
   */
  privateMetadata: InputMaybe<Array<MetadataInput>>;
  /** URL of the invoice to download. */
  url: InputMaybe<Scalars['String']>;
};

export type OrderBulkCreateNoteInput = {
  /** The app ID associated with the message. */
  appId: InputMaybe<Scalars['ID']>;
  /** The date associated with the message. */
  date: InputMaybe<Scalars['DateTime']>;
  /** Note message. Max characters: 255. */
  message: Scalars['String'];
  /** The user email associated with the message. */
  userEmail: InputMaybe<Scalars['ID']>;
  /** The user external ID associated with the message. */
  userExternalReference: InputMaybe<Scalars['ID']>;
  /** The user ID associated with the message. */
  userId: InputMaybe<Scalars['ID']>;
};

export type OrderBulkCreateOrderLineInput = {
  /** The date, when the order line was created. */
  createdAt: Scalars['DateTime'];
  /** Gift card flag. */
  isGiftCard: Scalars['Boolean'];
  /** Determines whether shipping of the order line items is required. */
  isShippingRequired: Scalars['Boolean'];
  /**
   * Metadata of the order line. Can be read by any API client authorized to read the object it's attached to.
   *
   * Warning: never store sensitive information, including financial data such as credit card details.
   */
  metadata: InputMaybe<Array<MetadataInput>>;
  /**
   * Private metadata of the order line. Requires permissions to modify and to read the metadata of the object it's attached to.
   *
   * Warning: never store sensitive information, including financial data such as credit card details.
   */
  privateMetadata: InputMaybe<Array<MetadataInput>>;
  /** The name of the product. */
  productName: InputMaybe<Scalars['String']>;
  /**
   * The SKU of the product.
   *
   * Added in Saleor 3.18.
   */
  productSku: InputMaybe<Scalars['String']>;
  /** Number of items in the order line */
  quantity: Scalars['Int'];
  /** The ID of the tax class. */
  taxClassId: InputMaybe<Scalars['ID']>;
  /**
   * Metadata of the tax class. Can be read by any API client authorized to read the object it's attached to.
   *
   * Warning: never store sensitive information, including financial data such as credit card details.
   */
  taxClassMetadata: InputMaybe<Array<MetadataInput>>;
  /** The name of the tax class. */
  taxClassName: InputMaybe<Scalars['String']>;
  /**
   * Private metadata of the tax class. Requires permissions to modify and to read the metadata of the object it's attached to.
   *
   * Warning: never store sensitive information, including financial data such as credit card details.
   */
  taxClassPrivateMetadata: InputMaybe<Array<MetadataInput>>;
  /** Tax rate of the order line. */
  taxRate: InputMaybe<Scalars['PositiveDecimal']>;
  /** Price of the order line. */
  totalPrice: TaxedMoneyInput;
  /** Translation of the product name. */
  translatedProductName: InputMaybe<Scalars['String']>;
  /** Translation of the product variant name. */
  translatedVariantName: InputMaybe<Scalars['String']>;
  /** Price of the order line excluding applied discount. */
  undiscountedTotalPrice: TaxedMoneyInput;
  /**
   * Reason of the discount on order line.
   *
   * Added in Saleor 3.19.
   */
  unitDiscountReason: InputMaybe<Scalars['String']>;
  /**
   * Type of the discount: fixed or percent
   *
   * Added in Saleor 3.19.
   */
  unitDiscountType: InputMaybe<DiscountValueTypeEnum>;
  /**
   * Value of the discount. Can store fixed value or percent value
   *
   * Added in Saleor 3.19.
   */
  unitDiscountValue: InputMaybe<Scalars['PositiveDecimal']>;
  /** The external ID of the product variant. */
  variantExternalReference: InputMaybe<Scalars['String']>;
  /** The ID of the product variant. */
  variantId: InputMaybe<Scalars['ID']>;
  /** The name of the product variant. */
  variantName: InputMaybe<Scalars['String']>;
  /** The SKU of the product variant. */
  variantSku: InputMaybe<Scalars['String']>;
  /** The ID of the warehouse, where the line will be allocated. */
  warehouse: Scalars['ID'];
};

export type OrderBulkCreateResult = {
  __typename: 'OrderBulkCreateResult';
  /** List of errors occurred on create attempt. */
  errors: Maybe<Array<OrderBulkCreateError>>;
  /** Order data. */
  order: Maybe<Order>;
};

export type OrderBulkCreateUserInput = {
  /** Customer email associated with the order. */
  email: InputMaybe<Scalars['String']>;
  /** Customer external ID associated with the order. */
  externalReference: InputMaybe<Scalars['String']>;
  /** Customer ID associated with the order. */
  id: InputMaybe<Scalars['ID']>;
};

/** Event sent when orders are imported. */
export type OrderBulkCreated = Event & {
  __typename: 'OrderBulkCreated';
  /** Time of the event. */
  issuedAt: Maybe<Scalars['DateTime']>;
  /** The user or application that triggered the event. */
  issuingPrincipal: Maybe<IssuingPrincipal>;
  /** The orders the event relates to. */
  orders: Maybe<Array<Order>>;
  /** The application receiving the webhook. */
  recipient: Maybe<App>;
  /** Saleor version that triggered the event. */
  version: Maybe<Scalars['String']>;
};

/**
 * Cancel an order.
 *
 * Requires one of the following permissions: MANAGE_ORDERS.
 */
export type OrderCancel = {
  __typename: 'OrderCancel';
  errors: Array<OrderError>;
  /** Canceled order. */
  order: Maybe<Order>;
  /** @deprecated Use `errors` field instead. */
  orderErrors: Array<OrderError>;
};

/** Event sent when order is canceled. */
export type OrderCancelled = Event & {
  __typename: 'OrderCancelled';
  /** Time of the event. */
  issuedAt: Maybe<Scalars['DateTime']>;
  /** The user or application that triggered the event. */
  issuingPrincipal: Maybe<IssuingPrincipal>;
  /** The order the event relates to. */
  order: Maybe<Order>;
  /** The application receiving the webhook. */
  recipient: Maybe<App>;
  /** Saleor version that triggered the event. */
  version: Maybe<Scalars['String']>;
};

/**
 * Capture an order.
 *
 * Requires one of the following permissions: MANAGE_ORDERS.
 */
export type OrderCapture = {
  __typename: 'OrderCapture';
  errors: Array<OrderError>;
  /** Captured order. */
  order: Maybe<Order>;
  /** @deprecated Use `errors` field instead. */
  orderErrors: Array<OrderError>;
};

/**
 * Determine the current charge status for the order.
 *
 *     An order is considered overcharged when the sum of the
 *     transactionItem's charge amounts exceeds the value of
 *     `order.total` - `order.totalGrantedRefund`.
 *     If the sum of the transactionItem's charge amounts equals
 *     `order.total` - `order.totalGrantedRefund`, we consider the order to be fully
 *     charged.
 *     If the sum of the transactionItem's charge amounts covers a part of the
 *     `order.total` - `order.totalGrantedRefund`, we treat the order as partially charged.
 *
 *     NONE - the funds are not charged.
 *     PARTIAL - the funds that are charged don't cover the
 *     `order.total`-`order.totalGrantedRefund`
 *     FULL - the funds that are charged fully cover the
 *     `order.total`-`order.totalGrantedRefund`
 *     OVERCHARGED - the charged funds are bigger than the
 *     `order.total`-`order.totalGrantedRefund`
 */
export type OrderChargeStatusEnum =
  | 'FULL'
  | 'NONE'
  | 'OVERCHARGED'
  | 'PARTIAL';

/** Filter by charge status. */
export type OrderChargeStatusEnumFilterInput = {
  /** The value equal to. */
  eq: InputMaybe<OrderChargeStatusEnum>;
  /** The value included in. */
  oneOf: InputMaybe<Array<OrderChargeStatusEnum>>;
};

/**
 * Confirms an unconfirmed order by changing status to unfulfilled.
 *
 * Requires one of the following permissions: MANAGE_ORDERS.
 */
export type OrderConfirm = {
  __typename: 'OrderConfirm';
  errors: Array<OrderError>;
  /** Order which has been confirmed. */
  order: Maybe<Order>;
  /** @deprecated Use `errors` field instead. */
  orderErrors: Array<OrderError>;
};

/** Event sent when order is confirmed. */
export type OrderConfirmed = Event & {
  __typename: 'OrderConfirmed';
  /** Time of the event. */
  issuedAt: Maybe<Scalars['DateTime']>;
  /** The user or application that triggered the event. */
  issuingPrincipal: Maybe<IssuingPrincipal>;
  /** The order the event relates to. */
  order: Maybe<Order>;
  /** The application receiving the webhook. */
  recipient: Maybe<App>;
  /** Saleor version that triggered the event. */
  version: Maybe<Scalars['String']>;
};

export type OrderCountableConnection = {
  __typename: 'OrderCountableConnection';
  edges: Array<OrderCountableEdge>;
  /** Pagination data for this connection. */
  pageInfo: PageInfo;
  /** A total count of items in the collection. */
  totalCount: Maybe<Scalars['Int']>;
};

export type OrderCountableEdge = {
  __typename: 'OrderCountableEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node: Order;
};

/**
 * Create new order from existing checkout. Requires the following permissions: AUTHENTICATED_APP and HANDLE_CHECKOUTS.
 *
 * Triggers the following webhook events:
 * - SHIPPING_LIST_METHODS_FOR_CHECKOUT (sync): Optionally triggered when cached external shipping methods are invalid.
 * - CHECKOUT_FILTER_SHIPPING_METHODS (sync): Optionally triggered when cached filtered shipping methods are invalid.
 * - CHECKOUT_CALCULATE_TAXES (sync): Optionally triggered when checkout prices are expired.
 * - ORDER_CREATED (async): Triggered when order is created.
 * - NOTIFY_USER (async): A notification for order placement.
 * - NOTIFY_USER (async): A staff notification for order placement.
 * - ORDER_UPDATED (async): Triggered when order received the update after placement.
 * - ORDER_PAID (async): Triggered when newly created order is paid.
 * - ORDER_FULLY_PAID (async): Triggered when newly created order is fully paid.
 * - ORDER_CONFIRMED (async): Optionally triggered when newly created order are automatically marked as confirmed.
 */
export type OrderCreateFromCheckout = {
  __typename: 'OrderCreateFromCheckout';
  errors: Array<OrderCreateFromCheckoutError>;
  /** Placed order. */
  order: Maybe<Order>;
};

export type OrderCreateFromCheckoutError = {
  __typename: 'OrderCreateFromCheckoutError';
  /** The error code. */
  code: OrderCreateFromCheckoutErrorCode;
  /** Name of a field that caused the error. A value of `null` indicates that the error isn't associated with a particular field. */
  field: Maybe<Scalars['String']>;
  /** List of line Ids which cause the error. */
  lines: Maybe<Array<Scalars['ID']>>;
  /** The error message. */
  message: Maybe<Scalars['String']>;
  /** List of variant IDs which causes the error. */
  variants: Maybe<Array<Scalars['ID']>>;
};

export type OrderCreateFromCheckoutErrorCode =
  | 'BILLING_ADDRESS_NOT_SET'
  | 'CHANNEL_INACTIVE'
  | 'CHECKOUT_NOT_FOUND'
  | 'EMAIL_NOT_SET'
  | 'GIFT_CARD_NOT_APPLICABLE'
  | 'GRAPHQL_ERROR'
  | 'INSUFFICIENT_STOCK'
  | 'INVALID_SHIPPING_METHOD'
  | 'NO_LINES'
  | 'SHIPPING_ADDRESS_NOT_SET'
  | 'SHIPPING_METHOD_NOT_SET'
  | 'TAX_ERROR'
  | 'UNAVAILABLE_VARIANT_IN_CHANNEL'
  | 'VOUCHER_NOT_APPLICABLE';

/** Event sent when new order is created. */
export type OrderCreated = Event & {
  __typename: 'OrderCreated';
  /** Time of the event. */
  issuedAt: Maybe<Scalars['DateTime']>;
  /** The user or application that triggered the event. */
  issuingPrincipal: Maybe<IssuingPrincipal>;
  /** The order the event relates to. */
  order: Maybe<Order>;
  /** The application receiving the webhook. */
  recipient: Maybe<App>;
  /** Saleor version that triggered the event. */
  version: Maybe<Scalars['String']>;
};

export type OrderDirection =
  /** Specifies an ascending sort order. */
  | 'ASC'
  /** Specifies a descending sort order. */
  | 'DESC';

/** Contains all details related to the applied discount to the order. */
export type OrderDiscount = Node & {
  __typename: 'OrderDiscount';
  /**
   * Returns amount of discount.
   * @deprecated Use `total` instead.
   */
  amount: Money;
  /** The ID of discount applied. */
  id: Scalars['ID'];
  /** The name of applied discount. */
  name: Maybe<Scalars['String']>;
  /**
   * Explanation for the applied discount.
   *
   * Requires one of the following permissions: MANAGE_ORDERS.
   */
  reason: Maybe<Scalars['String']>;
  /**
   * The amount of discount applied to the order.
   *
   * Added in Saleor 3.21.
   */
  total: Money;
  /** Translated name of the applied discount. */
  translatedName: Maybe<Scalars['String']>;
  /** The type of applied discount: Sale, Voucher or Manual. */
  type: OrderDiscountType;
  /** Value of the discount. Can store fixed value or percent value */
  value: Scalars['PositiveDecimal'];
  /** Type of the discount: fixed or percent */
  valueType: DiscountValueTypeEnum;
};

/**
 * Adds discount to the order.
 *
 * Requires one of the following permissions: MANAGE_ORDERS.
 */
export type OrderDiscountAdd = {
  __typename: 'OrderDiscountAdd';
  errors: Array<OrderError>;
  /** Order which has been discounted. */
  order: Maybe<Order>;
  /** @deprecated Use `errors` field instead. */
  orderErrors: Array<OrderError>;
};

export type OrderDiscountCommonInput = {
  /** Explanation for the applied discount. */
  reason: InputMaybe<Scalars['String']>;
  /** Value of the discount. Can store fixed value or percent value */
  value: Scalars['PositiveDecimal'];
  /** Type of the discount: fixed or percent */
  valueType: DiscountValueTypeEnum;
};

/**
 * Remove discount from the order.
 *
 * Requires one of the following permissions: MANAGE_ORDERS.
 */
export type OrderDiscountDelete = {
  __typename: 'OrderDiscountDelete';
  errors: Array<OrderError>;
  /** Order which has removed discount. */
  order: Maybe<Order>;
  /** @deprecated Use `errors` field instead. */
  orderErrors: Array<OrderError>;
};

export type OrderDiscountType =
  | 'MANUAL'
  | 'ORDER_PROMOTION'
  | 'PROMOTION'
  | 'SALE'
  | 'VOUCHER';

/**
 * Update discount for the order.
 *
 * Requires one of the following permissions: MANAGE_ORDERS.
 */
export type OrderDiscountUpdate = {
  __typename: 'OrderDiscountUpdate';
  errors: Array<OrderError>;
  /** Order which has been discounted. */
  order: Maybe<Order>;
  /** @deprecated Use `errors` field instead. */
  orderErrors: Array<OrderError>;
};

export type OrderDraftFilterInput = {
  channels: InputMaybe<Array<Scalars['ID']>>;
  created: InputMaybe<DateRangeInput>;
  customer: InputMaybe<Scalars['String']>;
  metadata: InputMaybe<Array<MetadataFilter>>;
  search: InputMaybe<Scalars['String']>;
};

export type OrderError = {
  __typename: 'OrderError';
  /** A type of address that causes the error. */
  addressType: Maybe<AddressTypeEnum>;
  /** The error code. */
  code: OrderErrorCode;
  /** Name of a field that caused the error. A value of `null` indicates that the error isn't associated with a particular field. */
  field: Maybe<Scalars['String']>;
  /** The error message. */
  message: Maybe<Scalars['String']>;
  /** List of order line IDs that cause the error. */
  orderLines: Maybe<Array<Scalars['ID']>>;
  /** List of product variants that are associated with the error */
  variants: Maybe<Array<Scalars['ID']>>;
  /** Warehouse ID which causes the error. */
  warehouse: Maybe<Scalars['ID']>;
};

export type OrderErrorCode =
  | 'BILLING_ADDRESS_NOT_SET'
  | 'CANNOT_CANCEL_FULFILLMENT'
  | 'CANNOT_CANCEL_ORDER'
  | 'CANNOT_DELETE'
  | 'CANNOT_DISCOUNT'
  | 'CANNOT_FULFILL_UNPAID_ORDER'
  | 'CANNOT_REFUND'
  | 'CAPTURE_INACTIVE_PAYMENT'
  | 'CHANNEL_INACTIVE'
  | 'DUPLICATED_INPUT_ITEM'
  | 'FULFILL_ORDER_LINE'
  | 'GIFT_CARD_LINE'
  | 'GRAPHQL_ERROR'
  | 'INSUFFICIENT_STOCK'
  | 'INVALID'
  | 'INVALID_QUANTITY'
  | 'INVALID_VOUCHER'
  | 'INVALID_VOUCHER_CODE'
  | 'MISSING_ADDRESS_DATA'
  | 'NON_EDITABLE_GIFT_LINE'
  | 'NON_REMOVABLE_GIFT_LINE'
  | 'NOT_AVAILABLE_IN_CHANNEL'
  | 'NOT_EDITABLE'
  | 'NOT_FOUND'
  | 'ORDER_NO_SHIPPING_ADDRESS'
  | 'PAYMENT_ERROR'
  | 'PAYMENT_MISSING'
  | 'PRODUCT_NOT_PUBLISHED'
  | 'PRODUCT_UNAVAILABLE_FOR_PURCHASE'
  | 'REQUIRED'
  | 'SHIPPING_METHOD_NOT_APPLICABLE'
  | 'SHIPPING_METHOD_REQUIRED'
  | 'TAX_ERROR'
  | 'TRANSACTION_ERROR'
  | 'UNIQUE'
  | 'VOID_INACTIVE_PAYMENT'
  | 'ZERO_QUANTITY';

/** History log of the order. */
export type OrderEvent = Node & {
  __typename: 'OrderEvent';
  /** Amount of money. */
  amount: Maybe<Scalars['Float']>;
  /** App that performed the action. Requires of of the following permissions: MANAGE_APPS, MANAGE_ORDERS, OWNER. */
  app: Maybe<App>;
  /** Composed ID of the Fulfillment. */
  composedId: Maybe<Scalars['String']>;
  /** Date when event happened at in ISO 8601 format. */
  date: Maybe<Scalars['DateTime']>;
  /** The discount applied to the order. */
  discount: Maybe<OrderEventDiscountObject>;
  /** Email of the customer. */
  email: Maybe<Scalars['String']>;
  /** Type of an email sent to the customer. */
  emailType: Maybe<OrderEventsEmailsEnum>;
  /** The lines fulfilled. */
  fulfilledItems: Maybe<Array<FulfillmentLine>>;
  /** ID of the event associated with an order. */
  id: Scalars['ID'];
  /** Number of an invoice related to the order. */
  invoiceNumber: Maybe<Scalars['String']>;
  /** The concerned lines. */
  lines: Maybe<Array<OrderEventOrderLineObject>>;
  /** Content of the event. */
  message: Maybe<Scalars['String']>;
  /** User-friendly number of an order. */
  orderNumber: Maybe<Scalars['String']>;
  /** List of oversold lines names. */
  oversoldItems: Maybe<Array<Scalars['String']>>;
  /** The payment gateway of the payment. */
  paymentGateway: Maybe<Scalars['String']>;
  /** The payment reference from the payment provider. */
  paymentId: Maybe<Scalars['String']>;
  /** Number of items. */
  quantity: Maybe<Scalars['Int']>;
  /** The reference of payment's transaction. */
  reference: Maybe<Scalars['String']>;
  /** The order event which is related to this event. */
  related: Maybe<OrderEvent>;
  /** The order which is related to this order. */
  relatedOrder: Maybe<Order>;
  /** Define if shipping costs were included to the refund. */
  shippingCostsIncluded: Maybe<Scalars['Boolean']>;
  /** The transaction reference of captured payment. */
  transactionReference: Maybe<Scalars['String']>;
  /** Order event type. */
  type: Maybe<OrderEventsEnum>;
  /** User who performed the action. */
  user: Maybe<User>;
  /** The warehouse were items were restocked. */
  warehouse: Maybe<Warehouse>;
};

export type OrderEventCountableConnection = {
  __typename: 'OrderEventCountableConnection';
  edges: Array<OrderEventCountableEdge>;
  /** Pagination data for this connection. */
  pageInfo: PageInfo;
  /** A total count of items in the collection. */
  totalCount: Maybe<Scalars['Int']>;
};

export type OrderEventCountableEdge = {
  __typename: 'OrderEventCountableEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node: OrderEvent;
};

export type OrderEventDiscountObject = {
  __typename: 'OrderEventDiscountObject';
  /** Returns amount of discount. */
  amount: Maybe<Money>;
  /** Returns amount of discount. */
  oldAmount: Maybe<Money>;
  /** Value of the discount. Can store fixed value or percent value. */
  oldValue: Maybe<Scalars['PositiveDecimal']>;
  /** Type of the discount: fixed or percent. */
  oldValueType: Maybe<DiscountValueTypeEnum>;
  /** Explanation for the applied discount. */
  reason: Maybe<Scalars['String']>;
  /** Value of the discount. Can store fixed value or percent value. */
  value: Scalars['PositiveDecimal'];
  /** Type of the discount: fixed or percent. */
  valueType: DiscountValueTypeEnum;
};

/** Filter input for order events data. */
export type OrderEventFilterInput = {
  /** Filter order events by date. */
  date: InputMaybe<DateTimeRangeInput>;
  /** Filter order events by type. */
  type: InputMaybe<OrderEventTypeEnumFilterInput>;
};

export type OrderEventOrderLineObject = {
  __typename: 'OrderEventOrderLineObject';
  /** The discount applied to the order line. */
  discount: Maybe<OrderEventDiscountObject>;
  /** The variant name. */
  itemName: Maybe<Scalars['String']>;
  /** The order line. */
  orderLine: Maybe<OrderLine>;
  /** The variant quantity. */
  quantity: Maybe<Scalars['Int']>;
};

export type OrderEventTypeEnumFilterInput = {
  /** The value equal to. */
  eq: InputMaybe<OrderEventsEnum>;
  /** The value included in. */
  oneOf: InputMaybe<Array<OrderEventsEnum>>;
};

export type OrderEventsEmailsEnum =
  | 'CONFIRMED'
  | 'DIGITAL_LINKS'
  | 'FULFILLMENT_CONFIRMATION'
  | 'ORDER_CANCEL'
  | 'ORDER_CONFIRMATION'
  | 'ORDER_REFUND'
  | 'PAYMENT_CONFIRMATION'
  | 'SHIPPING_CONFIRMATION'
  | 'TRACKING_UPDATED';

/** The different order event types. */
export type OrderEventsEnum =
  | 'ADDED_PRODUCTS'
  | 'CANCELED'
  | 'CONFIRMED'
  | 'DRAFT_CREATED'
  | 'DRAFT_CREATED_FROM_REPLACE'
  | 'EMAIL_SENT'
  | 'EXPIRED'
  | 'EXTERNAL_SERVICE_NOTIFICATION'
  | 'FULFILLMENT_AWAITS_APPROVAL'
  | 'FULFILLMENT_CANCELED'
  | 'FULFILLMENT_FULFILLED_ITEMS'
  | 'FULFILLMENT_REFUNDED'
  | 'FULFILLMENT_REPLACED'
  | 'FULFILLMENT_RESTOCKED_ITEMS'
  | 'FULFILLMENT_RETURNED'
  | 'INVOICE_GENERATED'
  | 'INVOICE_REQUESTED'
  | 'INVOICE_SENT'
  | 'INVOICE_UPDATED'
  | 'NOTE_ADDED'
  | 'NOTE_UPDATED'
  | 'ORDER_DISCOUNT_ADDED'
  | 'ORDER_DISCOUNT_AUTOMATICALLY_UPDATED'
  | 'ORDER_DISCOUNT_DELETED'
  | 'ORDER_DISCOUNT_UPDATED'
  | 'ORDER_FULLY_PAID'
  | 'ORDER_LINE_DISCOUNT_REMOVED'
  | 'ORDER_LINE_DISCOUNT_UPDATED'
  | 'ORDER_LINE_PRODUCT_DELETED'
  | 'ORDER_LINE_VARIANT_DELETED'
  | 'ORDER_MARKED_AS_PAID'
  | 'ORDER_REPLACEMENT_CREATED'
  | 'OTHER'
  | 'OVERSOLD_ITEMS'
  | 'PAYMENT_AUTHORIZED'
  | 'PAYMENT_CAPTURED'
  | 'PAYMENT_FAILED'
  | 'PAYMENT_REFUNDED'
  | 'PAYMENT_VOIDED'
  | 'PLACED'
  | 'PLACED_AUTOMATICALLY_FROM_PAID_CHECKOUT'
  | 'PLACED_FROM_DRAFT'
  | 'REMOVED_PRODUCTS'
  | 'TRACKING_UPDATED'
  | 'TRANSACTION_CANCEL_REQUESTED'
  | 'TRANSACTION_CHARGE_REQUESTED'
  | 'TRANSACTION_EVENT'
  | 'TRANSACTION_MARK_AS_PAID_FAILED'
  | 'TRANSACTION_REFUND_REQUESTED'
  | 'UPDATED_ADDRESS';

/** Event sent when order becomes expired. */
export type OrderExpired = Event & {
  __typename: 'OrderExpired';
  /** Time of the event. */
  issuedAt: Maybe<Scalars['DateTime']>;
  /** The user or application that triggered the event. */
  issuingPrincipal: Maybe<IssuingPrincipal>;
  /** The order the event relates to. */
  order: Maybe<Order>;
  /** The application receiving the webhook. */
  recipient: Maybe<App>;
  /** Saleor version that triggered the event. */
  version: Maybe<Scalars['String']>;
};

export type OrderFilterInput = {
  authorizeStatus: InputMaybe<Array<OrderAuthorizeStatusEnum>>;
  channels: InputMaybe<Array<Scalars['ID']>>;
  chargeStatus: InputMaybe<Array<OrderChargeStatusEnum>>;
  checkoutIds: InputMaybe<Array<Scalars['ID']>>;
  checkoutTokens: InputMaybe<Array<Scalars['UUID']>>;
  created: InputMaybe<DateRangeInput>;
  customer: InputMaybe<Scalars['String']>;
  giftCardBought: InputMaybe<Scalars['Boolean']>;
  giftCardUsed: InputMaybe<Scalars['Boolean']>;
  ids: InputMaybe<Array<Scalars['ID']>>;
  isClickAndCollect: InputMaybe<Scalars['Boolean']>;
  isPreorder: InputMaybe<Scalars['Boolean']>;
  metadata: InputMaybe<Array<MetadataFilter>>;
  numbers: InputMaybe<Array<Scalars['String']>>;
  paymentStatus: InputMaybe<Array<PaymentChargeStatusEnum>>;
  search: InputMaybe<Scalars['String']>;
  status: InputMaybe<Array<OrderStatusFilter>>;
  updatedAt: InputMaybe<DateTimeRangeInput>;
};

/** Filter shipping methods for order. */
export type OrderFilterShippingMethods = Event & {
  __typename: 'OrderFilterShippingMethods';
  /** Time of the event. */
  issuedAt: Maybe<Scalars['DateTime']>;
  /** The user or application that triggered the event. */
  issuingPrincipal: Maybe<IssuingPrincipal>;
  /** The order the event relates to. */
  order: Maybe<Order>;
  /** The application receiving the webhook. */
  recipient: Maybe<App>;
  /** Shipping methods that can be used with this checkout. */
  shippingMethods: Maybe<Array<ShippingMethod>>;
  /** Saleor version that triggered the event. */
  version: Maybe<Scalars['String']>;
};

/**
 * Creates new fulfillments for an order.
 *
 * Requires one of the following permissions: MANAGE_ORDERS.
 *
 * Triggers the following webhook events:
 * - FULFILLMENT_CREATED (async): A new fulfillment is created.
 * - ORDER_FULFILLED (async): Order is fulfilled.
 * - FULFILLMENT_TRACKING_NUMBER_UPDATED (async): Sent when fulfillment tracking number is updated.
 * - FULFILLMENT_APPROVED (async): A fulfillment is approved.
 */
export type OrderFulfill = {
  __typename: 'OrderFulfill';
  errors: Array<OrderError>;
  /** List of created fulfillments. */
  fulfillments: Maybe<Array<Fulfillment>>;
  /** Fulfilled order. */
  order: Maybe<Order>;
  /** @deprecated Use `errors` field instead. */
  orderErrors: Array<OrderError>;
};

export type OrderFulfillInput = {
  /** If true, then allow proceed fulfillment when stock is exceeded. */
  allowStockToBeExceeded: InputMaybe<Scalars['Boolean']>;
  /** List of items informing how to fulfill the order. */
  lines: Array<OrderFulfillLineInput>;
  /** If true, send an email notification to the customer. */
  notifyCustomer: InputMaybe<Scalars['Boolean']>;
  /** Fulfillment tracking number. */
  trackingNumber: InputMaybe<Scalars['String']>;
};

export type OrderFulfillLineInput = {
  /** The ID of the order line. */
  orderLineId: InputMaybe<Scalars['ID']>;
  /** List of stock items to create. */
  stocks: Array<OrderFulfillStockInput>;
};

export type OrderFulfillStockInput = {
  /** The number of line items to be fulfilled from given warehouse. */
  quantity: Scalars['Int'];
  /** ID of the warehouse from which the item will be fulfilled. */
  warehouse: Scalars['ID'];
};

/** Event sent when order is fulfilled. */
export type OrderFulfilled = Event & {
  __typename: 'OrderFulfilled';
  /** Time of the event. */
  issuedAt: Maybe<Scalars['DateTime']>;
  /** The user or application that triggered the event. */
  issuingPrincipal: Maybe<IssuingPrincipal>;
  /** The order the event relates to. */
  order: Maybe<Order>;
  /** The application receiving the webhook. */
  recipient: Maybe<App>;
  /** Saleor version that triggered the event. */
  version: Maybe<Scalars['String']>;
};

/** Event sent when order is fully paid. */
export type OrderFullyPaid = Event & {
  __typename: 'OrderFullyPaid';
  /** Time of the event. */
  issuedAt: Maybe<Scalars['DateTime']>;
  /** The user or application that triggered the event. */
  issuingPrincipal: Maybe<IssuingPrincipal>;
  /** The order the event relates to. */
  order: Maybe<Order>;
  /** The application receiving the webhook. */
  recipient: Maybe<App>;
  /** Saleor version that triggered the event. */
  version: Maybe<Scalars['String']>;
};

/** The order is fully refunded. */
export type OrderFullyRefunded = Event & {
  __typename: 'OrderFullyRefunded';
  /** Time of the event. */
  issuedAt: Maybe<Scalars['DateTime']>;
  /** The user or application that triggered the event. */
  issuingPrincipal: Maybe<IssuingPrincipal>;
  /** The order the event relates to. */
  order: Maybe<Order>;
  /** The application receiving the webhook. */
  recipient: Maybe<App>;
  /** Saleor version that triggered the event. */
  version: Maybe<Scalars['String']>;
};

/**
 * Adds granted refund to the order.
 *
 * Requires one of the following permissions: MANAGE_ORDERS.
 */
export type OrderGrantRefundCreate = {
  __typename: 'OrderGrantRefundCreate';
  errors: Array<OrderGrantRefundCreateError>;
  /** Created granted refund. */
  grantedRefund: Maybe<OrderGrantedRefund>;
  /** Order which has assigned new grant refund. */
  order: Maybe<Order>;
};

export type OrderGrantRefundCreateError = {
  __typename: 'OrderGrantRefundCreateError';
  /** The error code. */
  code: OrderGrantRefundCreateErrorCode;
  /** Name of a field that caused the error. A value of `null` indicates that the error isn't associated with a particular field. */
  field: Maybe<Scalars['String']>;
  /** List of lines which cause the error. */
  lines: Maybe<Array<OrderGrantRefundCreateLineError>>;
  /** The error message. */
  message: Maybe<Scalars['String']>;
};

export type OrderGrantRefundCreateErrorCode =
  | 'AMOUNT_GREATER_THAN_AVAILABLE'
  | 'GRAPHQL_ERROR'
  | 'INVALID'
  | 'NOT_FOUND'
  | 'REQUIRED'
  | 'SHIPPING_COSTS_ALREADY_GRANTED';

export type OrderGrantRefundCreateInput = {
  /** Amount of the granted refund. If not provided, the amount will be calculated automatically based on provided `lines` and `grantRefundForShipping`. */
  amount: InputMaybe<Scalars['Decimal']>;
  /** Determine if granted refund should include shipping costs. */
  grantRefundForShipping: InputMaybe<Scalars['Boolean']>;
  /** Lines to assign to granted refund. */
  lines: InputMaybe<Array<OrderGrantRefundCreateLineInput>>;
  /** Reason of the granted refund. */
  reason: InputMaybe<Scalars['String']>;
  /**
   * ID of a `Page` (Model) to reference in reason.
   *
   * Added in Saleor 3.22.
   */
  reasonReference: InputMaybe<Scalars['ID']>;
  /**
   * The ID of the transaction item related to the granted refund. If `amount` provided in the input, the transaction.chargedAmount needs to be equal or greater than provided `amount`.If `amount` is not provided in the input and calculated automatically by Saleor, the `min(calculatedAmount, transaction.chargedAmount)` will be used. Field required starting from Saleor 3.21.
   *
   * Added in Saleor 3.20.
   *
   * Note: this API is currently in Feature Preview and can be subject to changes at later point.
   */
  transactionId: Scalars['ID'];
};

export type OrderGrantRefundCreateLineError = {
  __typename: 'OrderGrantRefundCreateLineError';
  /** The error code. */
  code: OrderGrantRefundCreateLineErrorCode;
  /** Name of a field that caused the error. A value of `null` indicates that the error isn't associated with a particular field. */
  field: Maybe<Scalars['String']>;
  /** The ID of the line related to the error. */
  lineId: Scalars['ID'];
  /** The error message. */
  message: Maybe<Scalars['String']>;
};

export type OrderGrantRefundCreateLineErrorCode =
  | 'GRAPHQL_ERROR'
  | 'NOT_FOUND'
  | 'QUANTITY_GREATER_THAN_AVAILABLE';

export type OrderGrantRefundCreateLineInput = {
  /** The ID of the order line. */
  id: Scalars['ID'];
  /** The quantity of line items to be marked to refund. */
  quantity: Scalars['Int'];
  /** Reason of the granted refund for the line. */
  reason: InputMaybe<Scalars['String']>;
};

/**
 * Updates granted refund.
 *
 * Requires one of the following permissions: MANAGE_ORDERS.
 */
export type OrderGrantRefundUpdate = {
  __typename: 'OrderGrantRefundUpdate';
  errors: Array<OrderGrantRefundUpdateError>;
  /** Created granted refund. */
  grantedRefund: Maybe<OrderGrantedRefund>;
  /** Order which has assigned updated grant refund. */
  order: Maybe<Order>;
};

export type OrderGrantRefundUpdateError = {
  __typename: 'OrderGrantRefundUpdateError';
  /** List of lines to add which cause the error. */
  addLines: Maybe<Array<OrderGrantRefundUpdateLineError>>;
  /** The error code. */
  code: OrderGrantRefundUpdateErrorCode;
  /** Name of a field that caused the error. A value of `null` indicates that the error isn't associated with a particular field. */
  field: Maybe<Scalars['String']>;
  /** The error message. */
  message: Maybe<Scalars['String']>;
  /** List of lines to remove which cause the error. */
  removeLines: Maybe<Array<OrderGrantRefundUpdateLineError>>;
};

export type OrderGrantRefundUpdateErrorCode =
  | 'AMOUNT_GREATER_THAN_AVAILABLE'
  | 'GRAPHQL_ERROR'
  | 'INVALID'
  | 'NOT_FOUND'
  | 'REQUIRED'
  | 'SHIPPING_COSTS_ALREADY_GRANTED';

export type OrderGrantRefundUpdateInput = {
  /** Lines to assign to granted refund. */
  addLines: InputMaybe<Array<OrderGrantRefundUpdateLineAddInput>>;
  /** Amount of the granted refund. if not provided and `addLines` or `removeLines` or `grantRefundForShipping` is provided, amount will be calculated automatically. */
  amount: InputMaybe<Scalars['Decimal']>;
  /** Determine if granted refund should include shipping costs. */
  grantRefundForShipping: InputMaybe<Scalars['Boolean']>;
  /** Reason of the granted refund. */
  reason: InputMaybe<Scalars['String']>;
  /**
   * ID of a `Page` (Model) to reference in reason.
   *
   * Added in Saleor 3.22.
   */
  reasonReference: InputMaybe<Scalars['ID']>;
  /** Lines to remove from granted refund. */
  removeLines: InputMaybe<Array<Scalars['ID']>>;
  /**
   * The ID of the transaction item related to the granted refund. If `amount` provided in the input, the transaction.chargedAmount needs to be equal or greater than provided `amount`.If `amount` is not provided in the input and calculated automatically by Saleor, the `min(calculatedAmount, transaction.chargedAmount)` will be used.Field will be required starting from Saleor 3.21.
   *
   * Added in Saleor 3.20.
   *
   * Note: this API is currently in Feature Preview and can be subject to changes at later point.
   */
  transactionId: InputMaybe<Scalars['ID']>;
};

export type OrderGrantRefundUpdateLineAddInput = {
  /** The ID of the order line. */
  id: Scalars['ID'];
  /** The quantity of line items to be marked to refund. */
  quantity: Scalars['Int'];
  /** Reason of the granted refund for the line. */
  reason: InputMaybe<Scalars['String']>;
};

export type OrderGrantRefundUpdateLineError = {
  __typename: 'OrderGrantRefundUpdateLineError';
  /** The error code. */
  code: OrderGrantRefundUpdateLineErrorCode;
  /** Name of a field that caused the error. A value of `null` indicates that the error isn't associated with a particular field. */
  field: Maybe<Scalars['String']>;
  /** The ID of the line related to the error. */
  lineId: Scalars['ID'];
  /** The error message. */
  message: Maybe<Scalars['String']>;
};

export type OrderGrantRefundUpdateLineErrorCode =
  | 'GRAPHQL_ERROR'
  | 'NOT_FOUND'
  | 'QUANTITY_GREATER_THAN_AVAILABLE';

/** The details of granted refund. */
export type OrderGrantedRefund = {
  __typename: 'OrderGrantedRefund';
  /** Refund amount. */
  amount: Money;
  /** App that performed the action. */
  app: Maybe<App>;
  /** Time of creation. */
  createdAt: Scalars['DateTime'];
  id: Scalars['ID'];
  /** Lines assigned to the granted refund. */
  lines: Maybe<Array<OrderGrantedRefundLine>>;
  /**
   * Reason of the refund.
   *
   * Added in Saleor 3.22.
   */
  reason: Maybe<Scalars['String']>;
  /**
   * Reason Model (Page) reference for refund.
   *
   * Added in Saleor 3.22.
   */
  reasonReference: Maybe<Page>;
  /** If true, the refunded amount includes the shipping price.If false, the refunded amount does not include the shipping price. */
  shippingCostsIncluded: Scalars['Boolean'];
  /**
   * Status of the granted refund calculated based on transactionItem assigned to granted refund.
   *
   * Added in Saleor 3.20.
   */
  status: OrderGrantedRefundStatusEnum;
  /**
   * The transaction assigned to the granted refund.
   *
   * Added in Saleor 3.20.
   */
  transaction: Maybe<TransactionItem>;
  /**
   * List of refund events associated with the granted refund.
   *
   * Added in Saleor 3.20.
   */
  transactionEvents: Maybe<Array<TransactionEvent>>;
  /** Time of last update. */
  updatedAt: Scalars['DateTime'];
  /** User who performed the action. Requires of of the following permissions: MANAGE_USERS, MANAGE_STAFF, OWNER. */
  user: Maybe<User>;
};

/** Represents granted refund line. */
export type OrderGrantedRefundLine = {
  __typename: 'OrderGrantedRefundLine';
  id: Scalars['ID'];
  /** Line of the order associated with this granted refund. */
  orderLine: OrderLine;
  /** Number of items to refund. */
  quantity: Scalars['Int'];
  /** Reason for refunding the line. */
  reason: Maybe<Scalars['String']>;
};

/**
 * Represents the status of a granted refund.
 *
 *     NONE - the refund on related transactionItem is not processed
 *     PENDING - the refund on related transactionItem is pending
 *     FULL - the refund on related transactionItem is fully processed
 *     FAIL - the refund on related transactionItem failed
 */
export type OrderGrantedRefundStatusEnum =
  | 'FAILURE'
  | 'NONE'
  | 'PENDING'
  | 'SUCCESS';

/** Represents order line of particular order. */
export type OrderLine = Node & ObjectWithMetadata & {
  __typename: 'OrderLine';
  /**
   * List of allocations across warehouses.
   *
   * Requires one of the following permissions: MANAGE_PRODUCTS, MANAGE_ORDERS.
   */
  allocations: Maybe<Array<Allocation>>;
  digitalContentUrl: Maybe<DigitalContentUrl>;
  /**
   * List of applied discounts
   *
   * Added in Saleor 3.21.
   */
  discounts: Maybe<Array<OrderLineDiscount>>;
  /** ID of the order line. */
  id: Scalars['ID'];
  /**
   * Determine if the line is a gift.
   *
   * Added in Saleor 3.19.
   *
   * Note: this API is currently in Feature Preview and can be subject to changes at later point.
   */
  isGift: Maybe<Scalars['Boolean']>;
  /** Returns True, if the line unit price was overridden. */
  isPriceOverridden: Maybe<Scalars['Boolean']>;
  /** Whether the product variant requires shipping. */
  isShippingRequired: Scalars['Boolean'];
  /** List of public metadata items. Can be accessed without permissions. */
  metadata: Array<MetadataItem>;
  /**
   * A single key from public metadata.
   *
   * Tip: Use GraphQL aliases to fetch multiple keys.
   */
  metafield: Maybe<Scalars['String']>;
  /** Public metadata. Use `keys` to control which fields you want to include. The default is to include everything. */
  metafields: Maybe<Scalars['Metadata']>;
  /** List of private metadata items. Requires staff permissions to access. */
  privateMetadata: Array<MetadataItem>;
  /**
   * A single key from private metadata. Requires staff permissions to access.
   *
   * Tip: Use GraphQL aliases to fetch multiple keys.
   */
  privateMetafield: Maybe<Scalars['String']>;
  /** Private metadata. Requires staff permissions to access. Use `keys` to control which fields you want to include. The default is to include everything. */
  privateMetafields: Maybe<Scalars['Metadata']>;
  /** Name of the product in order line. */
  productName: Scalars['String'];
  /** SKU of the product variant. */
  productSku: Maybe<Scalars['String']>;
  /** The ID of the product variant. */
  productVariantId: Maybe<Scalars['String']>;
  /** Number of variant items ordered. */
  quantity: Scalars['Int'];
  /** Number of variant items fulfilled. */
  quantityFulfilled: Scalars['Int'];
  /** A quantity of items remaining to be fulfilled. */
  quantityToFulfill: Scalars['Int'];
  /** Denormalized sale ID, set when order line is created for a product variant that is on sale. */
  saleId: Maybe<Scalars['ID']>;
  /**
   * Denormalized tax class of the product in this order line.
   *
   * Requires one of the following permissions: AUTHENTICATED_STAFF_USER, AUTHENTICATED_APP.
   */
  taxClass: Maybe<TaxClass>;
  /** Denormalized public metadata of the tax class. */
  taxClassMetadata: Array<MetadataItem>;
  /** Denormalized name of the tax class. */
  taxClassName: Maybe<Scalars['String']>;
  /** Denormalized private metadata of the tax class. Requires staff permissions to access. */
  taxClassPrivateMetadata: Array<MetadataItem>;
  /** Rate of tax applied on product variant. */
  taxRate: Scalars['Float'];
  thumbnail: Maybe<Image>;
  /** Price of the order line. */
  totalPrice: TaxedMoney;
  /** Product name in the customer's language */
  translatedProductName: Scalars['String'];
  /** Variant name in the customer's language */
  translatedVariantName: Scalars['String'];
  /** Price of the order line without discounts. */
  undiscountedTotalPrice: TaxedMoney;
  /** Price of the single item in the order line without any discount applied. */
  undiscountedUnitPrice: TaxedMoney;
  /** Sum of the line-level discounts applied to the order line. Order-level discounts which affect the line are not visible in this field. For order-level discount portion (if any), please query `order.discounts` field. */
  unitDiscount: Money;
  /** Reason for line-level discounts applied on the order line. Order-level discounts which affect the line are not visible in this field. For order-level discount reason (if any), please query `order.discounts` field. */
  unitDiscountReason: Maybe<Scalars['String']>;
  /** Type of the discount: `fixed` or `percent`. This field shouldn't be used when multiple discounts affect the line. There is a limitation, that after running `checkoutComplete` mutation the field is always set to `fixed`. */
  unitDiscountType: Maybe<DiscountValueTypeEnum>;
  /** Value of the discount. Can store fixed value or percent value. This field shouldn't be used when multiple discounts affect the line. There is a limitation, that after running `checkoutComplete` mutation the field always stores fixed value. */
  unitDiscountValue: Scalars['PositiveDecimal'];
  /** Price of the single item in the order line with all the line-level discounts and order-level discount portions applied. */
  unitPrice: TaxedMoney;
  /** A purchased product variant. Note: this field may be null if the variant has been removed from stock at all. Requires one of the following permissions to include the unpublished items: MANAGE_ORDERS, MANAGE_DISCOUNTS, MANAGE_PRODUCTS. */
  variant: Maybe<ProductVariant>;
  /** Name of the variant of product in order line. */
  variantName: Scalars['String'];
  /** Voucher code that was used for this order line. */
  voucherCode: Maybe<Scalars['String']>;
};


/** Represents order line of particular order. */
export type OrderLineMetafieldArgs = {
  key: Scalars['String'];
};


/** Represents order line of particular order. */
export type OrderLineMetafieldsArgs = {
  keys: InputMaybe<Array<Scalars['String']>>;
};


/** Represents order line of particular order. */
export type OrderLinePrivateMetafieldArgs = {
  key: Scalars['String'];
};


/** Represents order line of particular order. */
export type OrderLinePrivateMetafieldsArgs = {
  keys: InputMaybe<Array<Scalars['String']>>;
};


/** Represents order line of particular order. */
export type OrderLineThumbnailArgs = {
  format?: InputMaybe<ThumbnailFormatEnum>;
  size: InputMaybe<Scalars['Int']>;
};

export type OrderLineCreateInput = {
  /** Flag that allow force splitting the same variant into multiple lines by skipping the matching logic. */
  forceNewLine: InputMaybe<Scalars['Boolean']>;
  /** Custom price of the item.When the line with the same variant will be provided multiple times, the last price will be used. */
  price: InputMaybe<Scalars['PositiveDecimal']>;
  /** Number of variant items ordered. */
  quantity: Scalars['Int'];
  /** Product variant ID. */
  variantId: Scalars['ID'];
};

/**
 * Deletes an order line from an order.
 *
 * Requires one of the following permissions: MANAGE_ORDERS.
 */
export type OrderLineDelete = {
  __typename: 'OrderLineDelete';
  errors: Array<OrderError>;
  /** A related order. */
  order: Maybe<Order>;
  /** @deprecated Use `errors` field instead. */
  orderErrors: Array<OrderError>;
  /** An order line that was deleted. */
  orderLine: Maybe<OrderLine>;
};

/** Represent the discount applied to order line. */
export type OrderLineDiscount = {
  __typename: 'OrderLineDiscount';
  /** The ID of discount applied. */
  id: Scalars['ID'];
  /** The name of applied discount. */
  name: Maybe<Scalars['String']>;
  /**
   * Explanation for the applied discount.
   *
   * Requires one of the following permissions: MANAGE_ORDERS.
   */
  reason: Maybe<Scalars['String']>;
  /** The discount amount applied to the line item. */
  total: Money;
  /** Translated name of the applied discount. */
  translatedName: Maybe<Scalars['String']>;
  /** The type of applied discount: Sale, Voucher or Manual. */
  type: OrderDiscountType;
  /** The discount amount applied to the single line unit. */
  unit: Money;
  /** Value of the discount. Can store fixed value or percent value */
  value: Scalars['PositiveDecimal'];
  /** Type of the discount: fixed or percent */
  valueType: DiscountValueTypeEnum;
};

/**
 * Remove discount applied to the order line.
 *
 * Requires one of the following permissions: MANAGE_ORDERS.
 */
export type OrderLineDiscountRemove = {
  __typename: 'OrderLineDiscountRemove';
  errors: Array<OrderError>;
  /** Order which is related to line which has removed discount. */
  order: Maybe<Order>;
  /** @deprecated Use `errors` field instead. */
  orderErrors: Array<OrderError>;
  /** Order line which has removed discount. */
  orderLine: Maybe<OrderLine>;
};

/**
 * Update discount for the order line.
 *
 * Requires one of the following permissions: MANAGE_ORDERS.
 */
export type OrderLineDiscountUpdate = {
  __typename: 'OrderLineDiscountUpdate';
  errors: Array<OrderError>;
  /** Order which is related to the discounted line. */
  order: Maybe<Order>;
  /** @deprecated Use `errors` field instead. */
  orderErrors: Array<OrderError>;
  /** Order line which has been discounted. */
  orderLine: Maybe<OrderLine>;
};

export type OrderLineInput = {
  /** Number of variant items ordered. */
  quantity: Scalars['Int'];
};

/**
 * Updates an order line of an order.
 *
 * Requires one of the following permissions: MANAGE_ORDERS.
 */
export type OrderLineUpdate = {
  __typename: 'OrderLineUpdate';
  errors: Array<OrderError>;
  /** Related order. */
  order: Maybe<Order>;
  /** @deprecated Use `errors` field instead. */
  orderErrors: Array<OrderError>;
  orderLine: Maybe<OrderLine>;
};

/**
 * Creates order lines for an order.
 *
 * Requires one of the following permissions: MANAGE_ORDERS.
 */
export type OrderLinesCreate = {
  __typename: 'OrderLinesCreate';
  errors: Array<OrderError>;
  /** Related order. */
  order: Maybe<Order>;
  /** @deprecated Use `errors` field instead. */
  orderErrors: Array<OrderError>;
  /** List of added order lines. */
  orderLines: Maybe<Array<OrderLine>>;
};

/**
 * Mark order as manually paid.
 *
 * Requires one of the following permissions: MANAGE_ORDERS.
 */
export type OrderMarkAsPaid = {
  __typename: 'OrderMarkAsPaid';
  errors: Array<OrderError>;
  /** Order marked as paid. */
  order: Maybe<Order>;
  /** @deprecated Use `errors` field instead. */
  orderErrors: Array<OrderError>;
};

/** Event sent when order metadata is updated. */
export type OrderMetadataUpdated = Event & {
  __typename: 'OrderMetadataUpdated';
  /** Time of the event. */
  issuedAt: Maybe<Scalars['DateTime']>;
  /** The user or application that triggered the event. */
  issuingPrincipal: Maybe<IssuingPrincipal>;
  /** The order the event relates to. */
  order: Maybe<Order>;
  /** The application receiving the webhook. */
  recipient: Maybe<App>;
  /** Saleor version that triggered the event. */
  version: Maybe<Scalars['String']>;
};

/**
 * Adds note to the order.
 *
 * Requires one of the following permissions: MANAGE_ORDERS.
 */
export type OrderNoteAdd = {
  __typename: 'OrderNoteAdd';
  errors: Array<OrderNoteAddError>;
  /** Order note created. */
  event: Maybe<OrderEvent>;
  /** Order with the note added. */
  order: Maybe<Order>;
};

export type OrderNoteAddError = {
  __typename: 'OrderNoteAddError';
  /** The error code. */
  code: Maybe<OrderNoteAddErrorCode>;
  /** Name of a field that caused the error. A value of `null` indicates that the error isn't associated with a particular field. */
  field: Maybe<Scalars['String']>;
  /** The error message. */
  message: Maybe<Scalars['String']>;
};

export type OrderNoteAddErrorCode =
  | 'GRAPHQL_ERROR'
  | 'REQUIRED';

export type OrderNoteInput = {
  /** Note message. */
  message: Scalars['String'];
};

/**
 * Updates note of an order.
 *
 * Requires one of the following permissions: MANAGE_ORDERS.
 */
export type OrderNoteUpdate = {
  __typename: 'OrderNoteUpdate';
  errors: Array<OrderNoteUpdateError>;
  /** Order note updated. */
  event: Maybe<OrderEvent>;
  /** Order with the note updated. */
  order: Maybe<Order>;
};

export type OrderNoteUpdateError = {
  __typename: 'OrderNoteUpdateError';
  /** The error code. */
  code: Maybe<OrderNoteUpdateErrorCode>;
  /** Name of a field that caused the error. A value of `null` indicates that the error isn't associated with a particular field. */
  field: Maybe<Scalars['String']>;
  /** The error message. */
  message: Maybe<Scalars['String']>;
};

export type OrderNoteUpdateErrorCode =
  | 'GRAPHQL_ERROR'
  | 'NOT_FOUND'
  | 'REQUIRED';

export type OrderOrCheckout = Checkout | Order;

export type OrderOriginEnum =
  | 'BULK_CREATE'
  | 'CHECKOUT'
  | 'DRAFT'
  | 'REISSUE';

/** Payment has been made. The order may be partially or fully paid. */
export type OrderPaid = Event & {
  __typename: 'OrderPaid';
  /** Time of the event. */
  issuedAt: Maybe<Scalars['DateTime']>;
  /** The user or application that triggered the event. */
  issuingPrincipal: Maybe<IssuingPrincipal>;
  /** The order the event relates to. */
  order: Maybe<Order>;
  /** The application receiving the webhook. */
  recipient: Maybe<App>;
  /** Saleor version that triggered the event. */
  version: Maybe<Scalars['String']>;
};

export type OrderPredicateInput = {
  /** List of conditions that must be met. */
  AND: InputMaybe<Array<OrderPredicateInput>>;
  /** A list of conditions of which at least one must be met. */
  OR: InputMaybe<Array<OrderPredicateInput>>;
  /** Defines the conditions related to checkout and order objects. */
  discountedObjectPredicate: InputMaybe<DiscountedObjectWhereInput>;
};

/**
 * Refund an order.
 *
 * Requires one of the following permissions: MANAGE_ORDERS.
 */
export type OrderRefund = {
  __typename: 'OrderRefund';
  errors: Array<OrderError>;
  /** A refunded order. */
  order: Maybe<Order>;
  /** @deprecated Use `errors` field instead. */
  orderErrors: Array<OrderError>;
};

export type OrderRefundFulfillmentLineInput = {
  /** The ID of the fulfillment line to refund. */
  fulfillmentLineId: Scalars['ID'];
  /** The number of items to be refunded. */
  quantity: Scalars['Int'];
};

export type OrderRefundLineInput = {
  /** The ID of the order line to refund. */
  orderLineId: Scalars['ID'];
  /** The number of items to be refunded. */
  quantity: Scalars['Int'];
};

export type OrderRefundProductsInput = {
  /** The total amount of refund when the value is provided manually. */
  amountToRefund: InputMaybe<Scalars['PositiveDecimal']>;
  /** List of fulfilled lines to refund. */
  fulfillmentLines: InputMaybe<Array<OrderRefundFulfillmentLineInput>>;
  /** If true, Saleor will refund shipping costs. If amountToRefund is providedincludeShippingCosts will be ignored. */
  includeShippingCosts: InputMaybe<Scalars['Boolean']>;
  /** List of unfulfilled lines to refund. */
  orderLines: InputMaybe<Array<OrderRefundLineInput>>;
};

/** The order received a refund. The order may be partially or fully refunded. */
export type OrderRefunded = Event & {
  __typename: 'OrderRefunded';
  /** Time of the event. */
  issuedAt: Maybe<Scalars['DateTime']>;
  /** The user or application that triggered the event. */
  issuingPrincipal: Maybe<IssuingPrincipal>;
  /** The order the event relates to. */
  order: Maybe<Order>;
  /** The application receiving the webhook. */
  recipient: Maybe<App>;
  /** Saleor version that triggered the event. */
  version: Maybe<Scalars['String']>;
};

export type OrderReturnFulfillmentLineInput = {
  /** The ID of the fulfillment line to return. */
  fulfillmentLineId: Scalars['ID'];
  /** The number of items to be returned. */
  quantity: Scalars['Int'];
  /** Determines, if the line should be added to replace order. */
  replace: InputMaybe<Scalars['Boolean']>;
};

export type OrderReturnLineInput = {
  /** The ID of the order line to return. */
  orderLineId: Scalars['ID'];
  /** The number of items to be returned. */
  quantity: Scalars['Int'];
  /** Determines, if the line should be added to replace order. */
  replace: InputMaybe<Scalars['Boolean']>;
};

export type OrderReturnProductsInput = {
  /** The total amount of refund when the value is provided manually. */
  amountToRefund: InputMaybe<Scalars['PositiveDecimal']>;
  /** List of fulfilled lines to return. */
  fulfillmentLines: InputMaybe<Array<OrderReturnFulfillmentLineInput>>;
  /** If true, Saleor will refund shipping costs. If amountToRefund is providedincludeShippingCosts will be ignored. */
  includeShippingCosts: InputMaybe<Scalars['Boolean']>;
  /** List of unfulfilled lines to return. */
  orderLines: InputMaybe<Array<OrderReturnLineInput>>;
  /** If true, Saleor will call refund action for all lines. */
  refund: InputMaybe<Scalars['Boolean']>;
};

/** Represents the channel-specific order settings. */
export type OrderSettings = {
  __typename: 'OrderSettings';
  /** Determine if it is possible to place unpaid order by calling `checkoutComplete` mutation. */
  allowUnpaidOrders: Scalars['Boolean'];
  /** When disabled, all new orders from checkout will be marked as unconfirmed. When enabled orders from checkout will become unfulfilled immediately. */
  automaticallyConfirmAllNewOrders: Scalars['Boolean'];
  /** When enabled, all non-shippable gift card orders will be fulfilled automatically. */
  automaticallyFulfillNonShippableGiftCard: Scalars['Boolean'];
  /** The time in days after expired orders will be deleted. */
  deleteExpiredOrdersAfter: Scalars['Day'];
  /**
   * Time in hours after which the draft order line price will be refreshed.
   *
   * Added in Saleor 3.21.
   *
   * Note: this API is currently in Feature Preview and can be subject to changes at later point.
   */
  draftOrderLinePriceFreezePeriod: Maybe<Scalars['Hour']>;
  /** Expiration time in minutes. Default null - means do not expire any orders. */
  expireOrdersAfter: Maybe<Scalars['Minute']>;
  /**
   * Determine if voucher applied on draft order should be count toward voucher usage.
   *
   * Added in Saleor 3.18.
   *
   * Note: this API is currently in Feature Preview and can be subject to changes at later point.
   */
  includeDraftOrderInVoucherUsage: Scalars['Boolean'];
  /**
   * Determine what strategy will be used to mark the order as paid. Based on the chosen option, the proper object will be created and attached to the order when it's manually marked as paid.
   * `PAYMENT_FLOW` - [default option] creates the `Payment` object.
   * `TRANSACTION_FLOW` - creates the `TransactionItem` object.
   */
  markAsPaidStrategy: MarkAsPaidStrategyEnum;
  /**
   * This flag only affects orders created from checkout and applies specifically to vouchers of the types: `SPECIFIC_PRODUCT` and `ENTIRE_ORDER` with `applyOncePerOrder` enabled.
   * - When legacy propagation is enabled, discounts from these vouchers are represented as `OrderDiscount` objects, attached to the order and returned in the `Order.discounts` field. Additionally, percentage-based vouchers are converted to fixed-value discounts.
   * - When legacy propagation is disabled, discounts are represented as `OrderLineDiscount` objects, attached to individual lines and returned in the `OrderLine.discounts` field. In this case, percentage-based vouchers retain their original type.
   * In future releases, `OrderLineDiscount` will become the default behavior, and this flag will be deprecated and removed.
   *
   * Added in Saleor 3.21.
   */
  useLegacyLineDiscountPropagation: Scalars['Boolean'];
};

export type OrderSettingsError = {
  __typename: 'OrderSettingsError';
  /** The error code. */
  code: OrderSettingsErrorCode;
  /** Name of a field that caused the error. A value of `null` indicates that the error isn't associated with a particular field. */
  field: Maybe<Scalars['String']>;
  /** The error message. */
  message: Maybe<Scalars['String']>;
};

export type OrderSettingsErrorCode =
  | 'INVALID';

export type OrderSettingsInput = {
  /** Determine if it is possible to place unpaid order by calling `checkoutComplete` mutation. */
  allowUnpaidOrders: InputMaybe<Scalars['Boolean']>;
  /** When disabled, all new orders from checkout will be marked as unconfirmed. When enabled orders from checkout will become unfulfilled immediately. By default set to True */
  automaticallyConfirmAllNewOrders: InputMaybe<Scalars['Boolean']>;
  /** When enabled, all non-shippable gift card orders will be fulfilled automatically. By default set to True. */
  automaticallyFulfillNonShippableGiftCard: InputMaybe<Scalars['Boolean']>;
  /** The time in days after expired orders will be deleted.Allowed range is from 1 to 120. */
  deleteExpiredOrdersAfter: InputMaybe<Scalars['Day']>;
  /**
   * Time in hours after which the draft order line price will be refreshed. Default value is 24 hours. Enter 0 or null to disable.
   *
   * Added in Saleor 3.21.
   *
   * Note: this API is currently in Feature Preview and can be subject to changes at later point.
   */
  draftOrderLinePriceFreezePeriod: InputMaybe<Scalars['Hour']>;
  /** Expiration time in minutes. Default null - means do not expire any orders. Enter 0 or null to disable. */
  expireOrdersAfter: InputMaybe<Scalars['Minute']>;
  /**
   * Specify whether a coupon applied to draft orders will count toward voucher usage.
   *
   * Warning:  when switching this setting from `false` to `true`, the vouchers will be disconnected from all draft orders.
   *
   * Added in Saleor 3.18.
   *
   * Note: this API is currently in Feature Preview and can be subject to changes at later point.
   */
  includeDraftOrderInVoucherUsage: InputMaybe<Scalars['Boolean']>;
  /**
   * Determine what strategy will be used to mark the order as paid. Based on the chosen option, the proper object will be created and attached to the order when it's manually marked as paid.
   * `PAYMENT_FLOW` - [default option] creates the `Payment` object.
   * `TRANSACTION_FLOW` - creates the `TransactionItem` object.
   */
  markAsPaidStrategy: InputMaybe<MarkAsPaidStrategyEnum>;
  /**
   * This flag only affects orders created from checkout and applies specifically to vouchers of the types: `SPECIFIC_PRODUCT` and `ENTIRE_ORDER` with `applyOncePerOrder` enabled.
   * - When legacy propagation is enabled, discounts from these vouchers are represented as `OrderDiscount` objects, attached to the order and returned in the `Order.discounts` field. Additionally, percentage-based vouchers are converted to fixed-value discounts.
   * - When legacy propagation is disabled, discounts are represented as `OrderLineDiscount` objects, attached to individual lines and returned in the `OrderLine.discounts` field. In this case, percentage-based vouchers retain their original type.
   * In future releases, `OrderLineDiscount` will become the default behavior, and this flag will be deprecated and removed.
   *
   * Added in Saleor 3.21.
   */
  useLegacyLineDiscountPropagation: InputMaybe<Scalars['Boolean']>;
};

/**
 * Update shop order settings across all channels. Returns `orderSettings` for the first `channel` in alphabetical order.
 *
 * Requires one of the following permissions: MANAGE_ORDERS.
 */
export type OrderSettingsUpdate = {
  __typename: 'OrderSettingsUpdate';
  errors: Array<OrderSettingsError>;
  /** Order settings. */
  orderSettings: Maybe<OrderSettings>;
  /** @deprecated Use `errors` field instead. */
  orderSettingsErrors: Array<OrderSettingsError>;
};

export type OrderSettingsUpdateInput = {
  /** When disabled, all new orders from checkout will be marked as unconfirmed. When enabled orders from checkout will become unfulfilled immediately. By default set to True */
  automaticallyConfirmAllNewOrders: InputMaybe<Scalars['Boolean']>;
  /** When enabled, all non-shippable gift card orders will be fulfilled automatically. By default set to True. */
  automaticallyFulfillNonShippableGiftCard: InputMaybe<Scalars['Boolean']>;
};

export type OrderSortField =
  /** Sort orders by creation date. */
  | 'CREATED_AT'
  /** Sort orders by creation date */
  | 'CREATION_DATE'
  /** Sort orders by customer. */
  | 'CUSTOMER'
  /** Sort orders by fulfillment status. */
  | 'FULFILLMENT_STATUS'
  /** Sort orders by last modified date. */
  | 'LAST_MODIFIED_AT'
  /** Sort orders by number. */
  | 'NUMBER'
  /** Sort orders by payment status. */
  | 'PAYMENT'
  /** Sort orders by rank. Note: This option is available only with the `search` filter. */
  | 'RANK'
  /**
   * Sort orders by order status.
   *
   * Added in Saleor 3.22.
   */
  | 'STATUS';

export type OrderSortingInput = {
  /** Specifies the direction in which to sort orders. */
  direction: OrderDirection;
  /** Sort orders by the selected field. */
  field: OrderSortField;
};

export type OrderStatus =
  | 'CANCELED'
  | 'DRAFT'
  | 'EXPIRED'
  | 'FULFILLED'
  | 'PARTIALLY_FULFILLED'
  | 'PARTIALLY_RETURNED'
  | 'RETURNED'
  | 'UNCONFIRMED'
  | 'UNFULFILLED';

/** Filter by order status. */
export type OrderStatusEnumFilterInput = {
  /** The value equal to. */
  eq: InputMaybe<OrderStatus>;
  /** The value included in. */
  oneOf: InputMaybe<Array<OrderStatus>>;
};

export type OrderStatusFilter =
  | 'CANCELED'
  | 'FULFILLED'
  | 'PARTIALLY_FULFILLED'
  | 'READY_TO_CAPTURE'
  | 'READY_TO_FULFILL'
  | 'UNCONFIRMED'
  | 'UNFULFILLED';

/**
 * Updates an order.
 *
 * Requires one of the following permissions: MANAGE_ORDERS.
 */
export type OrderUpdate = {
  __typename: 'OrderUpdate';
  errors: Array<OrderError>;
  order: Maybe<Order>;
  /** @deprecated Use `errors` field instead. */
  orderErrors: Array<OrderError>;
};

export type OrderUpdateInput = {
  /** Billing address of the customer. */
  billingAddress: InputMaybe<AddressInput>;
  /** External ID of this order. */
  externalReference: InputMaybe<Scalars['String']>;
  /**
   * Order language code.
   *
   * Added in Saleor 3.21.
   */
  languageCode: InputMaybe<LanguageCodeEnum>;
  /**
   * Order public metadata.
   *
   * Added in Saleor 3.21.Can be read by any API client authorized to read the object it's attached to.
   *
   * Warning: never store sensitive information, including financial data such as credit card details.
   */
  metadata: InputMaybe<Array<MetadataInput>>;
  /**
   * Order private metadata.
   *
   * Added in Saleor 3.21.Requires permissions to modify and to read the metadata of the object it's attached to.
   *
   * Warning: never store sensitive information, including financial data such as credit card details.
   */
  privateMetadata: InputMaybe<Array<MetadataInput>>;
  /** Shipping address of the customer. */
  shippingAddress: InputMaybe<AddressInput>;
  /** Email address of the customer. */
  userEmail: InputMaybe<Scalars['String']>;
};

/**
 * Updates a shipping method of the order. Requires shipping method ID to update, when null is passed then currently assigned shipping method is removed.
 *
 * Requires one of the following permissions: MANAGE_ORDERS.
 */
export type OrderUpdateShipping = {
  __typename: 'OrderUpdateShipping';
  errors: Array<OrderError>;
  /** Order with updated shipping method. */
  order: Maybe<Order>;
  /** @deprecated Use `errors` field instead. */
  orderErrors: Array<OrderError>;
};

export type OrderUpdateShippingInput = {
  /** ID of the selected shipping method, pass null to remove currently assigned shipping method. */
  shippingMethod: InputMaybe<Scalars['ID']>;
};

/** Event sent when order is updated. */
export type OrderUpdated = Event & {
  __typename: 'OrderUpdated';
  /** Time of the event. */
  issuedAt: Maybe<Scalars['DateTime']>;
  /** The user or application that triggered the event. */
  issuingPrincipal: Maybe<IssuingPrincipal>;
  /** The order the event relates to. */
  order: Maybe<Order>;
  /** The application receiving the webhook. */
  recipient: Maybe<App>;
  /** Saleor version that triggered the event. */
  version: Maybe<Scalars['String']>;
};

/**
 * Void an order.
 *
 * Requires one of the following permissions: MANAGE_ORDERS.
 */
export type OrderVoid = {
  __typename: 'OrderVoid';
  errors: Array<OrderError>;
  /** A voided order. */
  order: Maybe<Order>;
  /** @deprecated Use `errors` field instead. */
  orderErrors: Array<OrderError>;
};

export type OrderWhereInput = {
  /** List of conditions that must be met. */
  AND: InputMaybe<Array<OrderWhereInput>>;
  /** A list of conditions of which at least one must be met. */
  OR: InputMaybe<Array<OrderWhereInput>>;
  /** Filter by authorize status. */
  authorizeStatus: InputMaybe<OrderAuthorizeStatusEnumFilterInput>;
  /** Filter by billing address of the order. */
  billingAddress: InputMaybe<AddressFilterInput>;
  /** Filter by channel. */
  channelId: InputMaybe<GlobalIdFilterInput>;
  /** Filter by charge status. */
  chargeStatus: InputMaybe<OrderChargeStatusEnumFilterInput>;
  /** Filter by checkout id. */
  checkoutId: InputMaybe<GlobalIdFilterInput>;
  /** Filter by checkout token. */
  checkoutToken: InputMaybe<UuidFilterInput>;
  /** Filter order by created at date. */
  createdAt: InputMaybe<DateTimeRangeInput>;
  /** Filter by order events. Each list item represents conditions that must be satisfied by a single object. The filter matches orders that have related objects meeting all specified groups of conditions. */
  events: InputMaybe<Array<OrderEventFilterInput>>;
  /** Filter by fulfillment data associated with the order. Each list item represents conditions that must be satisfied by a single object. The filter matches orders that have related objects meeting all specified groups of conditions. */
  fulfillments: InputMaybe<Array<FulfillmentFilterInput>>;
  /** Filter by whether the order has any fulfillments. */
  hasFulfillments: InputMaybe<Scalars['Boolean']>;
  /** Filter by whether the order has any invoices. */
  hasInvoices: InputMaybe<Scalars['Boolean']>;
  ids: InputMaybe<Array<Scalars['ID']>>;
  /** Filter by invoice data associated with the order. Each list item represents conditions that must be satisfied by a single object. The filter matches orders that have related objects meeting all specified groups of conditions. */
  invoices: InputMaybe<Array<InvoiceFilterInput>>;
  /** Filter by whether the order uses the click and collect delivery method. */
  isClickAndCollect: InputMaybe<Scalars['Boolean']>;
  /** Filter based on whether the order includes a gift card purchase. */
  isGiftCardBought: InputMaybe<Scalars['Boolean']>;
  /** Filter based on whether a gift card was used in the order. */
  isGiftCardUsed: InputMaybe<Scalars['Boolean']>;
  /** Filter by line items associated with the order. Each list item represents conditions that must be satisfied by a single object. The filter matches orders that have related objects meeting all specified groups of conditions. */
  lines: InputMaybe<Array<LinesFilterInput>>;
  /** Filter by number of lines in the order. */
  linesCount: InputMaybe<IntFilterInput>;
  /** Filter by metadata fields. */
  metadata: InputMaybe<MetadataFilterInput>;
  /** Filter by order number. */
  number: InputMaybe<IntFilterInput>;
  /** Filter by the product type of related order lines. */
  productTypeId: InputMaybe<GlobalIdFilterInput>;
  /** Filter by shipping address of the order. */
  shippingAddress: InputMaybe<AddressFilterInput>;
  /** Filter by order status. */
  status: InputMaybe<OrderStatusEnumFilterInput>;
  /** Filter by total gross amount of the order. */
  totalGross: InputMaybe<PriceFilterInput>;
  /** Filter by total net amount of the order. */
  totalNet: InputMaybe<PriceFilterInput>;
  /** Filter by transaction data associated with the order. Each list item represents conditions that must be satisfied by a single object. The filter matches orders that have related objects meeting all specified groups of conditions. */
  transactions: InputMaybe<Array<TransactionFilterInput>>;
  /** Filter order by updated at date. */
  updatedAt: InputMaybe<DateTimeRangeInput>;
  /** Filter by user. */
  user: InputMaybe<GlobalIdFilterInput>;
  /** Filter by user email. */
  userEmail: InputMaybe<StringFilterInput>;
  /** Filter by voucher code used in the order. */
  voucherCode: InputMaybe<StringFilterInput>;
};

/**
 * Represents a payment method used for a transaction.
 *
 * Added in Saleor 3.22.
 */
export type OtherPaymentMethodDetails = PaymentMethodDetails & {
  __typename: 'OtherPaymentMethodDetails';
  /** Name of the payment method. */
  name: Scalars['String'];
};

export type OtherPaymentMethodDetailsInput = {
  /** Name of the payment method used for the transaction. */
  name: Scalars['String'];
};

/** A static page that can be manually added by a shop operator through the dashboard. */
export type Page = Node & ObjectWithAttributes & ObjectWithMetadata & {
  __typename: 'Page';
  /**
   * Get a single attribute attached to page by attribute slug.
   *
   * Added in Saleor 3.22.
   */
  assignedAttribute: Maybe<AssignedAttribute>;
  /**
   * List of attributes assigned to this page.
   *
   * Added in Saleor 3.22.
   */
  assignedAttributes: Array<AssignedAttribute>;
  /**
   * Get a single attribute attached to page by attribute slug.
   * @deprecated Use `assignedAttribute` field instead.
   */
  attribute: Maybe<SelectedAttribute>;
  /**
   * List of attributes assigned to this page.
   * @deprecated Use `assignedAttributes` field instead.
   */
  attributes: Array<SelectedAttribute>;
  /**
   * Content of the page.
   *
   * Rich text format. For reference see https://editorjs.io/
   */
  content: Maybe<Scalars['JSONString']>;
  /**
   * Content of the page.
   *
   * Rich text format. For reference see https://editorjs.io/
   * @deprecated Use the `content` field instead.
   */
  contentJson: Scalars['JSONString'];
  /** Date and time at which page was created. */
  created: Scalars['DateTime'];
  /** ID of the page. */
  id: Scalars['ID'];
  /** Determines if the page is published. */
  isPublished: Scalars['Boolean'];
  /** List of public metadata items. Can be accessed without permissions. */
  metadata: Array<MetadataItem>;
  /**
   * A single key from public metadata.
   *
   * Tip: Use GraphQL aliases to fetch multiple keys.
   */
  metafield: Maybe<Scalars['String']>;
  /** Public metadata. Use `keys` to control which fields you want to include. The default is to include everything. */
  metafields: Maybe<Scalars['Metadata']>;
  /** Determines the type of page */
  pageType: PageType;
  /** List of private metadata items. Requires staff permissions to access. */
  privateMetadata: Array<MetadataItem>;
  /**
   * A single key from private metadata. Requires staff permissions to access.
   *
   * Tip: Use GraphQL aliases to fetch multiple keys.
   */
  privateMetafield: Maybe<Scalars['String']>;
  /** Private metadata. Requires staff permissions to access. Use `keys` to control which fields you want to include. The default is to include everything. */
  privateMetafields: Maybe<Scalars['Metadata']>;
  /** @deprecated Use the `publishedAt` field to fetch the publication date. */
  publicationDate: Maybe<Scalars['Date']>;
  /** The page publication date. */
  publishedAt: Maybe<Scalars['DateTime']>;
  /** Description of the page for SEO. */
  seoDescription: Maybe<Scalars['String']>;
  /** Title of the page for SEO. */
  seoTitle: Maybe<Scalars['String']>;
  /** Slug of the page. */
  slug: Scalars['String'];
  /** Title of the page. */
  title: Scalars['String'];
  /** Returns translated page fields for the given language code. */
  translation: Maybe<PageTranslation>;
};


/** A static page that can be manually added by a shop operator through the dashboard. */
export type PageAssignedAttributeArgs = {
  slug: Scalars['String'];
};


/** A static page that can be manually added by a shop operator through the dashboard. */
export type PageAssignedAttributesArgs = {
  limit?: InputMaybe<Scalars['PositiveInt']>;
};


/** A static page that can be manually added by a shop operator through the dashboard. */
export type PageAttributeArgs = {
  slug: Scalars['String'];
};


/** A static page that can be manually added by a shop operator through the dashboard. */
export type PageMetafieldArgs = {
  key: Scalars['String'];
};


/** A static page that can be manually added by a shop operator through the dashboard. */
export type PageMetafieldsArgs = {
  keys: InputMaybe<Array<Scalars['String']>>;
};


/** A static page that can be manually added by a shop operator through the dashboard. */
export type PagePrivateMetafieldArgs = {
  key: Scalars['String'];
};


/** A static page that can be manually added by a shop operator through the dashboard. */
export type PagePrivateMetafieldsArgs = {
  keys: InputMaybe<Array<Scalars['String']>>;
};


/** A static page that can be manually added by a shop operator through the dashboard. */
export type PageTranslationArgs = {
  languageCode: LanguageCodeEnum;
};

/**
 * Assign attributes to a given page type.
 *
 * Requires one of the following permissions: MANAGE_PAGE_TYPES_AND_ATTRIBUTES.
 */
export type PageAttributeAssign = {
  __typename: 'PageAttributeAssign';
  errors: Array<PageError>;
  /** @deprecated Use `errors` field instead. */
  pageErrors: Array<PageError>;
  /** The updated page type. */
  pageType: Maybe<PageType>;
};

/**
 * Unassign attributes from a given page type.
 *
 * Requires one of the following permissions: MANAGE_PAGE_TYPES_AND_ATTRIBUTES.
 */
export type PageAttributeUnassign = {
  __typename: 'PageAttributeUnassign';
  errors: Array<PageError>;
  /** @deprecated Use `errors` field instead. */
  pageErrors: Array<PageError>;
  /** The updated page type. */
  pageType: Maybe<PageType>;
};

/**
 * Deletes pages.
 *
 * Requires one of the following permissions: MANAGE_PAGES.
 */
export type PageBulkDelete = {
  __typename: 'PageBulkDelete';
  /** Returns how many objects were affected. */
  count: Scalars['Int'];
  errors: Array<PageError>;
  /** @deprecated Use `errors` field instead. */
  pageErrors: Array<PageError>;
};

/**
 * Publish pages.
 *
 * Requires one of the following permissions: MANAGE_PAGES.
 */
export type PageBulkPublish = {
  __typename: 'PageBulkPublish';
  /** Returns how many objects were affected. */
  count: Scalars['Int'];
  errors: Array<PageError>;
  /** @deprecated Use `errors` field instead. */
  pageErrors: Array<PageError>;
};

export type PageCountableConnection = {
  __typename: 'PageCountableConnection';
  edges: Array<PageCountableEdge>;
  /** Pagination data for this connection. */
  pageInfo: PageInfo;
  /** A total count of items in the collection. */
  totalCount: Maybe<Scalars['Int']>;
};

export type PageCountableEdge = {
  __typename: 'PageCountableEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node: Page;
};

/**
 * Creates a new page.
 *
 * Requires one of the following permissions: MANAGE_PAGES.
 */
export type PageCreate = {
  __typename: 'PageCreate';
  errors: Array<PageError>;
  page: Maybe<Page>;
  /** @deprecated Use `errors` field instead. */
  pageErrors: Array<PageError>;
};

export type PageCreateInput = {
  /** List of attributes. */
  attributes: InputMaybe<Array<AttributeValueInput>>;
  /**
   * Page content.
   *
   * Rich text format. For reference see https://editorjs.io/
   */
  content: InputMaybe<Scalars['JSONString']>;
  /** Determines if page is visible in the storefront. */
  isPublished: InputMaybe<Scalars['Boolean']>;
  /** ID of the page type that page belongs to. */
  pageType: Scalars['ID'];
  /**
   * Publication date. ISO 8601 standard.
   * @deprecated Use `publishedAt` field instead.
   */
  publicationDate: InputMaybe<Scalars['String']>;
  /** Publication date time. ISO 8601 standard. */
  publishedAt: InputMaybe<Scalars['DateTime']>;
  /** Search engine optimization fields. */
  seo: InputMaybe<SeoInput>;
  /** Page internal name. */
  slug: InputMaybe<Scalars['String']>;
  /** Page title. */
  title: InputMaybe<Scalars['String']>;
};

/** Event sent when new page is created. */
export type PageCreated = Event & {
  __typename: 'PageCreated';
  /** Time of the event. */
  issuedAt: Maybe<Scalars['DateTime']>;
  /** The user or application that triggered the event. */
  issuingPrincipal: Maybe<IssuingPrincipal>;
  /** The page the event relates to. */
  page: Maybe<Page>;
  /** The application receiving the webhook. */
  recipient: Maybe<App>;
  /** Saleor version that triggered the event. */
  version: Maybe<Scalars['String']>;
};

/**
 * Deletes a page.
 *
 * Requires one of the following permissions: MANAGE_PAGES.
 */
export type PageDelete = {
  __typename: 'PageDelete';
  errors: Array<PageError>;
  page: Maybe<Page>;
  /** @deprecated Use `errors` field instead. */
  pageErrors: Array<PageError>;
};

/** Event sent when page is deleted. */
export type PageDeleted = Event & {
  __typename: 'PageDeleted';
  /** Time of the event. */
  issuedAt: Maybe<Scalars['DateTime']>;
  /** The user or application that triggered the event. */
  issuingPrincipal: Maybe<IssuingPrincipal>;
  /** The page the event relates to. */
  page: Maybe<Page>;
  /** The application receiving the webhook. */
  recipient: Maybe<App>;
  /** Saleor version that triggered the event. */
  version: Maybe<Scalars['String']>;
};

export type PageError = {
  __typename: 'PageError';
  /** List of attributes IDs which causes the error. */
  attributes: Maybe<Array<Scalars['ID']>>;
  /** The error code. */
  code: PageErrorCode;
  /** Name of a field that caused the error. A value of `null` indicates that the error isn't associated with a particular field. */
  field: Maybe<Scalars['String']>;
  /** The error message. */
  message: Maybe<Scalars['String']>;
  /** List of attribute values IDs which causes the error. */
  values: Maybe<Array<Scalars['ID']>>;
};

export type PageErrorCode =
  | 'ATTRIBUTE_ALREADY_ASSIGNED'
  | 'DUPLICATED_INPUT_ITEM'
  | 'GRAPHQL_ERROR'
  | 'INVALID'
  | 'NOT_FOUND'
  | 'REQUIRED'
  | 'UNIQUE';

export type PageFilterInput = {
  ids: InputMaybe<Array<Scalars['ID']>>;
  metadata: InputMaybe<Array<MetadataFilter>>;
  pageTypes: InputMaybe<Array<Scalars['ID']>>;
  search: InputMaybe<Scalars['String']>;
  slugs: InputMaybe<Array<Scalars['String']>>;
};

/** The Relay compliant `PageInfo` type, containing data necessary to paginate this connection. */
export type PageInfo = {
  __typename: 'PageInfo';
  /** When paginating forwards, the cursor to continue. */
  endCursor: Maybe<Scalars['String']>;
  /** When paginating forwards, are there more items? */
  hasNextPage: Scalars['Boolean'];
  /** When paginating backwards, are there more items? */
  hasPreviousPage: Scalars['Boolean'];
  /** When paginating backwards, the cursor to continue. */
  startCursor: Maybe<Scalars['String']>;
};

export type PageInput = {
  /** List of attributes. */
  attributes: InputMaybe<Array<AttributeValueInput>>;
  /**
   * Page content.
   *
   * Rich text format. For reference see https://editorjs.io/
   */
  content: InputMaybe<Scalars['JSONString']>;
  /** Determines if page is visible in the storefront. */
  isPublished: InputMaybe<Scalars['Boolean']>;
  /**
   * Publication date. ISO 8601 standard.
   * @deprecated Use `publishedAt` field instead.
   */
  publicationDate: InputMaybe<Scalars['String']>;
  /** Publication date time. ISO 8601 standard. */
  publishedAt: InputMaybe<Scalars['DateTime']>;
  /** Search engine optimization fields. */
  seo: InputMaybe<SeoInput>;
  /** Page internal name. */
  slug: InputMaybe<Scalars['String']>;
  /** Page title. */
  title: InputMaybe<Scalars['String']>;
};

/**
 * Reorder page attribute values.
 *
 * Requires one of the following permissions: MANAGE_PAGES.
 */
export type PageReorderAttributeValues = {
  __typename: 'PageReorderAttributeValues';
  errors: Array<PageError>;
  /** Page from which attribute values are reordered. */
  page: Maybe<Page>;
  /** @deprecated Use `errors` field instead. */
  pageErrors: Array<PageError>;
};

export type PageSortField =
  /** Sort pages by creation date. */
  | 'CREATED_AT'
  /** Sort pages by creation date. */
  | 'CREATION_DATE'
  /** Sort pages by publication date. */
  | 'PUBLICATION_DATE'
  /** Sort pages by publication date. */
  | 'PUBLISHED_AT'
  /** Sort pages by slug. */
  | 'SLUG'
  /** Sort pages by title. */
  | 'TITLE'
  /** Sort pages by visibility. */
  | 'VISIBILITY';

export type PageSortingInput = {
  /** Specifies the direction in which to sort pages. */
  direction: OrderDirection;
  /** Sort pages by the selected field. */
  field: PageSortField;
};

/** Represents page's original translatable fields and related translations. */
export type PageTranslatableContent = Node & {
  __typename: 'PageTranslatableContent';
  /** List of page content attribute values that can be translated. */
  attributeValues: Array<AttributeValueTranslatableContent>;
  /**
   * Content of the page to translate.
   *
   * Rich text format. For reference see https://editorjs.io/
   */
  content: Maybe<Scalars['JSONString']>;
  /**
   * Content of the page.
   *
   * Rich text format. For reference see https://editorjs.io/
   * @deprecated Use the `content` field instead.
   */
  contentJson: Maybe<Scalars['JSONString']>;
  /** The ID of the page translatable content. */
  id: Scalars['ID'];
  /**
   * A static page that can be manually added by a shop operator through the dashboard.
   * @deprecated Get model fields from the root level queries.
   */
  page: Maybe<Page>;
  /** The ID of the page to translate. */
  pageId: Scalars['ID'];
  /** SEO description to translate. */
  seoDescription: Maybe<Scalars['String']>;
  /** SEO title to translate. */
  seoTitle: Maybe<Scalars['String']>;
  /**
   * Slug to translate.
   *
   * Added in Saleor 3.21.
   */
  slug: Maybe<Scalars['String']>;
  /** Page title to translate. */
  title: Scalars['String'];
  /** Returns translated page fields for the given language code. */
  translation: Maybe<PageTranslation>;
};


/** Represents page's original translatable fields and related translations. */
export type PageTranslatableContentTranslationArgs = {
  languageCode: LanguageCodeEnum;
};

/**
 * Creates/updates translations for a page.
 *
 * Requires one of the following permissions: MANAGE_TRANSLATIONS.
 */
export type PageTranslate = {
  __typename: 'PageTranslate';
  errors: Array<TranslationError>;
  page: Maybe<PageTranslatableContent>;
  /** @deprecated Use `errors` field instead. */
  translationErrors: Array<TranslationError>;
};

/** Represents page translations. */
export type PageTranslation = Node & {
  __typename: 'PageTranslation';
  /**
   * Translated content of the page.
   *
   * Rich text format. For reference see https://editorjs.io/
   */
  content: Maybe<Scalars['JSONString']>;
  /**
   * Translated description of the page.
   *
   * Rich text format. For reference see https://editorjs.io/
   * @deprecated Use the `content` field instead.
   */
  contentJson: Maybe<Scalars['JSONString']>;
  /** The ID of the page translation. */
  id: Scalars['ID'];
  /** Translation language. */
  language: LanguageDisplay;
  /** Translated SEO description. */
  seoDescription: Maybe<Scalars['String']>;
  /** Translated SEO title. */
  seoTitle: Maybe<Scalars['String']>;
  /**
   * Translated page slug.
   *
   * Added in Saleor 3.21.
   */
  slug: Maybe<Scalars['String']>;
  /** Translated page title. */
  title: Maybe<Scalars['String']>;
  /** Represents the page fields to translate. */
  translatableContent: Maybe<PageTranslatableContent>;
};

export type PageTranslationInput = {
  /**
   * Translated page content.
   *
   * Rich text format. For reference see https://editorjs.io/
   */
  content: InputMaybe<Scalars['JSONString']>;
  seoDescription: InputMaybe<Scalars['String']>;
  seoTitle: InputMaybe<Scalars['String']>;
  slug: InputMaybe<Scalars['String']>;
  title: InputMaybe<Scalars['String']>;
};

/** Represents a type of page. It defines what attributes are available to pages of this type. */
export type PageType = Node & ObjectWithMetadata & {
  __typename: 'PageType';
  /** Page attributes of that page type. */
  attributes: Maybe<Array<Attribute>>;
  /**
   * Attributes that can be assigned to the page type.
   *
   * Requires one of the following permissions: MANAGE_PAGES, MANAGE_PAGE_TYPES_AND_ATTRIBUTES.
   */
  availableAttributes: Maybe<AttributeCountableConnection>;
  /**
   * Whether page type has pages assigned.
   *
   * Requires one of the following permissions: MANAGE_PAGES, MANAGE_PAGE_TYPES_AND_ATTRIBUTES.
   */
  hasPages: Maybe<Scalars['Boolean']>;
  /** ID of the page type. */
  id: Scalars['ID'];
  /** List of public metadata items. Can be accessed without permissions. */
  metadata: Array<MetadataItem>;
  /**
   * A single key from public metadata.
   *
   * Tip: Use GraphQL aliases to fetch multiple keys.
   */
  metafield: Maybe<Scalars['String']>;
  /** Public metadata. Use `keys` to control which fields you want to include. The default is to include everything. */
  metafields: Maybe<Scalars['Metadata']>;
  /** Name of the page type. */
  name: Scalars['String'];
  /** List of private metadata items. Requires staff permissions to access. */
  privateMetadata: Array<MetadataItem>;
  /**
   * A single key from private metadata. Requires staff permissions to access.
   *
   * Tip: Use GraphQL aliases to fetch multiple keys.
   */
  privateMetafield: Maybe<Scalars['String']>;
  /** Private metadata. Requires staff permissions to access. Use `keys` to control which fields you want to include. The default is to include everything. */
  privateMetafields: Maybe<Scalars['Metadata']>;
  /** Slug of the page type. */
  slug: Scalars['String'];
};


/** Represents a type of page. It defines what attributes are available to pages of this type. */
export type PageTypeAvailableAttributesArgs = {
  after: InputMaybe<Scalars['String']>;
  before: InputMaybe<Scalars['String']>;
  filter: InputMaybe<AttributeFilterInput>;
  first: InputMaybe<Scalars['Int']>;
  last: InputMaybe<Scalars['Int']>;
  search: InputMaybe<Scalars['String']>;
  where: InputMaybe<AttributeWhereInput>;
};


/** Represents a type of page. It defines what attributes are available to pages of this type. */
export type PageTypeMetafieldArgs = {
  key: Scalars['String'];
};


/** Represents a type of page. It defines what attributes are available to pages of this type. */
export type PageTypeMetafieldsArgs = {
  keys: InputMaybe<Array<Scalars['String']>>;
};


/** Represents a type of page. It defines what attributes are available to pages of this type. */
export type PageTypePrivateMetafieldArgs = {
  key: Scalars['String'];
};


/** Represents a type of page. It defines what attributes are available to pages of this type. */
export type PageTypePrivateMetafieldsArgs = {
  keys: InputMaybe<Array<Scalars['String']>>;
};

/**
 * Deletes page types.
 *
 * Requires one of the following permissions: MANAGE_PAGE_TYPES_AND_ATTRIBUTES.
 */
export type PageTypeBulkDelete = {
  __typename: 'PageTypeBulkDelete';
  /** Returns how many objects were affected. */
  count: Scalars['Int'];
  errors: Array<PageError>;
  /** @deprecated Use `errors` field instead. */
  pageErrors: Array<PageError>;
};

export type PageTypeCountableConnection = {
  __typename: 'PageTypeCountableConnection';
  edges: Array<PageTypeCountableEdge>;
  /** Pagination data for this connection. */
  pageInfo: PageInfo;
  /** A total count of items in the collection. */
  totalCount: Maybe<Scalars['Int']>;
};

export type PageTypeCountableEdge = {
  __typename: 'PageTypeCountableEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node: PageType;
};

/**
 * Creates a new page type.
 *
 * Requires one of the following permissions: MANAGE_PAGE_TYPES_AND_ATTRIBUTES.
 */
export type PageTypeCreate = {
  __typename: 'PageTypeCreate';
  errors: Array<PageError>;
  /** @deprecated Use `errors` field instead. */
  pageErrors: Array<PageError>;
  pageType: Maybe<PageType>;
};

export type PageTypeCreateInput = {
  /** List of attribute IDs to be assigned to the page type. */
  addAttributes: InputMaybe<Array<Scalars['ID']>>;
  /** Name of the page type. */
  name: InputMaybe<Scalars['String']>;
  /** Page type slug. */
  slug: InputMaybe<Scalars['String']>;
};

/** Event sent when new page type is created. */
export type PageTypeCreated = Event & {
  __typename: 'PageTypeCreated';
  /** Time of the event. */
  issuedAt: Maybe<Scalars['DateTime']>;
  /** The user or application that triggered the event. */
  issuingPrincipal: Maybe<IssuingPrincipal>;
  /** The page type the event relates to. */
  pageType: Maybe<PageType>;
  /** The application receiving the webhook. */
  recipient: Maybe<App>;
  /** Saleor version that triggered the event. */
  version: Maybe<Scalars['String']>;
};

/**
 * Deletes a page type.
 *
 * Requires one of the following permissions: MANAGE_PAGE_TYPES_AND_ATTRIBUTES.
 */
export type PageTypeDelete = {
  __typename: 'PageTypeDelete';
  errors: Array<PageError>;
  /** @deprecated Use `errors` field instead. */
  pageErrors: Array<PageError>;
  pageType: Maybe<PageType>;
};

/** Event sent when page type is deleted. */
export type PageTypeDeleted = Event & {
  __typename: 'PageTypeDeleted';
  /** Time of the event. */
  issuedAt: Maybe<Scalars['DateTime']>;
  /** The user or application that triggered the event. */
  issuingPrincipal: Maybe<IssuingPrincipal>;
  /** The page type the event relates to. */
  pageType: Maybe<PageType>;
  /** The application receiving the webhook. */
  recipient: Maybe<App>;
  /** Saleor version that triggered the event. */
  version: Maybe<Scalars['String']>;
};

export type PageTypeFilterInput = {
  search: InputMaybe<Scalars['String']>;
  slugs: InputMaybe<Array<Scalars['String']>>;
};

/**
 * Reorder the attributes of a page type.
 *
 * Requires one of the following permissions: MANAGE_PAGE_TYPES_AND_ATTRIBUTES.
 */
export type PageTypeReorderAttributes = {
  __typename: 'PageTypeReorderAttributes';
  errors: Array<PageError>;
  /** @deprecated Use `errors` field instead. */
  pageErrors: Array<PageError>;
  /** Page type from which attributes are reordered. */
  pageType: Maybe<PageType>;
};

export type PageTypeSortField =
  /** Sort page types by name. */
  | 'NAME'
  /** Sort page types by slug. */
  | 'SLUG';

export type PageTypeSortingInput = {
  /** Specifies the direction in which to sort page types. */
  direction: OrderDirection;
  /** Sort page types by the selected field. */
  field: PageTypeSortField;
};

/**
 * Updates page type.
 *
 * Requires one of the following permissions: MANAGE_PAGE_TYPES_AND_ATTRIBUTES.
 */
export type PageTypeUpdate = {
  __typename: 'PageTypeUpdate';
  errors: Array<PageError>;
  /** @deprecated Use `errors` field instead. */
  pageErrors: Array<PageError>;
  pageType: Maybe<PageType>;
};

export type PageTypeUpdateInput = {
  /** List of attribute IDs to be assigned to the page type. */
  addAttributes: InputMaybe<Array<Scalars['ID']>>;
  /** Name of the page type. */
  name: InputMaybe<Scalars['String']>;
  /** List of attribute IDs to be assigned to the page type. */
  removeAttributes: InputMaybe<Array<Scalars['ID']>>;
  /** Page type slug. */
  slug: InputMaybe<Scalars['String']>;
};

/** Event sent when page type is updated. */
export type PageTypeUpdated = Event & {
  __typename: 'PageTypeUpdated';
  /** Time of the event. */
  issuedAt: Maybe<Scalars['DateTime']>;
  /** The user or application that triggered the event. */
  issuingPrincipal: Maybe<IssuingPrincipal>;
  /** The page type the event relates to. */
  pageType: Maybe<PageType>;
  /** The application receiving the webhook. */
  recipient: Maybe<App>;
  /** Saleor version that triggered the event. */
  version: Maybe<Scalars['String']>;
};

/**
 * Updates an existing page.
 *
 * Requires one of the following permissions: MANAGE_PAGES.
 */
export type PageUpdate = {
  __typename: 'PageUpdate';
  errors: Array<PageError>;
  page: Maybe<Page>;
  /** @deprecated Use `errors` field instead. */
  pageErrors: Array<PageError>;
};

/** Event sent when page is updated. */
export type PageUpdated = Event & {
  __typename: 'PageUpdated';
  /** Time of the event. */
  issuedAt: Maybe<Scalars['DateTime']>;
  /** The user or application that triggered the event. */
  issuingPrincipal: Maybe<IssuingPrincipal>;
  /** The page the event relates to. */
  page: Maybe<Page>;
  /** The application receiving the webhook. */
  recipient: Maybe<App>;
  /** Saleor version that triggered the event. */
  version: Maybe<Scalars['String']>;
};

export type PageWhereInput = {
  /** List of conditions that must be met. */
  AND: InputMaybe<Array<PageWhereInput>>;
  /** A list of conditions of which at least one must be met. */
  OR: InputMaybe<Array<PageWhereInput>>;
  /** Filter by attributes associated with the page. */
  attributes: InputMaybe<Array<AssignedAttributeWhereInput>>;
  ids: InputMaybe<Array<Scalars['ID']>>;
  /** Filter by metadata fields. */
  metadata: InputMaybe<MetadataFilterInput>;
  /** Filter by page type. */
  pageType: InputMaybe<GlobalIdFilterInput>;
  /** Filter by page slug. */
  slug: InputMaybe<StringFilterInput>;
};

/**
 * Change the password of the logged in user.
 *
 * Requires one of the following permissions: AUTHENTICATED_USER.
 */
export type PasswordChange = {
  __typename: 'PasswordChange';
  /** @deprecated Use `errors` field instead. */
  accountErrors: Array<AccountError>;
  errors: Array<AccountError>;
  /** A user instance with a new password. */
  user: Maybe<User>;
};

/** Represents a payment of a given type. */
export type Payment = Node & ObjectWithMetadata & {
  __typename: 'Payment';
  /**
   * List of actions that can be performed in the current state of a payment.
   *
   * Requires one of the following permissions: MANAGE_ORDERS.
   */
  actions: Array<OrderAction>;
  /**
   * Maximum amount of money that can be captured.
   *
   * Requires one of the following permissions: MANAGE_ORDERS.
   */
  availableCaptureAmount: Maybe<Money>;
  /**
   * Maximum amount of money that can be refunded.
   *
   * Requires one of the following permissions: MANAGE_ORDERS.
   */
  availableRefundAmount: Maybe<Money>;
  /** Total amount captured for this payment. */
  capturedAmount: Maybe<Money>;
  /** Internal payment status. */
  chargeStatus: PaymentChargeStatusEnum;
  /** Checkout associated with a payment. */
  checkout: Maybe<Checkout>;
  /** Date and time at which payment was created. */
  created: Scalars['DateTime'];
  /** The details of the card used for this payment. */
  creditCard: Maybe<CreditCard>;
  /**
   * IP address of the user who created the payment.
   *
   * Requires one of the following permissions: MANAGE_ORDERS.
   */
  customerIpAddress: Maybe<Scalars['String']>;
  /** Payment gateway used for payment. */
  gateway: Scalars['String'];
  /** ID of the payment. */
  id: Scalars['ID'];
  /** Determines if the payment is active or not. */
  isActive: Scalars['Boolean'];
  /** List of public metadata items. Can be accessed without permissions. */
  metadata: Array<MetadataItem>;
  /**
   * A single key from public metadata.
   *
   * Tip: Use GraphQL aliases to fetch multiple keys.
   */
  metafield: Maybe<Scalars['String']>;
  /** Public metadata. Use `keys` to control which fields you want to include. The default is to include everything. */
  metafields: Maybe<Scalars['Metadata']>;
  /** Date and time at which payment was modified. */
  modified: Scalars['DateTime'];
  /** Order associated with a payment. */
  order: Maybe<Order>;
  /** Informs whether this is a partial payment. */
  partial: Scalars['Boolean'];
  /** Type of method used for payment. */
  paymentMethodType: Scalars['String'];
  /** List of private metadata items. Requires staff permissions to access. */
  privateMetadata: Array<MetadataItem>;
  /**
   * A single key from private metadata. Requires staff permissions to access.
   *
   * Tip: Use GraphQL aliases to fetch multiple keys.
   */
  privateMetafield: Maybe<Scalars['String']>;
  /** Private metadata. Requires staff permissions to access. Use `keys` to control which fields you want to include. The default is to include everything. */
  privateMetafields: Maybe<Scalars['Metadata']>;
  /** PSP reference of the payment. */
  pspReference: Maybe<Scalars['String']>;
  /** Unique token associated with a payment. */
  token: Scalars['String'];
  /** Total amount of the payment. */
  total: Maybe<Money>;
  /**
   * List of all transactions within this payment.
   *
   * Requires one of the following permissions: MANAGE_ORDERS.
   */
  transactions: Maybe<Array<Transaction>>;
};


/** Represents a payment of a given type. */
export type PaymentMetafieldArgs = {
  key: Scalars['String'];
};


/** Represents a payment of a given type. */
export type PaymentMetafieldsArgs = {
  keys: InputMaybe<Array<Scalars['String']>>;
};


/** Represents a payment of a given type. */
export type PaymentPrivateMetafieldArgs = {
  key: Scalars['String'];
};


/** Represents a payment of a given type. */
export type PaymentPrivateMetafieldsArgs = {
  keys: InputMaybe<Array<Scalars['String']>>;
};

/** Authorize payment. */
export type PaymentAuthorize = Event & {
  __typename: 'PaymentAuthorize';
  /** Time of the event. */
  issuedAt: Maybe<Scalars['DateTime']>;
  /** The user or application that triggered the event. */
  issuingPrincipal: Maybe<IssuingPrincipal>;
  /** Look up a payment. */
  payment: Maybe<Payment>;
  /** The application receiving the webhook. */
  recipient: Maybe<App>;
  /** Saleor version that triggered the event. */
  version: Maybe<Scalars['String']>;
};

/**
 * Captures the authorized payment amount.
 *
 * Requires one of the following permissions: MANAGE_ORDERS.
 */
export type PaymentCapture = {
  __typename: 'PaymentCapture';
  errors: Array<PaymentError>;
  /** Updated payment. */
  payment: Maybe<Payment>;
  /** @deprecated Use `errors` field instead. */
  paymentErrors: Array<PaymentError>;
};

/** Capture payment. */
export type PaymentCaptureEvent = Event & {
  __typename: 'PaymentCaptureEvent';
  /** Time of the event. */
  issuedAt: Maybe<Scalars['DateTime']>;
  /** The user or application that triggered the event. */
  issuingPrincipal: Maybe<IssuingPrincipal>;
  /** Look up a payment. */
  payment: Maybe<Payment>;
  /** The application receiving the webhook. */
  recipient: Maybe<App>;
  /** Saleor version that triggered the event. */
  version: Maybe<Scalars['String']>;
};

export type PaymentChargeStatusEnum =
  | 'CANCELLED'
  | 'FULLY_CHARGED'
  | 'FULLY_REFUNDED'
  | 'NOT_CHARGED'
  | 'PARTIALLY_CHARGED'
  | 'PARTIALLY_REFUNDED'
  | 'PENDING'
  | 'REFUSED';

/** Check payment balance. */
export type PaymentCheckBalance = {
  __typename: 'PaymentCheckBalance';
  /** Response from the gateway. */
  data: Maybe<Scalars['JSONString']>;
  errors: Array<PaymentError>;
  /** @deprecated Use `errors` field instead. */
  paymentErrors: Array<PaymentError>;
};

export type PaymentCheckBalanceInput = {
  /** Information about card. */
  card: CardInput;
  /** Slug of a channel for which the data should be returned. */
  channel: Scalars['String'];
  /** An ID of a payment gateway to check. */
  gatewayId: Scalars['String'];
  /** Payment method name. */
  method: Scalars['String'];
};

/** Confirm payment. */
export type PaymentConfirmEvent = Event & {
  __typename: 'PaymentConfirmEvent';
  /** Time of the event. */
  issuedAt: Maybe<Scalars['DateTime']>;
  /** The user or application that triggered the event. */
  issuingPrincipal: Maybe<IssuingPrincipal>;
  /** Look up a payment. */
  payment: Maybe<Payment>;
  /** The application receiving the webhook. */
  recipient: Maybe<App>;
  /** Saleor version that triggered the event. */
  version: Maybe<Scalars['String']>;
};

export type PaymentCountableConnection = {
  __typename: 'PaymentCountableConnection';
  edges: Array<PaymentCountableEdge>;
  /** Pagination data for this connection. */
  pageInfo: PageInfo;
  /** A total count of items in the collection. */
  totalCount: Maybe<Scalars['Int']>;
};

export type PaymentCountableEdge = {
  __typename: 'PaymentCountableEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node: Payment;
};

export type PaymentError = {
  __typename: 'PaymentError';
  /** The error code. */
  code: PaymentErrorCode;
  /** Name of a field that caused the error. A value of `null` indicates that the error isn't associated with a particular field. */
  field: Maybe<Scalars['String']>;
  /** The error message. */
  message: Maybe<Scalars['String']>;
  /** List of variant IDs which causes the error. */
  variants: Maybe<Array<Scalars['ID']>>;
};

export type PaymentErrorCode =
  | 'BALANCE_CHECK_ERROR'
  | 'BILLING_ADDRESS_NOT_SET'
  | 'CHANNEL_INACTIVE'
  | 'CHECKOUT_COMPLETION_IN_PROGRESS'
  | 'CHECKOUT_EMAIL_NOT_SET'
  | 'CHECKOUT_HAS_TRANSACTION'
  | 'GRAPHQL_ERROR'
  | 'INVALID'
  | 'INVALID_SHIPPING_METHOD'
  | 'NOT_FOUND'
  | 'NOT_SUPPORTED_GATEWAY'
  | 'NO_CHECKOUT_LINES'
  | 'PARTIAL_PAYMENT_NOT_ALLOWED'
  | 'PAYMENT_ERROR'
  | 'REQUIRED'
  | 'SHIPPING_ADDRESS_NOT_SET'
  | 'SHIPPING_METHOD_NOT_SET'
  | 'UNAVAILABLE_VARIANT_IN_CHANNEL'
  | 'UNIQUE';

export type PaymentFilterInput = {
  checkouts: InputMaybe<Array<Scalars['ID']>>;
  /** Filter by ids. */
  ids: InputMaybe<Array<Scalars['ID']>>;
};

/** Available payment gateway backend with configuration necessary to setup client. */
export type PaymentGateway = {
  __typename: 'PaymentGateway';
  /** Payment gateway client configuration. */
  config: Array<GatewayConfigLine>;
  /** Payment gateway supported currencies. */
  currencies: Array<Scalars['String']>;
  /** Payment gateway ID. */
  id: Scalars['ID'];
  /** Payment gateway name. */
  name: Scalars['String'];
};

export type PaymentGatewayConfig = {
  __typename: 'PaymentGatewayConfig';
  /** The JSON data required to initialize the payment gateway. */
  data: Maybe<Scalars['JSON']>;
  errors: Maybe<Array<PaymentGatewayConfigError>>;
  /** The app identifier. */
  id: Scalars['String'];
};

export type PaymentGatewayConfigError = {
  __typename: 'PaymentGatewayConfigError';
  /** The error code. */
  code: PaymentGatewayConfigErrorCode;
  /** Name of a field that caused the error. A value of `null` indicates that the error isn't associated with a particular field. */
  field: Maybe<Scalars['String']>;
  /** The error message. */
  message: Maybe<Scalars['String']>;
};

export type PaymentGatewayConfigErrorCode =
  | 'GRAPHQL_ERROR'
  | 'INVALID'
  | 'NOT_FOUND';

/** Initializes a payment gateway session. It triggers the webhook `PAYMENT_GATEWAY_INITIALIZE_SESSION`, to the requested `paymentGateways`. If `paymentGateways` is not provided, the webhook will be send to all subscribed payment gateways. There is a limit of 100 transaction items per checkout / order. */
export type PaymentGatewayInitialize = {
  __typename: 'PaymentGatewayInitialize';
  errors: Array<PaymentGatewayInitializeError>;
  /** List of payment gateway configurations. */
  gatewayConfigs: Maybe<Array<PaymentGatewayConfig>>;
};

export type PaymentGatewayInitializeError = {
  __typename: 'PaymentGatewayInitializeError';
  /** The error code. */
  code: PaymentGatewayInitializeErrorCode;
  /** Name of a field that caused the error. A value of `null` indicates that the error isn't associated with a particular field. */
  field: Maybe<Scalars['String']>;
  /** The error message. */
  message: Maybe<Scalars['String']>;
};

export type PaymentGatewayInitializeErrorCode =
  | 'GRAPHQL_ERROR'
  | 'INVALID'
  | 'NOT_FOUND';

/** Event sent when user wants to initialize the payment gateway. */
export type PaymentGatewayInitializeSession = Event & {
  __typename: 'PaymentGatewayInitializeSession';
  /** Amount requested for initializing the payment gateway. */
  amount: Maybe<Scalars['PositiveDecimal']>;
  /** Payment gateway data in JSON format, received from storefront. */
  data: Maybe<Scalars['JSON']>;
  /** Time of the event. */
  issuedAt: Maybe<Scalars['DateTime']>;
  /** The user or application that triggered the event. */
  issuingPrincipal: Maybe<IssuingPrincipal>;
  /** The application receiving the webhook. */
  recipient: Maybe<App>;
  /** Checkout or order */
  sourceObject: OrderOrCheckout;
  /** Saleor version that triggered the event. */
  version: Maybe<Scalars['String']>;
};

/**
 * Initializes payment gateway for tokenizing payment method session.
 *
 * Requires one of the following permissions: AUTHENTICATED_USER.
 *
 * Triggers the following webhook events:
 * - PAYMENT_GATEWAY_INITIALIZE_TOKENIZATION_SESSION (sync): The customer requested to initialize payment gateway for tokenization.
 */
export type PaymentGatewayInitializeTokenization = {
  __typename: 'PaymentGatewayInitializeTokenization';
  /** A data returned by payment app. */
  data: Maybe<Scalars['JSON']>;
  errors: Array<PaymentGatewayInitializeTokenizationError>;
  /** A status of the payment gateway initialization. */
  result: PaymentGatewayInitializeTokenizationResult;
};

export type PaymentGatewayInitializeTokenizationError = {
  __typename: 'PaymentGatewayInitializeTokenizationError';
  /** The error code. */
  code: PaymentGatewayInitializeTokenizationErrorCode;
  /** Name of a field that caused the error. A value of `null` indicates that the error isn't associated with a particular field. */
  field: Maybe<Scalars['String']>;
  /** The error message. */
  message: Maybe<Scalars['String']>;
};

export type PaymentGatewayInitializeTokenizationErrorCode =
  | 'CHANNEL_INACTIVE'
  | 'GATEWAY_ERROR'
  | 'GRAPHQL_ERROR'
  | 'INVALID'
  | 'NOT_FOUND';

/**
 * Result of initialize payment gateway for tokenization of payment method.
 *
 *     The result of initialize payment gateway for tokenization of payment method.
 *     SUCCESSFULLY_INITIALIZED - The payment gateway was successfully initialized.
 *     FAILED_TO_INITIALIZE - The payment gateway was not initialized.
 *     FAILED_TO_DELIVER - The request to initialize payment gateway was not delivered.
 */
export type PaymentGatewayInitializeTokenizationResult =
  | 'FAILED_TO_DELIVER'
  | 'FAILED_TO_INITIALIZE'
  | 'SUCCESSFULLY_INITIALIZED';

/** Event sent to initialize a new session in payment gateway to store the payment method. */
export type PaymentGatewayInitializeTokenizationSession = Event & {
  __typename: 'PaymentGatewayInitializeTokenizationSession';
  /** Channel related to the requested action. */
  channel: Channel;
  /** Payment gateway data in JSON format, received from storefront. */
  data: Maybe<Scalars['JSON']>;
  /** Time of the event. */
  issuedAt: Maybe<Scalars['DateTime']>;
  /** The user or application that triggered the event. */
  issuingPrincipal: Maybe<IssuingPrincipal>;
  /** The application receiving the webhook. */
  recipient: Maybe<App>;
  /** The user related to the requested action. */
  user: User;
  /** Saleor version that triggered the event. */
  version: Maybe<Scalars['String']>;
};

export type PaymentGatewayToInitialize = {
  /** The data that will be passed to the payment gateway. */
  data: InputMaybe<Scalars['JSON']>;
  /** The identifier of the payment gateway app to initialize. */
  id: Scalars['String'];
};

/** Initializes payment process when it is required by gateway. */
export type PaymentInitialize = {
  __typename: 'PaymentInitialize';
  errors: Array<PaymentError>;
  /** Payment that was initialized. */
  initializedPayment: Maybe<PaymentInitialized>;
  /** @deprecated Use `errors` field instead. */
  paymentErrors: Array<PaymentError>;
};

/** Server-side data generated by a payment gateway. Optional step when the payment provider requires an additional action to initialize payment session. */
export type PaymentInitialized = {
  __typename: 'PaymentInitialized';
  /** Initialized data by gateway. */
  data: Maybe<Scalars['JSONString']>;
  /** ID of a payment gateway. */
  gateway: Scalars['String'];
  /** Payment gateway name. */
  name: Scalars['String'];
};

export type PaymentInput = {
  /** Total amount of the transaction, including all taxes and discounts. If no amount is provided, the checkout total will be used. */
  amount: InputMaybe<Scalars['PositiveDecimal']>;
  /** A gateway to use with that payment. */
  gateway: Scalars['String'];
  /**
   * User public metadata. Can be read by any API client authorized to read the object it's attached to.
   *
   * Warning: never store sensitive information, including financial data such as credit card details.
   */
  metadata: InputMaybe<Array<MetadataInput>>;
  /** URL of a storefront view where user should be redirected after requiring additional actions. Payment with additional actions will not be finished if this field is not provided. */
  returnUrl: InputMaybe<Scalars['String']>;
  /** Payment store type. */
  storePaymentMethod: InputMaybe<StorePaymentMethodEnum>;
  /** Client-side generated payment token, representing customer's billing data in a secure manner. */
  token: InputMaybe<Scalars['String']>;
};

/** List payment gateways. */
export type PaymentListGateways = Event & {
  __typename: 'PaymentListGateways';
  /** The checkout the event relates to. */
  checkout: Maybe<Checkout>;
  /** Time of the event. */
  issuedAt: Maybe<Scalars['DateTime']>;
  /** The user or application that triggered the event. */
  issuingPrincipal: Maybe<IssuingPrincipal>;
  /** The application receiving the webhook. */
  recipient: Maybe<App>;
  /** Saleor version that triggered the event. */
  version: Maybe<Scalars['String']>;
};

/**
 * Represents a payment method used for a transaction.
 *
 * Added in Saleor 3.22.
 */
export type PaymentMethodDetails = {
  /** Name of the payment method. */
  name: Scalars['String'];
};

export type PaymentMethodDetailsCardFilterInput = {
  /** Filter by payment method brand used to pay for the order. */
  brand: InputMaybe<StringFilterInput>;
};

export type PaymentMethodDetailsFilterInput = {
  /** Filter by card details used to pay for the order. Skips `type` filter if provided. */
  card: InputMaybe<PaymentMethodDetailsCardFilterInput>;
  /** Filter by payment method type used to pay for the order. */
  type: InputMaybe<PaymentMethodTypeEnumFilterInput>;
};

/**
 * Details of the payment method used for the transaction. One of `card` or `other` is required.
 *
 * Added in Saleor 3.22.
 */
export type PaymentMethodDetailsInput = {
  /** Details of the card payment method used for the transaction. */
  card: InputMaybe<CardPaymentMethodDetailsInput>;
  /** Details of the non-card payment method used for this transaction. */
  other: InputMaybe<OtherPaymentMethodDetailsInput>;
};

/**
 * Tokenize payment method.
 *
 * Requires one of the following permissions: AUTHENTICATED_USER.
 *
 * Triggers the following webhook events:
 * - PAYMENT_METHOD_INITIALIZE_TOKENIZATION_SESSION (sync): The customer requested to tokenize payment method.
 */
export type PaymentMethodInitializeTokenization = {
  __typename: 'PaymentMethodInitializeTokenization';
  /** A data returned by the payment app. */
  data: Maybe<Scalars['JSON']>;
  errors: Array<PaymentMethodInitializeTokenizationError>;
  /** The identifier of the payment method. */
  id: Maybe<Scalars['String']>;
  /** A status of the payment method tokenization. */
  result: PaymentMethodTokenizationResult;
};

export type PaymentMethodInitializeTokenizationError = {
  __typename: 'PaymentMethodInitializeTokenizationError';
  /** The error code. */
  code: PaymentMethodInitializeTokenizationErrorCode;
  /** Name of a field that caused the error. A value of `null` indicates that the error isn't associated with a particular field. */
  field: Maybe<Scalars['String']>;
  /** The error message. */
  message: Maybe<Scalars['String']>;
};

export type PaymentMethodInitializeTokenizationErrorCode =
  | 'CHANNEL_INACTIVE'
  | 'GATEWAY_ERROR'
  | 'GRAPHQL_ERROR'
  | 'INVALID'
  | 'NOT_FOUND';

/** Event sent when user requests a tokenization of payment method. */
export type PaymentMethodInitializeTokenizationSession = Event & {
  __typename: 'PaymentMethodInitializeTokenizationSession';
  /** Channel related to the requested action. */
  channel: Channel;
  /** Payment gateway data in JSON format, received from storefront. */
  data: Maybe<Scalars['JSON']>;
  /** Time of the event. */
  issuedAt: Maybe<Scalars['DateTime']>;
  /** The user or application that triggered the event. */
  issuingPrincipal: Maybe<IssuingPrincipal>;
  /** The payment flow that the tokenized payment method should support. */
  paymentFlowToSupport: TokenizedPaymentFlowEnum;
  /** The application receiving the webhook. */
  recipient: Maybe<App>;
  /** The user related to the requested action. */
  user: User;
  /** Saleor version that triggered the event. */
  version: Maybe<Scalars['String']>;
};

/**
 * Tokenize payment method.
 *
 * Requires one of the following permissions: AUTHENTICATED_USER.
 *
 * Triggers the following webhook events:
 * - PAYMENT_METHOD_PROCESS_TOKENIZATION_SESSION (sync): The customer continues payment method tokenization.
 */
export type PaymentMethodProcessTokenization = {
  __typename: 'PaymentMethodProcessTokenization';
  /** A data returned by the payment app. */
  data: Maybe<Scalars['JSON']>;
  errors: Array<PaymentMethodProcessTokenizationError>;
  /** The identifier of the payment method. */
  id: Maybe<Scalars['String']>;
  /** A status of the payment method tokenization. */
  result: PaymentMethodTokenizationResult;
};

export type PaymentMethodProcessTokenizationError = {
  __typename: 'PaymentMethodProcessTokenizationError';
  /** The error code. */
  code: PaymentMethodProcessTokenizationErrorCode;
  /** Name of a field that caused the error. A value of `null` indicates that the error isn't associated with a particular field. */
  field: Maybe<Scalars['String']>;
  /** The error message. */
  message: Maybe<Scalars['String']>;
};

export type PaymentMethodProcessTokenizationErrorCode =
  | 'CHANNEL_INACTIVE'
  | 'GATEWAY_ERROR'
  | 'GRAPHQL_ERROR'
  | 'INVALID'
  | 'NOT_FOUND';

/** Event sent when user continues a tokenization of payment method. */
export type PaymentMethodProcessTokenizationSession = Event & {
  __typename: 'PaymentMethodProcessTokenizationSession';
  /** Channel related to the requested action. */
  channel: Channel;
  /** Payment gateway data in JSON format, received from storefront. */
  data: Maybe<Scalars['JSON']>;
  /** The ID returned by app from `PAYMENT_METHOD_INITIALIZE_TOKENIZATION_SESSION` webhook. */
  id: Scalars['String'];
  /** Time of the event. */
  issuedAt: Maybe<Scalars['DateTime']>;
  /** The user or application that triggered the event. */
  issuingPrincipal: Maybe<IssuingPrincipal>;
  /** The application receiving the webhook. */
  recipient: Maybe<App>;
  /** The user related to the requested action. */
  user: User;
  /** Saleor version that triggered the event. */
  version: Maybe<Scalars['String']>;
};

export type PaymentMethodRequestDeleteError = {
  __typename: 'PaymentMethodRequestDeleteError';
  /** The error code. */
  code: StoredPaymentMethodRequestDeleteErrorCode;
  /** Name of a field that caused the error. A value of `null` indicates that the error isn't associated with a particular field. */
  field: Maybe<Scalars['String']>;
  /** The error message. */
  message: Maybe<Scalars['String']>;
};

/**
 * Result of tokenization of payment method.
 *
 *     SUCCESSFULLY_TOKENIZED - The payment method was successfully tokenized.
 *     ADDITIONAL_ACTION_REQUIRED - The additional action is required to tokenize payment
 *     method.
 *     PENDING - The payment method is pending tokenization.
 *     FAILED_TO_TOKENIZE - The payment method was not tokenized.
 *     FAILED_TO_DELIVER - The request to tokenize payment method was not delivered.
 */
export type PaymentMethodTokenizationResult =
  | 'ADDITIONAL_ACTION_REQUIRED'
  | 'FAILED_TO_DELIVER'
  | 'FAILED_TO_TOKENIZE'
  | 'PENDING'
  | 'SUCCESSFULLY_TOKENIZED';

/**
 * Represents possible payment method types.
 *
 *     The following types are possible:
 *     CARD - represents a card payment method.
 *     OTHER - represents any payment method that is not a card payment.
 */
export type PaymentMethodTypeEnum =
  | 'CARD'
  | 'OTHER';

export type PaymentMethodTypeEnumFilterInput = {
  /** The value equal to. */
  eq: InputMaybe<PaymentMethodTypeEnum>;
  /** The value included in. */
  oneOf: InputMaybe<Array<PaymentMethodTypeEnum>>;
};

/** Process payment. */
export type PaymentProcessEvent = Event & {
  __typename: 'PaymentProcessEvent';
  /** Time of the event. */
  issuedAt: Maybe<Scalars['DateTime']>;
  /** The user or application that triggered the event. */
  issuingPrincipal: Maybe<IssuingPrincipal>;
  /** Look up a payment. */
  payment: Maybe<Payment>;
  /** The application receiving the webhook. */
  recipient: Maybe<App>;
  /** Saleor version that triggered the event. */
  version: Maybe<Scalars['String']>;
};

/**
 * Refunds the captured payment amount.
 *
 * Requires one of the following permissions: MANAGE_ORDERS.
 */
export type PaymentRefund = {
  __typename: 'PaymentRefund';
  errors: Array<PaymentError>;
  /** Updated payment. */
  payment: Maybe<Payment>;
  /** @deprecated Use `errors` field instead. */
  paymentErrors: Array<PaymentError>;
};

/** Refund payment. */
export type PaymentRefundEvent = Event & {
  __typename: 'PaymentRefundEvent';
  /** Time of the event. */
  issuedAt: Maybe<Scalars['DateTime']>;
  /** The user or application that triggered the event. */
  issuingPrincipal: Maybe<IssuingPrincipal>;
  /** Look up a payment. */
  payment: Maybe<Payment>;
  /** The application receiving the webhook. */
  recipient: Maybe<App>;
  /** Saleor version that triggered the event. */
  version: Maybe<Scalars['String']>;
};

/** Represents the channel-specific payment settings. */
export type PaymentSettings = {
  __typename: 'PaymentSettings';
  /**
   * Specifies the earliest date on which funds for expired checkouts can begin to be released. Expired checkouts dated before this cut-off will not have their funds released. Additionally, no funds will be released for checkouts that are more than one year old, regardless of the cut-off date.
   *
   * Added in Saleor 3.20.
   */
  checkoutReleaseFundsCutOffDate: Maybe<Scalars['DateTime']>;
  /**
   * The time in hours after which funds for expired checkouts will be released.
   *
   * Added in Saleor 3.20.
   */
  checkoutTtlBeforeReleasingFunds: Maybe<Scalars['Hour']>;
  /** Determine the transaction flow strategy to be used. Include the selected option in the payload sent to the payment app, as a requested action for the transaction. */
  defaultTransactionFlowStrategy: TransactionFlowStrategyEnum;
  /**
   * Determine if the funds for expired checkouts should be released automatically.
   *
   * Added in Saleor 3.20.
   */
  releaseFundsForExpiredCheckouts: Maybe<Scalars['Boolean']>;
};

export type PaymentSettingsInput = {
  /**
   * Specifies the earliest date on which funds for expired checkouts can begin to be released. Expired checkouts dated before this cut-off will not have their funds released. Additionally, no funds will be released for checkouts that are more than one year old, regardless of the cut-off date.
   *
   * Added in Saleor 3.20.
   */
  checkoutReleaseFundsCutOffDate: InputMaybe<Scalars['DateTime']>;
  /**
   * The time in hours after which funds for expired checkouts will be released.
   *
   * Added in Saleor 3.20.
   */
  checkoutTtlBeforeReleasingFunds: InputMaybe<Scalars['Hour']>;
  /** Determine the transaction flow strategy to be used. Include the selected option in the payload sent to the payment app, as a requested action for the transaction. */
  defaultTransactionFlowStrategy: InputMaybe<TransactionFlowStrategyEnum>;
  /**
   * Determine if the funds for expired checkouts should be released automatically.
   *
   * Added in Saleor 3.20.
   */
  releaseFundsForExpiredCheckouts: InputMaybe<Scalars['Boolean']>;
};

/** Represents a payment source stored for user in payment gateway, such as credit card. */
export type PaymentSource = {
  __typename: 'PaymentSource';
  /** Stored credit card details if available. */
  creditCardInfo: Maybe<CreditCard>;
  /** Payment gateway name. */
  gateway: Scalars['String'];
  /**
   * List of public metadata items.
   *
   * Can be accessed without permissions.
   */
  metadata: Array<MetadataItem>;
  /** ID of stored payment method. */
  paymentMethodId: Maybe<Scalars['String']>;
};

/**
 * Voids the authorized payment.
 *
 * Requires one of the following permissions: MANAGE_ORDERS.
 */
export type PaymentVoid = {
  __typename: 'PaymentVoid';
  errors: Array<PaymentError>;
  /** Updated payment. */
  payment: Maybe<Payment>;
  /** @deprecated Use `errors` field instead. */
  paymentErrors: Array<PaymentError>;
};

/** Void payment. */
export type PaymentVoidEvent = Event & {
  __typename: 'PaymentVoidEvent';
  /** Time of the event. */
  issuedAt: Maybe<Scalars['DateTime']>;
  /** The user or application that triggered the event. */
  issuingPrincipal: Maybe<IssuingPrincipal>;
  /** Look up a payment. */
  payment: Maybe<Payment>;
  /** The application receiving the webhook. */
  recipient: Maybe<App>;
  /** Saleor version that triggered the event. */
  version: Maybe<Scalars['String']>;
};

/** Represents a permission object in a friendly form. */
export type Permission = {
  __typename: 'Permission';
  /** Internal code for permission. */
  code: PermissionEnum;
  /** Describe action(s) allowed to do by permission. */
  name: Scalars['String'];
};

export type PermissionEnum =
  | 'HANDLE_CHECKOUTS'
  | 'HANDLE_PAYMENTS'
  | 'HANDLE_TAXES'
  | 'IMPERSONATE_USER'
  | 'MANAGE_APPS'
  | 'MANAGE_CHANNELS'
  | 'MANAGE_CHECKOUTS'
  | 'MANAGE_DISCOUNTS'
  | 'MANAGE_GIFT_CARD'
  | 'MANAGE_MENUS'
  | 'MANAGE_OBSERVABILITY'
  | 'MANAGE_ORDERS'
  | 'MANAGE_ORDERS_IMPORT'
  | 'MANAGE_PAGES'
  | 'MANAGE_PAGE_TYPES_AND_ATTRIBUTES'
  | 'MANAGE_PLUGINS'
  | 'MANAGE_PRODUCTS'
  | 'MANAGE_PRODUCT_TYPES_AND_ATTRIBUTES'
  | 'MANAGE_SETTINGS'
  | 'MANAGE_SHIPPING'
  | 'MANAGE_STAFF'
  | 'MANAGE_TAXES'
  | 'MANAGE_TRANSLATIONS'
  | 'MANAGE_USERS';

/**
 * Create new permission group. Apps are not allowed to perform this mutation.
 *
 * Requires one of the following permissions: MANAGE_STAFF.
 *
 * Triggers the following webhook events:
 * - PERMISSION_GROUP_CREATED (async)
 */
export type PermissionGroupCreate = {
  __typename: 'PermissionGroupCreate';
  errors: Array<PermissionGroupError>;
  group: Maybe<Group>;
  /** @deprecated Use `errors` field instead. */
  permissionGroupErrors: Array<PermissionGroupError>;
};

export type PermissionGroupCreateInput = {
  /** List of channels to assign to this group. */
  addChannels: InputMaybe<Array<Scalars['ID']>>;
  /** List of permission code names to assign to this group. */
  addPermissions: InputMaybe<Array<PermissionEnum>>;
  /** List of users to assign to this group. */
  addUsers: InputMaybe<Array<Scalars['ID']>>;
  /** Group name. */
  name: Scalars['String'];
  /** Determine if the group has restricted access to channels.  DEFAULT: False */
  restrictedAccessToChannels: InputMaybe<Scalars['Boolean']>;
};

/** Event sent when new permission group is created. */
export type PermissionGroupCreated = Event & {
  __typename: 'PermissionGroupCreated';
  /** Time of the event. */
  issuedAt: Maybe<Scalars['DateTime']>;
  /** The user or application that triggered the event. */
  issuingPrincipal: Maybe<IssuingPrincipal>;
  /** The permission group the event relates to. */
  permissionGroup: Maybe<Group>;
  /** The application receiving the webhook. */
  recipient: Maybe<App>;
  /** Saleor version that triggered the event. */
  version: Maybe<Scalars['String']>;
};

/**
 * Delete permission group. Apps are not allowed to perform this mutation.
 *
 * Requires one of the following permissions: MANAGE_STAFF.
 *
 * Triggers the following webhook events:
 * - PERMISSION_GROUP_DELETED (async)
 */
export type PermissionGroupDelete = {
  __typename: 'PermissionGroupDelete';
  errors: Array<PermissionGroupError>;
  group: Maybe<Group>;
  /** @deprecated Use `errors` field instead. */
  permissionGroupErrors: Array<PermissionGroupError>;
};

/** Event sent when permission group is deleted. */
export type PermissionGroupDeleted = Event & {
  __typename: 'PermissionGroupDeleted';
  /** Time of the event. */
  issuedAt: Maybe<Scalars['DateTime']>;
  /** The user or application that triggered the event. */
  issuingPrincipal: Maybe<IssuingPrincipal>;
  /** The permission group the event relates to. */
  permissionGroup: Maybe<Group>;
  /** The application receiving the webhook. */
  recipient: Maybe<App>;
  /** Saleor version that triggered the event. */
  version: Maybe<Scalars['String']>;
};

export type PermissionGroupError = {
  __typename: 'PermissionGroupError';
  /** List of channels IDs which causes the error. */
  channels: Maybe<Array<Scalars['ID']>>;
  /** The error code. */
  code: PermissionGroupErrorCode;
  /** Name of a field that caused the error. A value of `null` indicates that the error isn't associated with a particular field. */
  field: Maybe<Scalars['String']>;
  /** The error message. */
  message: Maybe<Scalars['String']>;
  /** List of permissions which causes the error. */
  permissions: Maybe<Array<PermissionEnum>>;
  /** List of user IDs which causes the error. */
  users: Maybe<Array<Scalars['ID']>>;
};

export type PermissionGroupErrorCode =
  | 'ASSIGN_NON_STAFF_MEMBER'
  | 'CANNOT_REMOVE_FROM_LAST_GROUP'
  | 'DUPLICATED_INPUT_ITEM'
  | 'LEFT_NOT_MANAGEABLE_PERMISSION'
  | 'OUT_OF_SCOPE_CHANNEL'
  | 'OUT_OF_SCOPE_PERMISSION'
  | 'OUT_OF_SCOPE_USER'
  | 'REQUIRED'
  | 'UNIQUE';

export type PermissionGroupFilterInput = {
  ids: InputMaybe<Array<Scalars['ID']>>;
  search: InputMaybe<Scalars['String']>;
};

/** Sorting options for permission groups. */
export type PermissionGroupSortField =
  /** Sort permission group accounts by name. */
  | 'NAME';

export type PermissionGroupSortingInput = {
  /** Specifies the direction in which to sort permission group. */
  direction: OrderDirection;
  /** Sort permission group by the selected field. */
  field: PermissionGroupSortField;
};

/**
 * Update permission group. Apps are not allowed to perform this mutation.
 *
 * Requires one of the following permissions: MANAGE_STAFF.
 *
 * Triggers the following webhook events:
 * - PERMISSION_GROUP_UPDATED (async)
 */
export type PermissionGroupUpdate = {
  __typename: 'PermissionGroupUpdate';
  errors: Array<PermissionGroupError>;
  group: Maybe<Group>;
  /** @deprecated Use `errors` field instead. */
  permissionGroupErrors: Array<PermissionGroupError>;
};

export type PermissionGroupUpdateInput = {
  /** List of channels to assign to this group. */
  addChannels: InputMaybe<Array<Scalars['ID']>>;
  /** List of permission code names to assign to this group. */
  addPermissions: InputMaybe<Array<PermissionEnum>>;
  /** List of users to assign to this group. */
  addUsers: InputMaybe<Array<Scalars['ID']>>;
  /** Group name. */
  name: InputMaybe<Scalars['String']>;
  /** List of channels to unassign from this group. */
  removeChannels: InputMaybe<Array<Scalars['ID']>>;
  /** List of permission code names to unassign from this group. */
  removePermissions: InputMaybe<Array<PermissionEnum>>;
  /** List of users to unassign from this group. */
  removeUsers: InputMaybe<Array<Scalars['ID']>>;
  /** Determine if the group has restricted access to channels. */
  restrictedAccessToChannels: InputMaybe<Scalars['Boolean']>;
};

/** Event sent when permission group is updated. */
export type PermissionGroupUpdated = Event & {
  __typename: 'PermissionGroupUpdated';
  /** Time of the event. */
  issuedAt: Maybe<Scalars['DateTime']>;
  /** The user or application that triggered the event. */
  issuingPrincipal: Maybe<IssuingPrincipal>;
  /** The permission group the event relates to. */
  permissionGroup: Maybe<Group>;
  /** The application receiving the webhook. */
  recipient: Maybe<App>;
  /** Saleor version that triggered the event. */
  version: Maybe<Scalars['String']>;
};

/** Plugin. */
export type Plugin = {
  __typename: 'Plugin';
  /** Channel-specific plugin configuration. */
  channelConfigurations: Array<PluginConfiguration>;
  /** Description of the plugin. */
  description: Scalars['String'];
  /** Global configuration of the plugin (not channel-specific). */
  globalConfiguration: Maybe<PluginConfiguration>;
  /** Identifier of the plugin. */
  id: Scalars['ID'];
  /** Name of the plugin. */
  name: Scalars['String'];
};

/** Stores information about a configuration of plugin. */
export type PluginConfiguration = {
  __typename: 'PluginConfiguration';
  /** Determines if plugin is active or not. */
  active: Scalars['Boolean'];
  /** The channel to which the plugin configuration is assigned to. */
  channel: Maybe<Channel>;
  /** Configuration of the plugin. */
  configuration: Maybe<Array<ConfigurationItem>>;
};

export type PluginConfigurationType =
  | 'GLOBAL'
  | 'PER_CHANNEL';

export type PluginCountableConnection = {
  __typename: 'PluginCountableConnection';
  edges: Array<PluginCountableEdge>;
  /** Pagination data for this connection. */
  pageInfo: PageInfo;
  /** A total count of items in the collection. */
  totalCount: Maybe<Scalars['Int']>;
};

export type PluginCountableEdge = {
  __typename: 'PluginCountableEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node: Plugin;
};

export type PluginError = {
  __typename: 'PluginError';
  /** The error code. */
  code: PluginErrorCode;
  /** Name of a field that caused the error. A value of `null` indicates that the error isn't associated with a particular field. */
  field: Maybe<Scalars['String']>;
  /** The error message. */
  message: Maybe<Scalars['String']>;
};

export type PluginErrorCode =
  | 'GRAPHQL_ERROR'
  | 'INVALID'
  | 'NOT_FOUND'
  | 'PLUGIN_MISCONFIGURED'
  | 'REQUIRED'
  | 'UNIQUE';

export type PluginFilterInput = {
  search: InputMaybe<Scalars['String']>;
  statusInChannels: InputMaybe<PluginStatusInChannelsInput>;
  type: InputMaybe<PluginConfigurationType>;
};

export type PluginSortField =
  | 'IS_ACTIVE'
  | 'NAME';

export type PluginSortingInput = {
  /** Specifies the direction in which to sort plugins. */
  direction: OrderDirection;
  /** Sort plugins by the selected field. */
  field: PluginSortField;
};

export type PluginStatusInChannelsInput = {
  active: Scalars['Boolean'];
  channels: Array<Scalars['ID']>;
};

/**
 * Update plugin configuration.
 *
 * Requires one of the following permissions: MANAGE_PLUGINS.
 */
export type PluginUpdate = {
  __typename: 'PluginUpdate';
  errors: Array<PluginError>;
  plugin: Maybe<Plugin>;
  /** @deprecated Use `errors` field instead. */
  pluginsErrors: Array<PluginError>;
};

export type PluginUpdateInput = {
  /** Indicates whether the plugin should be enabled. */
  active: InputMaybe<Scalars['Boolean']>;
  /** Configuration of the plugin. */
  configuration: InputMaybe<Array<ConfigurationItemInput>>;
};

export type PostalCodeRuleInclusionTypeEnum =
  | 'EXCLUDE'
  | 'INCLUDE';

/** Represents preorder settings for product variant. */
export type PreorderData = {
  __typename: 'PreorderData';
  /** Preorder end date. */
  endDate: Maybe<Scalars['DateTime']>;
  /**
   * Total number of sold product variant during preorder.
   *
   * Requires one of the following permissions: MANAGE_PRODUCTS.
   */
  globalSoldUnits: Scalars['Int'];
  /**
   * The global preorder threshold for product variant.
   *
   * Requires one of the following permissions: MANAGE_PRODUCTS.
   */
  globalThreshold: Maybe<Scalars['Int']>;
};

export type PreorderSettingsInput = {
  /** The end date for preorder. */
  endDate: InputMaybe<Scalars['DateTime']>;
  /** The global threshold for preorder variant. */
  globalThreshold: InputMaybe<Scalars['Int']>;
};

/** Represents preorder variant data for channel. */
export type PreorderThreshold = {
  __typename: 'PreorderThreshold';
  /** Preorder threshold for product variant in this channel. */
  quantity: Maybe<Scalars['Int']>;
  /** Number of sold product variant in this channel. */
  soldUnits: Scalars['Int'];
};

export type PriceFilterInput = {
  /** The amount of the price to filter by. */
  amount: DecimalFilterInput;
  /** The currency of the price to filter by. */
  currency: InputMaybe<Scalars['String']>;
};

export type PriceInput = {
  /** Amount of money. */
  amount: Scalars['PositiveDecimal'];
  /** Currency code. */
  currency: Scalars['String'];
};

export type PriceRangeInput = {
  /** Price greater than or equal to. */
  gte: InputMaybe<Scalars['Float']>;
  /** Price less than or equal to. */
  lte: InputMaybe<Scalars['Float']>;
};

/** Represents an individual item for sale in the storefront. */
export type Product = Node & ObjectWithAttributes & ObjectWithMetadata & {
  __typename: 'Product';
  /**
   * Get a single attribute attached to product by attribute slug.
   *
   * Added in Saleor 3.22.
   */
  assignedAttribute: Maybe<AssignedAttribute>;
  /**
   * List of attributes assigned to this product.
   *
   * Added in Saleor 3.22.
   */
  assignedAttributes: Array<AssignedAttribute>;
  /**
   * Get a single attribute attached to product by attribute slug.
   * @deprecated Use the `assignedAttribute` field instead.
   */
  attribute: Maybe<SelectedAttribute>;
  /**
   * List of attributes assigned to this product.
   * @deprecated Use the `assignedAttributes` field instead.
   */
  attributes: Array<SelectedAttribute>;
  /**
   * Date when product is available for purchase.
   * @deprecated Use the `availableForPurchaseAt` field to fetch the available for purchase date.
   */
  availableForPurchase: Maybe<Scalars['Date']>;
  /** Date when product is available for purchase. */
  availableForPurchaseAt: Maybe<Scalars['DateTime']>;
  category: Maybe<Category>;
  /** Channel given to retrieve this product. Also used by federation gateway to resolve this object in a federated query. */
  channel: Maybe<Scalars['String']>;
  /**
   * List of availability in channels for the product.
   *
   * Requires one of the following permissions: MANAGE_PRODUCTS.
   */
  channelListings: Maybe<Array<ProductChannelListing>>;
  /** @deprecated Use `Channel.taxConfiguration` field to determine whether tax collection is enabled. */
  chargeTaxes: Scalars['Boolean'];
  /** List of collections for the product. Requires the following permissions to include the unpublished items: MANAGE_ORDERS, MANAGE_DISCOUNTS, MANAGE_PRODUCTS. */
  collections: Maybe<Array<Collection>>;
  /** The date and time when the product was created. */
  created: Scalars['DateTime'];
  /** Default variant of the product. */
  defaultVariant: Maybe<ProductVariant>;
  /**
   * Description of the product.
   *
   * Rich text format. For reference see https://editorjs.io/
   */
  description: Maybe<Scalars['JSONString']>;
  /**
   * Description of the product.
   *
   * Rich text format. For reference see https://editorjs.io/
   * @deprecated Use the `description` field instead.
   */
  descriptionJson: Maybe<Scalars['JSONString']>;
  /** External ID of this product. */
  externalReference: Maybe<Scalars['String']>;
  /** The ID of the product. */
  id: Scalars['ID'];
  /**
   * Get a single product image by ID.
   * @deprecated Use the `mediaById` field instead.
   */
  imageById: Maybe<ProductImage>;
  /**
   * List of images for the product.
   * @deprecated Use the `media` field instead.
   */
  images: Maybe<Array<ProductImage>>;
  /** Whether the product is in stock, set as available for purchase in the given channel, and published. */
  isAvailable: Maybe<Scalars['Boolean']>;
  /** Refers to a state that can be set by admins to control whether a product is available for purchase in storefronts. This does not guarantee the availability of stock. When set to `False`, this product is still visible to customers, but it cannot be purchased. */
  isAvailableForPurchase: Maybe<Scalars['Boolean']>;
  /** List of media for the product. */
  media: Maybe<Array<ProductMedia>>;
  /** Get a single product media by ID. */
  mediaById: Maybe<ProductMedia>;
  /** List of public metadata items. Can be accessed without permissions. */
  metadata: Array<MetadataItem>;
  /**
   * A single key from public metadata.
   *
   * Tip: Use GraphQL aliases to fetch multiple keys.
   */
  metafield: Maybe<Scalars['String']>;
  /** Public metadata. Use `keys` to control which fields you want to include. The default is to include everything. */
  metafields: Maybe<Scalars['Metadata']>;
  /** SEO description of the product. */
  name: Scalars['String'];
  /** Lists the storefront product's pricing, the current price and discounts, only meant for displaying. */
  pricing: Maybe<ProductPricingInfo>;
  /** List of private metadata items. Requires staff permissions to access. */
  privateMetadata: Array<MetadataItem>;
  /**
   * A single key from private metadata. Requires staff permissions to access.
   *
   * Tip: Use GraphQL aliases to fetch multiple keys.
   */
  privateMetafield: Maybe<Scalars['String']>;
  /** Private metadata. Requires staff permissions to access. Use `keys` to control which fields you want to include. The default is to include everything. */
  privateMetafields: Maybe<Scalars['Metadata']>;
  /** Type of the product. */
  productType: ProductType;
  /**
   * List of variants for the product. Requires the following permissions to include the unpublished items: MANAGE_ORDERS, MANAGE_DISCOUNTS, MANAGE_PRODUCTS.
   *
   * Added in Saleor 3.21.
   */
  productVariants: Maybe<ProductVariantCountableConnection>;
  /** Rating of the product. */
  rating: Maybe<Scalars['Float']>;
  /** SEO description of the product. */
  seoDescription: Maybe<Scalars['String']>;
  /** SEO title of the product. */
  seoTitle: Maybe<Scalars['String']>;
  /** Slug of the product. */
  slug: Scalars['String'];
  /**
   * Tax class assigned to this product type. All products of this product type use this tax class, unless it's overridden in the `Product` type.
   *
   * Requires one of the following permissions: AUTHENTICATED_STAFF_USER, AUTHENTICATED_APP.
   */
  taxClass: Maybe<TaxClass>;
  /**
   * A type of tax. Assigned by enabled tax gateway
   * @deprecated Use `taxClass` field instead.
   */
  taxType: Maybe<TaxType>;
  /** Thumbnail of the product. */
  thumbnail: Maybe<Image>;
  /** Returns translated product fields for the given language code. */
  translation: Maybe<ProductTranslation>;
  /** The date and time when the product was last updated. */
  updatedAt: Scalars['DateTime'];
  /**
   * Get a single variant by SKU or ID.
   * @deprecated Use top-level `variant` query.
   */
  variant: Maybe<ProductVariant>;
  /**
   * List of variants for the product. Requires the following permissions to include the unpublished items: MANAGE_ORDERS, MANAGE_DISCOUNTS, MANAGE_PRODUCTS.
   * @deprecated Use `productVariants` field instead.
   */
  variants: Maybe<Array<ProductVariant>>;
  /** Weight of the product. */
  weight: Maybe<Weight>;
};


/** Represents an individual item for sale in the storefront. */
export type ProductAssignedAttributeArgs = {
  slug: Scalars['String'];
};


/** Represents an individual item for sale in the storefront. */
export type ProductAssignedAttributesArgs = {
  limit?: InputMaybe<Scalars['PositiveInt']>;
};


/** Represents an individual item for sale in the storefront. */
export type ProductAttributeArgs = {
  slug: Scalars['String'];
};


/** Represents an individual item for sale in the storefront. */
export type ProductImageByIdArgs = {
  id: Scalars['ID'];
};


/** Represents an individual item for sale in the storefront. */
export type ProductIsAvailableArgs = {
  address: InputMaybe<AddressInput>;
};


/** Represents an individual item for sale in the storefront. */
export type ProductMediaArgs = {
  sortBy: InputMaybe<MediaSortingInput>;
};


/** Represents an individual item for sale in the storefront. */
export type ProductMediaByIdArgs = {
  id: Scalars['ID'];
};


/** Represents an individual item for sale in the storefront. */
export type ProductMetafieldArgs = {
  key: Scalars['String'];
};


/** Represents an individual item for sale in the storefront. */
export type ProductMetafieldsArgs = {
  keys: InputMaybe<Array<Scalars['String']>>;
};


/** Represents an individual item for sale in the storefront. */
export type ProductPricingArgs = {
  address: InputMaybe<AddressInput>;
};


/** Represents an individual item for sale in the storefront. */
export type ProductPrivateMetafieldArgs = {
  key: Scalars['String'];
};


/** Represents an individual item for sale in the storefront. */
export type ProductPrivateMetafieldsArgs = {
  keys: InputMaybe<Array<Scalars['String']>>;
};


/** Represents an individual item for sale in the storefront. */
export type ProductProductVariantsArgs = {
  after: InputMaybe<Scalars['String']>;
  before: InputMaybe<Scalars['String']>;
  filter: InputMaybe<ProductVariantFilterInput>;
  first: InputMaybe<Scalars['Int']>;
  last: InputMaybe<Scalars['Int']>;
  sortBy: InputMaybe<ProductVariantSortingInput>;
  where: InputMaybe<ProductVariantWhereInput>;
};


/** Represents an individual item for sale in the storefront. */
export type ProductThumbnailArgs = {
  format?: InputMaybe<ThumbnailFormatEnum>;
  size: InputMaybe<Scalars['Int']>;
};


/** Represents an individual item for sale in the storefront. */
export type ProductTranslationArgs = {
  languageCode: LanguageCodeEnum;
};


/** Represents an individual item for sale in the storefront. */
export type ProductVariantArgs = {
  id: InputMaybe<Scalars['ID']>;
  sku: InputMaybe<Scalars['String']>;
};

/**
 * Assign attributes to a given product type.
 *
 * Requires one of the following permissions: MANAGE_PRODUCT_TYPES_AND_ATTRIBUTES.
 */
export type ProductAttributeAssign = {
  __typename: 'ProductAttributeAssign';
  errors: Array<ProductError>;
  /** @deprecated Use `errors` field instead. */
  productErrors: Array<ProductError>;
  /** The updated product type. */
  productType: Maybe<ProductType>;
};

export type ProductAttributeAssignInput = {
  /** The ID of the attribute to assign. */
  id: Scalars['ID'];
  /** The attribute type to be assigned as. */
  type: ProductAttributeType;
  /** Whether attribute is allowed in variant selection. Allowed types are: ['dropdown', 'boolean', 'swatch', 'numeric']. */
  variantSelection: InputMaybe<Scalars['Boolean']>;
};

/**
 * Update attributes assigned to product variant for given product type.
 *
 * Requires one of the following permissions: MANAGE_PRODUCT_TYPES_AND_ATTRIBUTES.
 */
export type ProductAttributeAssignmentUpdate = {
  __typename: 'ProductAttributeAssignmentUpdate';
  errors: Array<ProductError>;
  /** @deprecated Use `errors` field instead. */
  productErrors: Array<ProductError>;
  /** The updated product type. */
  productType: Maybe<ProductType>;
};

export type ProductAttributeAssignmentUpdateInput = {
  /** The ID of the attribute to assign. */
  id: Scalars['ID'];
  /** Whether attribute is allowed in variant selection. Allowed types are: ['dropdown', 'boolean', 'swatch', 'numeric']. */
  variantSelection: Scalars['Boolean'];
};

export type ProductAttributeType =
  | 'PRODUCT'
  | 'VARIANT';

/**
 * Un-assign attributes from a given product type.
 *
 * Requires one of the following permissions: MANAGE_PRODUCT_TYPES_AND_ATTRIBUTES.
 */
export type ProductAttributeUnassign = {
  __typename: 'ProductAttributeUnassign';
  errors: Array<ProductError>;
  /** @deprecated Use `errors` field instead. */
  productErrors: Array<ProductError>;
  /** The updated product type. */
  productType: Maybe<ProductType>;
};

/**
 * Creates products.
 *
 * Requires one of the following permissions: MANAGE_PRODUCTS.
 */
export type ProductBulkCreate = {
  __typename: 'ProductBulkCreate';
  /** Returns how many objects were created. */
  count: Scalars['Int'];
  errors: Array<ProductBulkCreateError>;
  /** List of the created products. */
  results: Array<ProductBulkResult>;
};

export type ProductBulkCreateError = {
  __typename: 'ProductBulkCreateError';
  /** List of attributes IDs which causes the error. */
  attributes: Maybe<Array<Scalars['ID']>>;
  /** List of channel IDs which causes the error. */
  channels: Maybe<Array<Scalars['ID']>>;
  /** The error code. */
  code: ProductBulkCreateErrorCode;
  /** The error message. */
  message: Maybe<Scalars['String']>;
  /** Path to field that caused the error. A value of `null` indicates that the error isn't associated with a particular field. */
  path: Maybe<Scalars['String']>;
  /** List of attribute values IDs which causes the error. */
  values: Maybe<Array<Scalars['ID']>>;
  /** List of warehouse IDs which causes the error. */
  warehouses: Maybe<Array<Scalars['ID']>>;
};

export type ProductBulkCreateErrorCode =
  | 'ATTRIBUTE_ALREADY_ASSIGNED'
  | 'ATTRIBUTE_CANNOT_BE_ASSIGNED'
  | 'ATTRIBUTE_VARIANTS_DISABLED'
  | 'BLANK'
  | 'DUPLICATED_INPUT_ITEM'
  | 'GRAPHQL_ERROR'
  | 'INVALID'
  | 'INVALID_PRICE'
  | 'MAX_LENGTH'
  | 'NOT_FOUND'
  | 'PRODUCT_NOT_ASSIGNED_TO_CHANNEL'
  | 'PRODUCT_WITHOUT_CATEGORY'
  | 'REQUIRED'
  | 'UNIQUE'
  | 'UNSUPPORTED_MEDIA_PROVIDER';

export type ProductBulkCreateInput = {
  /** List of attributes. */
  attributes: InputMaybe<Array<AttributeValueInput>>;
  /** ID of the product's category. */
  category: InputMaybe<Scalars['ID']>;
  /** List of channels in which the product is available. */
  channelListings: InputMaybe<Array<ProductChannelListingCreateInput>>;
  /**
   * Determine if taxes are being charged for the product.
   * @deprecated Use `Channel.taxConfiguration` to configure whether tax collection is enabled.
   */
  chargeTaxes: InputMaybe<Scalars['Boolean']>;
  /** List of IDs of collections that the product belongs to. */
  collections: InputMaybe<Array<Scalars['ID']>>;
  /**
   * Product description.
   *
   * Rich text format. For reference see https://editorjs.io/
   */
  description: InputMaybe<Scalars['JSONString']>;
  /** External ID of this product. */
  externalReference: InputMaybe<Scalars['String']>;
  /** List of media inputs associated with the product. */
  media: InputMaybe<Array<MediaInput>>;
  /**
   * Fields required to update the product metadata. Can be read by any API client authorized to read the object it's attached to.
   *
   * Warning: never store sensitive information, including financial data such as credit card details.
   */
  metadata: InputMaybe<Array<MetadataInput>>;
  /** Product name. */
  name: InputMaybe<Scalars['String']>;
  /**
   * Fields required to update the product private metadata. Requires permissions to modify and to read the metadata of the object it's attached to.
   *
   * Warning: never store sensitive information, including financial data such as credit card details.
   */
  privateMetadata: InputMaybe<Array<MetadataInput>>;
  /** ID of the type that product belongs to. */
  productType: Scalars['ID'];
  /** Defines the product rating value. */
  rating: InputMaybe<Scalars['Float']>;
  /** Search engine optimization fields. */
  seo: InputMaybe<SeoInput>;
  /** Product slug. */
  slug: InputMaybe<Scalars['String']>;
  /** ID of a tax class to assign to this product. If not provided, product will use the tax class which is assigned to the product type. */
  taxClass: InputMaybe<Scalars['ID']>;
  /**
   * Tax rate for enabled tax gateway.
   * @deprecated Use tax classes to control the tax calculation for a product. If taxCode is provided, Saleor will try to find a tax class with given code (codes are stored in metadata) and assign it. If no tax class is found, it would be created and assigned.
   */
  taxCode: InputMaybe<Scalars['String']>;
  /** Input list of product variants to create. */
  variants: InputMaybe<Array<ProductVariantBulkCreateInput>>;
  /** Weight of the Product. */
  weight: InputMaybe<Scalars['WeightScalar']>;
};

/**
 * Deletes products.
 *
 * Requires one of the following permissions: MANAGE_PRODUCTS.
 */
export type ProductBulkDelete = {
  __typename: 'ProductBulkDelete';
  /** Returns how many objects were affected. */
  count: Scalars['Int'];
  errors: Array<ProductError>;
  /** @deprecated Use `errors` field instead. */
  productErrors: Array<ProductError>;
};

export type ProductBulkResult = {
  __typename: 'ProductBulkResult';
  /** List of errors occurred on create attempt. */
  errors: Maybe<Array<ProductBulkCreateError>>;
  /** Product data. */
  product: Maybe<Product>;
};

/**
 * Creates/updates translations for products.
 *
 * Requires one of the following permissions: MANAGE_TRANSLATIONS.
 *
 * Triggers the following webhook events:
 * - TRANSLATION_CREATED (async): Called when a translation was created.
 * - TRANSLATION_UPDATED (async): Called when a translation was updated.
 */
export type ProductBulkTranslate = {
  __typename: 'ProductBulkTranslate';
  /** Returns how many translations were created/updated. */
  count: Scalars['Int'];
  errors: Array<ProductBulkTranslateError>;
  /** List of the translations. */
  results: Array<ProductBulkTranslateResult>;
};

export type ProductBulkTranslateError = {
  __typename: 'ProductBulkTranslateError';
  /** The error code. */
  code: ProductTranslateErrorCode;
  /** The error message. */
  message: Maybe<Scalars['String']>;
  /** Path to field that caused the error. A value of `null` indicates that the error isn't associated with a particular field. */
  path: Maybe<Scalars['String']>;
};

export type ProductBulkTranslateInput = {
  /** External reference of an product. */
  externalReference: InputMaybe<Scalars['String']>;
  /** Product ID. */
  id: InputMaybe<Scalars['ID']>;
  /** Translation language code. */
  languageCode: LanguageCodeEnum;
  /** Translation fields. */
  translationFields: TranslationInput;
};

export type ProductBulkTranslateResult = {
  __typename: 'ProductBulkTranslateResult';
  /** List of errors occurred on translation attempt. */
  errors: Maybe<Array<ProductBulkTranslateError>>;
  /** Product translation data. */
  translation: Maybe<ProductTranslation>;
};

/** Represents product channel listing. */
export type ProductChannelListing = Node & {
  __typename: 'ProductChannelListing';
  /** @deprecated Use the `availableForPurchaseAt` field to fetch the available for purchase date. */
  availableForPurchase: Maybe<Scalars['Date']>;
  /** The product available for purchase date time. */
  availableForPurchaseAt: Maybe<Scalars['DateTime']>;
  /** The channel in which the product is listed. */
  channel: Channel;
  /** The price of the cheapest variant (including discounts). */
  discountedPrice: Maybe<Money>;
  /** The ID of the product channel listing. */
  id: Scalars['ID'];
  /** Refers to a state that can be set by admins to control whether a product is available for purchase in storefronts in this channel. This does not guarantee the availability of stock. When set to `False`, this product is still visible to customers, but it cannot be purchased. */
  isAvailableForPurchase: Maybe<Scalars['Boolean']>;
  /** Indicates if the product is published in the channel. */
  isPublished: Scalars['Boolean'];
  /**
   * Range of margin percentage value.
   *
   * Requires one of the following permissions: MANAGE_PRODUCTS.
   */
  margin: Maybe<Margin>;
  /** Lists the storefront product's pricing, the current price and discounts, only meant for displaying. */
  pricing: Maybe<ProductPricingInfo>;
  /** @deprecated Use the `publishedAt` field to fetch the publication date. */
  publicationDate: Maybe<Scalars['Date']>;
  /** The product publication date time. */
  publishedAt: Maybe<Scalars['DateTime']>;
  /**
   * Purchase cost of product.
   *
   * Requires one of the following permissions: MANAGE_PRODUCTS.
   */
  purchaseCost: Maybe<MoneyRange>;
  /** Indicates product visibility in the channel listings. */
  visibleInListings: Scalars['Boolean'];
};


/** Represents product channel listing. */
export type ProductChannelListingPricingArgs = {
  address: InputMaybe<AddressInput>;
};

export type ProductChannelListingAddInput = {
  /** List of variants to which the channel should be assigned. */
  addVariants: InputMaybe<Array<Scalars['ID']>>;
  /** A start date time from which a product will be available for purchase. When not set and `isAvailable` is set to True, the current day is assumed. */
  availableForPurchaseAt: InputMaybe<Scalars['DateTime']>;
  /**
   * A start date from which a product will be available for purchase. When not set and isAvailable is set to True, the current day is assumed.
   * @deprecated Use `availableForPurchaseAt` field instead.
   */
  availableForPurchaseDate: InputMaybe<Scalars['Date']>;
  /** ID of a channel. */
  channelId: Scalars['ID'];
  /** Determines if product should be available for purchase in this channel. This does not guarantee the availability of stock. When set to `False`, this product is still visible to customers, but it cannot be purchased. */
  isAvailableForPurchase: InputMaybe<Scalars['Boolean']>;
  /** Determines if object is visible to customers. */
  isPublished: InputMaybe<Scalars['Boolean']>;
  /**
   * Publication date. ISO 8601 standard.
   * @deprecated Use `publishedAt` field instead.
   */
  publicationDate: InputMaybe<Scalars['Date']>;
  /** Publication date time. ISO 8601 standard. */
  publishedAt: InputMaybe<Scalars['DateTime']>;
  /** List of variants from which the channel should be unassigned. */
  removeVariants: InputMaybe<Array<Scalars['ID']>>;
  /** Determines if product is visible in product listings (doesn't apply to product collections). */
  visibleInListings: InputMaybe<Scalars['Boolean']>;
};

export type ProductChannelListingCreateInput = {
  /** A start date time from which a product will be available for purchase. When not set and `isAvailable` is set to True, the current day is assumed. */
  availableForPurchaseAt: InputMaybe<Scalars['DateTime']>;
  /** ID of a channel. */
  channelId: Scalars['ID'];
  /** Determines if product should be available for purchase in this channel. This does not guarantee the availability of stock. When set to `False`, this product is still visible to customers, but it cannot be purchased. */
  isAvailableForPurchase: InputMaybe<Scalars['Boolean']>;
  /** Determines if object is visible to customers. */
  isPublished: InputMaybe<Scalars['Boolean']>;
  /** Publication date time. ISO 8601 standard. */
  publishedAt: InputMaybe<Scalars['DateTime']>;
  /** Determines if product is visible in product listings (doesn't apply to product collections). */
  visibleInListings: InputMaybe<Scalars['Boolean']>;
};

export type ProductChannelListingError = {
  __typename: 'ProductChannelListingError';
  /** List of attributes IDs which causes the error. */
  attributes: Maybe<Array<Scalars['ID']>>;
  /** List of channels IDs which causes the error. */
  channels: Maybe<Array<Scalars['ID']>>;
  /** The error code. */
  code: ProductErrorCode;
  /** Name of a field that caused the error. A value of `null` indicates that the error isn't associated with a particular field. */
  field: Maybe<Scalars['String']>;
  /** The error message. */
  message: Maybe<Scalars['String']>;
  /** List of attribute values IDs which causes the error. */
  values: Maybe<Array<Scalars['ID']>>;
  /** List of variants IDs which causes the error. */
  variants: Maybe<Array<Scalars['ID']>>;
};

/**
 * Manage product's availability in channels.
 *
 * Requires one of the following permissions: MANAGE_PRODUCTS.
 */
export type ProductChannelListingUpdate = {
  __typename: 'ProductChannelListingUpdate';
  errors: Array<ProductChannelListingError>;
  /** An updated product instance. */
  product: Maybe<Product>;
  /** @deprecated Use `errors` field instead. */
  productChannelListingErrors: Array<ProductChannelListingError>;
};

export type ProductChannelListingUpdateInput = {
  /** List of channels from which the product should be unassigned. */
  removeChannels: InputMaybe<Array<Scalars['ID']>>;
  /** List of channels to which the product should be assigned or updated. */
  updateChannels: InputMaybe<Array<ProductChannelListingAddInput>>;
};

export type ProductCountableConnection = {
  __typename: 'ProductCountableConnection';
  edges: Array<ProductCountableEdge>;
  /** Pagination data for this connection. */
  pageInfo: PageInfo;
  /** A total count of items in the collection. */
  totalCount: Maybe<Scalars['Int']>;
};

export type ProductCountableEdge = {
  __typename: 'ProductCountableEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node: Product;
};

/**
 * Creates a new product.
 *
 * Requires one of the following permissions: MANAGE_PRODUCTS.
 */
export type ProductCreate = {
  __typename: 'ProductCreate';
  errors: Array<ProductError>;
  product: Maybe<Product>;
  /** @deprecated Use `errors` field instead. */
  productErrors: Array<ProductError>;
};

export type ProductCreateInput = {
  /** List of attributes. */
  attributes: InputMaybe<Array<AttributeValueInput>>;
  /** ID of the product's category. */
  category: InputMaybe<Scalars['ID']>;
  /**
   * Determine if taxes are being charged for the product.
   * @deprecated Use `Channel.taxConfiguration` to configure whether tax collection is enabled.
   */
  chargeTaxes: InputMaybe<Scalars['Boolean']>;
  /** List of IDs of collections that the product belongs to. */
  collections: InputMaybe<Array<Scalars['ID']>>;
  /**
   * Product description.
   *
   * Rich text format. For reference see https://editorjs.io/
   */
  description: InputMaybe<Scalars['JSONString']>;
  /** External ID of this product. */
  externalReference: InputMaybe<Scalars['String']>;
  /**
   * Fields required to update the product metadata. Can be read by any API client authorized to read the object it's attached to.
   *
   * Warning: never store sensitive information, including financial data such as credit card details.
   */
  metadata: InputMaybe<Array<MetadataInput>>;
  /** Product name. */
  name: InputMaybe<Scalars['String']>;
  /**
   * Fields required to update the product private metadata. Requires permissions to modify and to read the metadata of the object it's attached to.
   *
   * Warning: never store sensitive information, including financial data such as credit card details.
   */
  privateMetadata: InputMaybe<Array<MetadataInput>>;
  /** ID of the type that product belongs to. */
  productType: Scalars['ID'];
  /** Defines the product rating value. */
  rating: InputMaybe<Scalars['Float']>;
  /** Search engine optimization fields. */
  seo: InputMaybe<SeoInput>;
  /** Product slug. */
  slug: InputMaybe<Scalars['String']>;
  /** ID of a tax class to assign to this product. If not provided, product will use the tax class which is assigned to the product type. */
  taxClass: InputMaybe<Scalars['ID']>;
  /**
   * Tax rate for enabled tax gateway.
   * @deprecated Use tax classes to control the tax calculation for a product. If taxCode is provided, Saleor will try to find a tax class with given code (codes are stored in metadata) and assign it. If no tax class is found, it would be created and assigned.
   */
  taxCode: InputMaybe<Scalars['String']>;
  /** Weight of the Product. */
  weight: InputMaybe<Scalars['WeightScalar']>;
};

/** Event sent when new product is created. */
export type ProductCreated = Event & {
  __typename: 'ProductCreated';
  /** The category of the product. */
  category: Maybe<Category>;
  /** Time of the event. */
  issuedAt: Maybe<Scalars['DateTime']>;
  /** The user or application that triggered the event. */
  issuingPrincipal: Maybe<IssuingPrincipal>;
  /** The product the event relates to. */
  product: Maybe<Product>;
  /** The application receiving the webhook. */
  recipient: Maybe<App>;
  /** Saleor version that triggered the event. */
  version: Maybe<Scalars['String']>;
};


/** Event sent when new product is created. */
export type ProductCreatedProductArgs = {
  channel: InputMaybe<Scalars['String']>;
};

/**
 * Deletes a product.
 *
 * Requires one of the following permissions: MANAGE_PRODUCTS.
 */
export type ProductDelete = {
  __typename: 'ProductDelete';
  errors: Array<ProductError>;
  product: Maybe<Product>;
  /** @deprecated Use `errors` field instead. */
  productErrors: Array<ProductError>;
};

/** Event sent when product is deleted. */
export type ProductDeleted = Event & {
  __typename: 'ProductDeleted';
  /** The category of the product. */
  category: Maybe<Category>;
  /** Time of the event. */
  issuedAt: Maybe<Scalars['DateTime']>;
  /** The user or application that triggered the event. */
  issuingPrincipal: Maybe<IssuingPrincipal>;
  /** The product the event relates to. */
  product: Maybe<Product>;
  /** The application receiving the webhook. */
  recipient: Maybe<App>;
  /** Saleor version that triggered the event. */
  version: Maybe<Scalars['String']>;
};


/** Event sent when product is deleted. */
export type ProductDeletedProductArgs = {
  channel: InputMaybe<Scalars['String']>;
};

export type ProductError = {
  __typename: 'ProductError';
  /** List of attributes IDs which causes the error. */
  attributes: Maybe<Array<Scalars['ID']>>;
  /** The error code. */
  code: ProductErrorCode;
  /** Name of a field that caused the error. A value of `null` indicates that the error isn't associated with a particular field. */
  field: Maybe<Scalars['String']>;
  /** The error message. */
  message: Maybe<Scalars['String']>;
  /** List of attribute values IDs which causes the error. */
  values: Maybe<Array<Scalars['ID']>>;
};

export type ProductErrorCode =
  | 'ALREADY_EXISTS'
  | 'ATTRIBUTE_ALREADY_ASSIGNED'
  | 'ATTRIBUTE_CANNOT_BE_ASSIGNED'
  | 'ATTRIBUTE_VARIANTS_DISABLED'
  | 'CANNOT_MANAGE_PRODUCT_WITHOUT_VARIANT'
  | 'DUPLICATED_INPUT_ITEM'
  | 'GRAPHQL_ERROR'
  | 'INVALID'
  | 'INVALID_FILE_TYPE'
  | 'INVALID_PRICE'
  | 'MEDIA_ALREADY_ASSIGNED'
  | 'NOT_FOUND'
  | 'NOT_PRODUCTS_IMAGE'
  | 'NOT_PRODUCTS_VARIANT'
  | 'PREORDER_VARIANT_CANNOT_BE_DEACTIVATED'
  | 'PRODUCT_NOT_ASSIGNED_TO_CHANNEL'
  | 'PRODUCT_WITHOUT_CATEGORY'
  | 'REQUIRED'
  | 'UNIQUE'
  | 'UNSUPPORTED_MEDIA_PROVIDER'
  | 'UNSUPPORTED_MIME_TYPE'
  | 'VARIANT_NO_DIGITAL_CONTENT';

/** Event sent when product export is completed. */
export type ProductExportCompleted = Event & {
  __typename: 'ProductExportCompleted';
  /** The export file for products. */
  export: Maybe<ExportFile>;
  /** Time of the event. */
  issuedAt: Maybe<Scalars['DateTime']>;
  /** The user or application that triggered the event. */
  issuingPrincipal: Maybe<IssuingPrincipal>;
  /** The application receiving the webhook. */
  recipient: Maybe<App>;
  /** Saleor version that triggered the event. */
  version: Maybe<Scalars['String']>;
};

export type ProductFieldEnum =
  | 'CATEGORY'
  | 'CHARGE_TAXES'
  | 'COLLECTIONS'
  | 'DESCRIPTION'
  | 'NAME'
  | 'PRODUCT_MEDIA'
  | 'PRODUCT_TYPE'
  | 'PRODUCT_WEIGHT'
  | 'VARIANT_ID'
  | 'VARIANT_MEDIA'
  | 'VARIANT_SKU'
  | 'VARIANT_WEIGHT';

export type ProductFilterInput = {
  attributes: InputMaybe<Array<AttributeInput>>;
  /** Filter by the date of availability for purchase. */
  availableFrom: InputMaybe<Scalars['DateTime']>;
  categories: InputMaybe<Array<Scalars['ID']>>;
  /**
   * Specifies the channel by which the data should be filtered.
   * @deprecated Use root-level channel argument instead.
   */
  channel: InputMaybe<Scalars['String']>;
  collections: InputMaybe<Array<Scalars['ID']>>;
  /** Filter on whether product is a gift card or not. */
  giftCard: InputMaybe<Scalars['Boolean']>;
  hasCategory: InputMaybe<Scalars['Boolean']>;
  hasPreorderedVariants: InputMaybe<Scalars['Boolean']>;
  ids: InputMaybe<Array<Scalars['ID']>>;
  /** Filter by availability for purchase. */
  isAvailable: InputMaybe<Scalars['Boolean']>;
  isPublished: InputMaybe<Scalars['Boolean']>;
  /** Filter by visibility in product listings. */
  isVisibleInListing: InputMaybe<Scalars['Boolean']>;
  metadata: InputMaybe<Array<MetadataFilter>>;
  /** Filter by the lowest variant price after discounts. */
  minimalPrice: InputMaybe<PriceRangeInput>;
  price: InputMaybe<PriceRangeInput>;
  productTypes: InputMaybe<Array<Scalars['ID']>>;
  /** Filter by the publication date. */
  publishedFrom: InputMaybe<Scalars['DateTime']>;
  search: InputMaybe<Scalars['String']>;
  slugs: InputMaybe<Array<Scalars['String']>>;
  /** Filter by variants having specific stock status. */
  stockAvailability: InputMaybe<StockAvailability>;
  stocks: InputMaybe<ProductStockFilterInput>;
  /** Filter by when was the most recent update. */
  updatedAt: InputMaybe<DateTimeRangeInput>;
};

/** Represents a product image. */
export type ProductImage = {
  __typename: 'ProductImage';
  /** The alt text of the image. */
  alt: Maybe<Scalars['String']>;
  /** The ID of the image. */
  id: Scalars['ID'];
  /** The new relative sorting position of the item (from -inf to +inf). 1 moves the item one position forward, -1 moves the item one position backward, 0 leaves the item unchanged. */
  sortOrder: Maybe<Scalars['Int']>;
  /** The URL of the image. */
  url: Scalars['String'];
};


/** Represents a product image. */
export type ProductImageUrlArgs = {
  format?: InputMaybe<ThumbnailFormatEnum>;
  size: InputMaybe<Scalars['Int']>;
};

export type ProductInput = {
  /** List of attributes. */
  attributes: InputMaybe<Array<AttributeValueInput>>;
  /** ID of the product's category. */
  category: InputMaybe<Scalars['ID']>;
  /**
   * Determine if taxes are being charged for the product.
   * @deprecated Use `Channel.taxConfiguration` to configure whether tax collection is enabled.
   */
  chargeTaxes: InputMaybe<Scalars['Boolean']>;
  /** List of IDs of collections that the product belongs to. */
  collections: InputMaybe<Array<Scalars['ID']>>;
  /**
   * Product description.
   *
   * Rich text format. For reference see https://editorjs.io/
   */
  description: InputMaybe<Scalars['JSONString']>;
  /** External ID of this product. */
  externalReference: InputMaybe<Scalars['String']>;
  /**
   * Fields required to update the product metadata. Can be read by any API client authorized to read the object it's attached to.
   *
   * Warning: never store sensitive information, including financial data such as credit card details.
   */
  metadata: InputMaybe<Array<MetadataInput>>;
  /** Product name. */
  name: InputMaybe<Scalars['String']>;
  /**
   * Fields required to update the product private metadata. Requires permissions to modify and to read the metadata of the object it's attached to.
   *
   * Warning: never store sensitive information, including financial data such as credit card details.
   */
  privateMetadata: InputMaybe<Array<MetadataInput>>;
  /** Defines the product rating value. */
  rating: InputMaybe<Scalars['Float']>;
  /** Search engine optimization fields. */
  seo: InputMaybe<SeoInput>;
  /** Product slug. */
  slug: InputMaybe<Scalars['String']>;
  /** ID of a tax class to assign to this product. If not provided, product will use the tax class which is assigned to the product type. */
  taxClass: InputMaybe<Scalars['ID']>;
  /**
   * Tax rate for enabled tax gateway.
   * @deprecated Use tax classes to control the tax calculation for a product. If taxCode is provided, Saleor will try to find a tax class with given code (codes are stored in metadata) and assign it. If no tax class is found, it would be created and assigned.
   */
  taxCode: InputMaybe<Scalars['String']>;
  /** Weight of the Product. */
  weight: InputMaybe<Scalars['WeightScalar']>;
};

/** Represents a product media. */
export type ProductMedia = Node & ObjectWithMetadata & {
  __typename: 'ProductMedia';
  /** The alt text of the media. */
  alt: Scalars['String'];
  /** The unique ID of the product media. */
  id: Scalars['ID'];
  /** List of public metadata items. Can be accessed without permissions. */
  metadata: Array<MetadataItem>;
  /**
   * A single key from public metadata.
   *
   * Tip: Use GraphQL aliases to fetch multiple keys.
   */
  metafield: Maybe<Scalars['String']>;
  /** Public metadata. Use `keys` to control which fields you want to include. The default is to include everything. */
  metafields: Maybe<Scalars['Metadata']>;
  /** The oEmbed data of the media. */
  oembedData: Scalars['JSONString'];
  /** List of private metadata items. Requires staff permissions to access. */
  privateMetadata: Array<MetadataItem>;
  /**
   * A single key from private metadata. Requires staff permissions to access.
   *
   * Tip: Use GraphQL aliases to fetch multiple keys.
   */
  privateMetafield: Maybe<Scalars['String']>;
  /** Private metadata. Requires staff permissions to access. Use `keys` to control which fields you want to include. The default is to include everything. */
  privateMetafields: Maybe<Scalars['Metadata']>;
  /** Product id the media refers to. */
  productId: Maybe<Scalars['ID']>;
  /** The sort order of the media. */
  sortOrder: Maybe<Scalars['Int']>;
  /** The type of the media. */
  type: ProductMediaType;
  /** The URL of the media. */
  url: Scalars['String'];
};


/** Represents a product media. */
export type ProductMediaMetafieldArgs = {
  key: Scalars['String'];
};


/** Represents a product media. */
export type ProductMediaMetafieldsArgs = {
  keys: InputMaybe<Array<Scalars['String']>>;
};


/** Represents a product media. */
export type ProductMediaPrivateMetafieldArgs = {
  key: Scalars['String'];
};


/** Represents a product media. */
export type ProductMediaPrivateMetafieldsArgs = {
  keys: InputMaybe<Array<Scalars['String']>>;
};


/** Represents a product media. */
export type ProductMediaUrlArgs = {
  format?: InputMaybe<ThumbnailFormatEnum>;
  size: InputMaybe<Scalars['Int']>;
};

/**
 * Deletes product media.
 *
 * Requires one of the following permissions: MANAGE_PRODUCTS.
 */
export type ProductMediaBulkDelete = {
  __typename: 'ProductMediaBulkDelete';
  /** Returns how many objects were affected. */
  count: Scalars['Int'];
  errors: Array<ProductError>;
  /** @deprecated Use `errors` field instead. */
  productErrors: Array<ProductError>;
};

/**
 * Create a media object (image or video URL) associated with product. For image, this mutation must be sent as a `multipart` request. More detailed specs of the upload format can be found here: https://github.com/jaydenseric/graphql-multipart-request-spec
 *
 * Requires one of the following permissions: MANAGE_PRODUCTS.
 */
export type ProductMediaCreate = {
  __typename: 'ProductMediaCreate';
  errors: Array<ProductError>;
  media: Maybe<ProductMedia>;
  product: Maybe<Product>;
  /** @deprecated Use `errors` field instead. */
  productErrors: Array<ProductError>;
};

export type ProductMediaCreateInput = {
  /** Alt text for a product media. */
  alt: InputMaybe<Scalars['String']>;
  /** Represents an image file in a multipart request. */
  image: InputMaybe<Scalars['Upload']>;
  /** Represents an URL to an external media. */
  mediaUrl: InputMaybe<Scalars['String']>;
  /** ID of an product. */
  product: Scalars['ID'];
};

/** Event sent when new product media is created. */
export type ProductMediaCreated = Event & {
  __typename: 'ProductMediaCreated';
  /** Time of the event. */
  issuedAt: Maybe<Scalars['DateTime']>;
  /** The user or application that triggered the event. */
  issuingPrincipal: Maybe<IssuingPrincipal>;
  /** The product media the event relates to. */
  productMedia: Maybe<ProductMedia>;
  /** The application receiving the webhook. */
  recipient: Maybe<App>;
  /** Saleor version that triggered the event. */
  version: Maybe<Scalars['String']>;
};

/**
 * Deletes a product media.
 *
 * Requires one of the following permissions: MANAGE_PRODUCTS.
 */
export type ProductMediaDelete = {
  __typename: 'ProductMediaDelete';
  errors: Array<ProductError>;
  media: Maybe<ProductMedia>;
  product: Maybe<Product>;
  /** @deprecated Use `errors` field instead. */
  productErrors: Array<ProductError>;
};

/** Event sent when product media is deleted. */
export type ProductMediaDeleted = Event & {
  __typename: 'ProductMediaDeleted';
  /** Time of the event. */
  issuedAt: Maybe<Scalars['DateTime']>;
  /** The user or application that triggered the event. */
  issuingPrincipal: Maybe<IssuingPrincipal>;
  /** The product media the event relates to. */
  productMedia: Maybe<ProductMedia>;
  /** The application receiving the webhook. */
  recipient: Maybe<App>;
  /** Saleor version that triggered the event. */
  version: Maybe<Scalars['String']>;
};

/**
 * Changes ordering of the product media.
 *
 * Requires one of the following permissions: MANAGE_PRODUCTS.
 */
export type ProductMediaReorder = {
  __typename: 'ProductMediaReorder';
  errors: Array<ProductError>;
  media: Maybe<Array<ProductMedia>>;
  product: Maybe<Product>;
  /** @deprecated Use `errors` field instead. */
  productErrors: Array<ProductError>;
};

export type ProductMediaType =
  | 'IMAGE'
  | 'VIDEO';

/**
 * Updates a product media.
 *
 * Requires one of the following permissions: MANAGE_PRODUCTS.
 */
export type ProductMediaUpdate = {
  __typename: 'ProductMediaUpdate';
  errors: Array<ProductError>;
  media: Maybe<ProductMedia>;
  product: Maybe<Product>;
  /** @deprecated Use `errors` field instead. */
  productErrors: Array<ProductError>;
};

export type ProductMediaUpdateInput = {
  /** Alt text for a product media. */
  alt: InputMaybe<Scalars['String']>;
};

/** Event sent when product media is updated. */
export type ProductMediaUpdated = Event & {
  __typename: 'ProductMediaUpdated';
  /** Time of the event. */
  issuedAt: Maybe<Scalars['DateTime']>;
  /** The user or application that triggered the event. */
  issuingPrincipal: Maybe<IssuingPrincipal>;
  /** The product media the event relates to. */
  productMedia: Maybe<ProductMedia>;
  /** The application receiving the webhook. */
  recipient: Maybe<App>;
  /** Saleor version that triggered the event. */
  version: Maybe<Scalars['String']>;
};

/** Event sent when product metadata is updated. */
export type ProductMetadataUpdated = Event & {
  __typename: 'ProductMetadataUpdated';
  /** The category of the product. */
  category: Maybe<Category>;
  /** Time of the event. */
  issuedAt: Maybe<Scalars['DateTime']>;
  /** The user or application that triggered the event. */
  issuingPrincipal: Maybe<IssuingPrincipal>;
  /** The product the event relates to. */
  product: Maybe<Product>;
  /** The application receiving the webhook. */
  recipient: Maybe<App>;
  /** Saleor version that triggered the event. */
  version: Maybe<Scalars['String']>;
};


/** Event sent when product metadata is updated. */
export type ProductMetadataUpdatedProductArgs = {
  channel: InputMaybe<Scalars['String']>;
};

export type ProductOrder = {
  /**
   * Sort product by the selected attribute's values.
   * Note: this doesn't take translations into account yet.
   */
  attributeId: InputMaybe<Scalars['ID']>;
  /**
   * Specifies the channel in which to sort the data.
   * @deprecated Use root-level channel argument instead.
   */
  channel: InputMaybe<Scalars['String']>;
  /** Specifies the direction in which to sort products. */
  direction: OrderDirection;
  /** Sort products by the selected field. */
  field: InputMaybe<ProductOrderField>;
};

export type ProductOrderField =
  /**
   * Sort products by collection. Note: This option is available only for the `Collection.products` query.
   *
   * This option requires a channel filter to work as the values can vary between channels.
   */
  | 'COLLECTION'
  /** Sort products by creation date. */
  | 'CREATED_AT'
  /** Sort products by update date. */
  | 'DATE'
  /** Sort products by update date. */
  | 'LAST_MODIFIED'
  /** Sort products by update date. */
  | 'LAST_MODIFIED_AT'
  /**
   * Sort products by a minimal price of a product's variant.
   *
   * This option requires a channel filter to work as the values can vary between channels.
   */
  | 'MINIMAL_PRICE'
  /** Sort products by name. */
  | 'NAME'
  /**
   * Sort products by price.
   *
   * This option requires a channel filter to work as the values can vary between channels.
   */
  | 'PRICE'
  /**
   * Sort products by publication date.
   *
   * This option requires a channel filter to work as the values can vary between channels.
   */
  | 'PUBLICATION_DATE'
  /**
   * Sort products by publication status.
   *
   * This option requires a channel filter to work as the values can vary between channels.
   */
  | 'PUBLISHED'
  /**
   * Sort products by publication date.
   *
   * This option requires a channel filter to work as the values can vary between channels.
   */
  | 'PUBLISHED_AT'
  /** Sort products by rank. Note: This option is available only with the `search` filter. */
  | 'RANK'
  /** Sort products by rating. */
  | 'RATING'
  /** Sort products by type. */
  | 'TYPE';

/** Represents availability of a product in the storefront. */
export type ProductPricingInfo = {
  __typename: 'ProductPricingInfo';
  /** The discount amount if in sale (null otherwise). */
  discount: Maybe<TaxedMoney>;
  /**
   * The discount amount in the local currency.
   * @deprecated Always returns `null`.
   */
  discountLocalCurrency: Maybe<TaxedMoney>;
  /**
   * The discount amount compared to prior price. Null if product is not on sale or prior price was not provided in VariantChannelListing
   *
   * Added in Saleor 3.21.
   */
  discountPrior: Maybe<TaxedMoney>;
  /** Determines whether displayed prices should include taxes. */
  displayGrossPrices: Scalars['Boolean'];
  /** Whether it is in sale or not. */
  onSale: Maybe<Scalars['Boolean']>;
  /** The discounted price range of the product variants. */
  priceRange: Maybe<TaxedMoneyRange>;
  /**
   * The discounted price range of the product variants in the local currency.
   * @deprecated Always returns `null`.
   */
  priceRangeLocalCurrency: Maybe<TaxedMoneyRange>;
  /**
   * The prior price range of the product variants.
   *
   * Added in Saleor 3.21.
   */
  priceRangePrior: Maybe<TaxedMoneyRange>;
  /** The undiscounted price range of the product variants. */
  priceRangeUndiscounted: Maybe<TaxedMoneyRange>;
};

/**
 * Reorder product attribute values.
 *
 * Requires one of the following permissions: MANAGE_PRODUCTS.
 */
export type ProductReorderAttributeValues = {
  __typename: 'ProductReorderAttributeValues';
  errors: Array<ProductError>;
  /** Product from which attribute values are reordered. */
  product: Maybe<Product>;
  /** @deprecated Use `errors` field instead. */
  productErrors: Array<ProductError>;
};

export type ProductStockFilterInput = {
  quantity: InputMaybe<IntRangeInput>;
  warehouseIds: InputMaybe<Array<Scalars['ID']>>;
};

/** Represents product's original translatable fields and related translations. */
export type ProductTranslatableContent = Node & {
  __typename: 'ProductTranslatableContent';
  /** List of product attribute values that can be translated. */
  attributeValues: Array<AttributeValueTranslatableContent>;
  /**
   * Product's description to translate.
   *
   * Rich text format. For reference see https://editorjs.io/
   */
  description: Maybe<Scalars['JSONString']>;
  /**
   * Description of the product.
   *
   * Rich text format. For reference see https://editorjs.io/
   * @deprecated Use the `description` field instead.
   */
  descriptionJson: Maybe<Scalars['JSONString']>;
  /** The ID of the product translatable content. */
  id: Scalars['ID'];
  /** Product's name to translate. */
  name: Scalars['String'];
  /**
   * Represents an individual item for sale in the storefront.
   * @deprecated Get model fields from the root level queries.
   */
  product: Maybe<Product>;
  /** The ID of the product to translate. */
  productId: Scalars['ID'];
  /** SEO description to translate. */
  seoDescription: Maybe<Scalars['String']>;
  /** SEO title to translate. */
  seoTitle: Maybe<Scalars['String']>;
  /**
   * Slug to translate.
   *
   * Added in Saleor 3.21.
   */
  slug: Maybe<Scalars['String']>;
  /** Returns translated product fields for the given language code. */
  translation: Maybe<ProductTranslation>;
};


/** Represents product's original translatable fields and related translations. */
export type ProductTranslatableContentTranslationArgs = {
  languageCode: LanguageCodeEnum;
};

/**
 * Creates/updates translations for a product.
 *
 * Requires one of the following permissions: MANAGE_TRANSLATIONS.
 */
export type ProductTranslate = {
  __typename: 'ProductTranslate';
  errors: Array<TranslationError>;
  product: Maybe<Product>;
  /** @deprecated Use `errors` field instead. */
  translationErrors: Array<TranslationError>;
};

export type ProductTranslateErrorCode =
  | 'GRAPHQL_ERROR'
  | 'INVALID'
  | 'NOT_FOUND'
  | 'REQUIRED';

/** Represents product translations. */
export type ProductTranslation = Node & {
  __typename: 'ProductTranslation';
  /**
   * Translated description of the product.
   *
   * Rich text format. For reference see https://editorjs.io/
   */
  description: Maybe<Scalars['JSONString']>;
  /**
   * Translated description of the product.
   *
   * Rich text format. For reference see https://editorjs.io/
   * @deprecated Use the `description` field instead.
   */
  descriptionJson: Maybe<Scalars['JSONString']>;
  /** The ID of the product translation. */
  id: Scalars['ID'];
  /** Translation language. */
  language: LanguageDisplay;
  /** Translated product name. */
  name: Maybe<Scalars['String']>;
  /** Translated SEO description. */
  seoDescription: Maybe<Scalars['String']>;
  /** Translated SEO title. */
  seoTitle: Maybe<Scalars['String']>;
  /**
   * Translated product slug.
   *
   * Added in Saleor 3.21.
   */
  slug: Maybe<Scalars['String']>;
  /** Represents the product fields to translate. */
  translatableContent: Maybe<ProductTranslatableContent>;
};

/** Represents a type of product. It defines what attributes are available to products of this type. */
export type ProductType = Node & ObjectWithMetadata & {
  __typename: 'ProductType';
  /** Variant attributes of that product type with attached variant selection. */
  assignedVariantAttributes: Maybe<Array<AssignedVariantAttribute>>;
  /**
   * List of attributes which can be assigned to this product type.
   *
   * Requires one of the following permissions: MANAGE_PRODUCTS.
   */
  availableAttributes: Maybe<AttributeCountableConnection>;
  /** Whether the product type has variants. */
  hasVariants: Scalars['Boolean'];
  /** The ID of the product type. */
  id: Scalars['ID'];
  /** Whether the product type is digital. */
  isDigital: Scalars['Boolean'];
  /** Whether shipping is required for this product type. */
  isShippingRequired: Scalars['Boolean'];
  /** The product type kind. */
  kind: ProductTypeKindEnum;
  /** List of public metadata items. Can be accessed without permissions. */
  metadata: Array<MetadataItem>;
  /**
   * A single key from public metadata.
   *
   * Tip: Use GraphQL aliases to fetch multiple keys.
   */
  metafield: Maybe<Scalars['String']>;
  /** Public metadata. Use `keys` to control which fields you want to include. The default is to include everything. */
  metafields: Maybe<Scalars['Metadata']>;
  /** Name of the product type. */
  name: Scalars['String'];
  /** List of private metadata items. Requires staff permissions to access. */
  privateMetadata: Array<MetadataItem>;
  /**
   * A single key from private metadata. Requires staff permissions to access.
   *
   * Tip: Use GraphQL aliases to fetch multiple keys.
   */
  privateMetafield: Maybe<Scalars['String']>;
  /** Private metadata. Requires staff permissions to access. Use `keys` to control which fields you want to include. The default is to include everything. */
  privateMetafields: Maybe<Scalars['Metadata']>;
  /** Product attributes of that product type. */
  productAttributes: Maybe<Array<Attribute>>;
  /**
   * List of products of this type.
   * @deprecated Use the top-level `products` query with the `productTypes` filter.
   */
  products: Maybe<ProductCountableConnection>;
  /** Slug of the product type. */
  slug: Scalars['String'];
  /**
   * Tax class assigned to this product type. All products of this product type use this tax class, unless it's overridden in the `Product` type.
   *
   * Requires one of the following permissions: AUTHENTICATED_STAFF_USER, AUTHENTICATED_APP.
   */
  taxClass: Maybe<TaxClass>;
  /**
   * A type of tax. Assigned by enabled tax gateway
   * @deprecated Use `taxClass` field instead.
   */
  taxType: Maybe<TaxType>;
  /**
   * Variant attributes of that product type.
   * @deprecated Use `assignedVariantAttributes` instead.
   */
  variantAttributes: Maybe<Array<Attribute>>;
  /** Weight of the product type. */
  weight: Maybe<Weight>;
};


/** Represents a type of product. It defines what attributes are available to products of this type. */
export type ProductTypeAssignedVariantAttributesArgs = {
  variantSelection: InputMaybe<VariantAttributeScope>;
};


/** Represents a type of product. It defines what attributes are available to products of this type. */
export type ProductTypeAvailableAttributesArgs = {
  after: InputMaybe<Scalars['String']>;
  before: InputMaybe<Scalars['String']>;
  filter: InputMaybe<AttributeFilterInput>;
  first: InputMaybe<Scalars['Int']>;
  last: InputMaybe<Scalars['Int']>;
  search: InputMaybe<Scalars['String']>;
  where: InputMaybe<AttributeWhereInput>;
};


/** Represents a type of product. It defines what attributes are available to products of this type. */
export type ProductTypeMetafieldArgs = {
  key: Scalars['String'];
};


/** Represents a type of product. It defines what attributes are available to products of this type. */
export type ProductTypeMetafieldsArgs = {
  keys: InputMaybe<Array<Scalars['String']>>;
};


/** Represents a type of product. It defines what attributes are available to products of this type. */
export type ProductTypePrivateMetafieldArgs = {
  key: Scalars['String'];
};


/** Represents a type of product. It defines what attributes are available to products of this type. */
export type ProductTypePrivateMetafieldsArgs = {
  keys: InputMaybe<Array<Scalars['String']>>;
};


/** Represents a type of product. It defines what attributes are available to products of this type. */
export type ProductTypeProductsArgs = {
  after: InputMaybe<Scalars['String']>;
  before: InputMaybe<Scalars['String']>;
  channel: InputMaybe<Scalars['String']>;
  first: InputMaybe<Scalars['Int']>;
  last: InputMaybe<Scalars['Int']>;
};


/** Represents a type of product. It defines what attributes are available to products of this type. */
export type ProductTypeVariantAttributesArgs = {
  variantSelection: InputMaybe<VariantAttributeScope>;
};

/**
 * Deletes product types.
 *
 * Requires one of the following permissions: MANAGE_PRODUCT_TYPES_AND_ATTRIBUTES.
 */
export type ProductTypeBulkDelete = {
  __typename: 'ProductTypeBulkDelete';
  /** Returns how many objects were affected. */
  count: Scalars['Int'];
  errors: Array<ProductError>;
  /** @deprecated Use `errors` field instead. */
  productErrors: Array<ProductError>;
};

export type ProductTypeConfigurable =
  | 'CONFIGURABLE'
  | 'SIMPLE';

export type ProductTypeCountableConnection = {
  __typename: 'ProductTypeCountableConnection';
  edges: Array<ProductTypeCountableEdge>;
  /** Pagination data for this connection. */
  pageInfo: PageInfo;
  /** A total count of items in the collection. */
  totalCount: Maybe<Scalars['Int']>;
};

export type ProductTypeCountableEdge = {
  __typename: 'ProductTypeCountableEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node: ProductType;
};

/**
 * Creates a new product type.
 *
 * Requires one of the following permissions: MANAGE_PRODUCT_TYPES_AND_ATTRIBUTES.
 */
export type ProductTypeCreate = {
  __typename: 'ProductTypeCreate';
  errors: Array<ProductError>;
  /** @deprecated Use `errors` field instead. */
  productErrors: Array<ProductError>;
  productType: Maybe<ProductType>;
};

/**
 * Deletes a product type.
 *
 * Requires one of the following permissions: MANAGE_PRODUCT_TYPES_AND_ATTRIBUTES.
 */
export type ProductTypeDelete = {
  __typename: 'ProductTypeDelete';
  errors: Array<ProductError>;
  /** @deprecated Use `errors` field instead. */
  productErrors: Array<ProductError>;
  productType: Maybe<ProductType>;
};

export type ProductTypeEnum =
  | 'DIGITAL'
  | 'SHIPPABLE';

export type ProductTypeFilterInput = {
  configurable: InputMaybe<ProductTypeConfigurable>;
  ids: InputMaybe<Array<Scalars['ID']>>;
  kind: InputMaybe<ProductTypeKindEnum>;
  metadata: InputMaybe<Array<MetadataFilter>>;
  productType: InputMaybe<ProductTypeEnum>;
  search: InputMaybe<Scalars['String']>;
  slugs: InputMaybe<Array<Scalars['String']>>;
};

export type ProductTypeInput = {
  /** Determines if product of this type has multiple variants. This option mainly simplifies product management in the dashboard. There is always at least one variant created under the hood. */
  hasVariants: InputMaybe<Scalars['Boolean']>;
  /** Determines if products are digital. */
  isDigital: InputMaybe<Scalars['Boolean']>;
  /** Determines if shipping is required for products of this variant. */
  isShippingRequired: InputMaybe<Scalars['Boolean']>;
  /** The product type kind. */
  kind: InputMaybe<ProductTypeKindEnum>;
  /** Name of the product type. */
  name: InputMaybe<Scalars['String']>;
  /** List of attributes shared among all product variants. */
  productAttributes: InputMaybe<Array<Scalars['ID']>>;
  /** Product type slug. */
  slug: InputMaybe<Scalars['String']>;
  /** ID of a tax class to assign to this product type. All products of this product type would use this tax class, unless it's overridden in the `Product` type. */
  taxClass: InputMaybe<Scalars['ID']>;
  /**
   * Tax rate for enabled tax gateway.
   * @deprecated Use tax classes to control the tax calculation for a product type. If taxCode is provided, Saleor will try to find a tax class with given code (codes are stored in metadata) and assign it. If no tax class is found, it would be created and assigned.
   */
  taxCode: InputMaybe<Scalars['String']>;
  /** List of attributes used to distinguish between different variants of a product. */
  variantAttributes: InputMaybe<Array<Scalars['ID']>>;
  /** Weight of the ProductType items. */
  weight: InputMaybe<Scalars['WeightScalar']>;
};

export type ProductTypeKindEnum =
  | 'GIFT_CARD'
  | 'NORMAL';

/**
 * Reorder the attributes of a product type.
 *
 * Requires one of the following permissions: MANAGE_PRODUCT_TYPES_AND_ATTRIBUTES.
 */
export type ProductTypeReorderAttributes = {
  __typename: 'ProductTypeReorderAttributes';
  errors: Array<ProductError>;
  /** @deprecated Use `errors` field instead. */
  productErrors: Array<ProductError>;
  /** Product type from which attributes are reordered. */
  productType: Maybe<ProductType>;
};

export type ProductTypeSortField =
  /** Sort products by type. */
  | 'DIGITAL'
  /** Sort products by name. */
  | 'NAME'
  /** Sort products by shipping. */
  | 'SHIPPING_REQUIRED';

export type ProductTypeSortingInput = {
  /** Specifies the direction in which to sort product types. */
  direction: OrderDirection;
  /** Sort product types by the selected field. */
  field: ProductTypeSortField;
};

/**
 * Updates an existing product type.
 *
 * Requires one of the following permissions: MANAGE_PRODUCT_TYPES_AND_ATTRIBUTES.
 */
export type ProductTypeUpdate = {
  __typename: 'ProductTypeUpdate';
  errors: Array<ProductError>;
  /** @deprecated Use `errors` field instead. */
  productErrors: Array<ProductError>;
  productType: Maybe<ProductType>;
};

/**
 * Updates an existing product.
 *
 * Requires one of the following permissions: MANAGE_PRODUCTS.
 */
export type ProductUpdate = {
  __typename: 'ProductUpdate';
  errors: Array<ProductError>;
  product: Maybe<Product>;
  /** @deprecated Use `errors` field instead. */
  productErrors: Array<ProductError>;
};

/** Event sent when product is updated. */
export type ProductUpdated = Event & {
  __typename: 'ProductUpdated';
  /** The category of the product. */
  category: Maybe<Category>;
  /** Time of the event. */
  issuedAt: Maybe<Scalars['DateTime']>;
  /** The user or application that triggered the event. */
  issuingPrincipal: Maybe<IssuingPrincipal>;
  /** The product the event relates to. */
  product: Maybe<Product>;
  /** The application receiving the webhook. */
  recipient: Maybe<App>;
  /** Saleor version that triggered the event. */
  version: Maybe<Scalars['String']>;
};


/** Event sent when product is updated. */
export type ProductUpdatedProductArgs = {
  channel: InputMaybe<Scalars['String']>;
};

/** Represents a version of a product such as different size or color. */
export type ProductVariant = Node & ObjectWithAttributes & ObjectWithMetadata & {
  __typename: 'ProductVariant';
  /**
   * Get a single attribute attached to product by attribute slug.
   *
   * Added in Saleor 3.22.
   */
  assignedAttribute: Maybe<AssignedAttribute>;
  /**
   * List of attributes assigned to this variant.
   *
   * Added in Saleor 3.22.
   */
  assignedAttributes: Array<AssignedAttribute>;
  /**
   * List of attributes assigned to this variant.
   * @deprecated Use the `assignedAttributes` field instead.
   */
  attributes: Array<SelectedAttribute>;
  /** Channel given to retrieve this product variant. Also used by federation gateway to resolve this object in a federated query. */
  channel: Maybe<Scalars['String']>;
  /**
   * List of price information in channels for the product.
   *
   * Requires one of the following permissions: AUTHENTICATED_APP, AUTHENTICATED_STAFF_USER.
   */
  channelListings: Maybe<Array<ProductVariantChannelListing>>;
  /** The date and time when the product variant was created. */
  created: Scalars['DateTime'];
  /**
   * Digital content for the product variant.
   *
   * Requires one of the following permissions: MANAGE_PRODUCTS.
   */
  digitalContent: Maybe<DigitalContent>;
  /** External ID of this product. */
  externalReference: Maybe<Scalars['String']>;
  /** The ID of the product variant. */
  id: Scalars['ID'];
  /**
   * List of images for the product variant.
   * @deprecated Use the `media` field instead.
   */
  images: Maybe<Array<ProductImage>>;
  /** Gross margin percentage value. */
  margin: Maybe<Scalars['Int']>;
  /** List of media for the product variant. */
  media: Maybe<Array<ProductMedia>>;
  /** List of public metadata items. Can be accessed without permissions. */
  metadata: Array<MetadataItem>;
  /**
   * A single key from public metadata.
   *
   * Tip: Use GraphQL aliases to fetch multiple keys.
   */
  metafield: Maybe<Scalars['String']>;
  /** Public metadata. Use `keys` to control which fields you want to include. The default is to include everything. */
  metafields: Maybe<Scalars['Metadata']>;
  /** The name of the product variant. */
  name: Scalars['String'];
  /** Preorder data for product variant. */
  preorder: Maybe<PreorderData>;
  /** Lists the storefront variant's pricing, the current price and discounts, only meant for displaying. */
  pricing: Maybe<VariantPricingInfo>;
  /** List of private metadata items. Requires staff permissions to access. */
  privateMetadata: Array<MetadataItem>;
  /**
   * A single key from private metadata. Requires staff permissions to access.
   *
   * Tip: Use GraphQL aliases to fetch multiple keys.
   */
  privateMetafield: Maybe<Scalars['String']>;
  /** Private metadata. Requires staff permissions to access. Use `keys` to control which fields you want to include. The default is to include everything. */
  privateMetafields: Maybe<Scalars['Metadata']>;
  /** The product to which the variant belongs. */
  product: Product;
  /** Quantity of a product available for sale in one checkout. Field value will be `null` when no `limitQuantityPerCheckout` in global settings has been set, and `productVariant` stocks are not tracked. */
  quantityAvailable: Maybe<Scalars['Int']>;
  /** The maximum quantity of this variant that a customer can purchase. */
  quantityLimitPerCustomer: Maybe<Scalars['Int']>;
  /**
   * Total quantity ordered.
   *
   * Requires one of the following permissions: MANAGE_PRODUCTS.
   */
  quantityOrdered: Maybe<Scalars['Int']>;
  /**
   * Total revenue generated by a variant in given period of time. Note: this field should be queried using `reportProductSales` query as it uses optimizations suitable for such calculations.
   *
   * Requires one of the following permissions: MANAGE_PRODUCTS.
   */
  revenue: Maybe<TaxedMoney>;
  /** The SKU (stock keeping unit) of the product variant. */
  sku: Maybe<Scalars['String']>;
  /**
   * Stocks for the product variant.
   *
   * Requires one of the following permissions: MANAGE_PRODUCTS, MANAGE_ORDERS.
   */
  stocks: Maybe<Array<Stock>>;
  /** Determines if the inventory of this variant should be tracked. If false, the quantity won't change when customers buy this item. If the field is not provided, `Shop.trackInventoryByDefault` will be used. */
  trackInventory: Scalars['Boolean'];
  /** Returns translated product variant fields for the given language code. */
  translation: Maybe<ProductVariantTranslation>;
  /** The date and time when the product variant was last updated. */
  updatedAt: Scalars['DateTime'];
  /** The weight of the product variant. */
  weight: Maybe<Weight>;
};


/** Represents a version of a product such as different size or color. */
export type ProductVariantAssignedAttributeArgs = {
  slug: Scalars['String'];
};


/** Represents a version of a product such as different size or color. */
export type ProductVariantAssignedAttributesArgs = {
  limit?: InputMaybe<Scalars['PositiveInt']>;
};


/** Represents a version of a product such as different size or color. */
export type ProductVariantAttributesArgs = {
  variantSelection: InputMaybe<VariantAttributeScope>;
};


/** Represents a version of a product such as different size or color. */
export type ProductVariantMetafieldArgs = {
  key: Scalars['String'];
};


/** Represents a version of a product such as different size or color. */
export type ProductVariantMetafieldsArgs = {
  keys: InputMaybe<Array<Scalars['String']>>;
};


/** Represents a version of a product such as different size or color. */
export type ProductVariantPricingArgs = {
  address: InputMaybe<AddressInput>;
};


/** Represents a version of a product such as different size or color. */
export type ProductVariantPrivateMetafieldArgs = {
  key: Scalars['String'];
};


/** Represents a version of a product such as different size or color. */
export type ProductVariantPrivateMetafieldsArgs = {
  keys: InputMaybe<Array<Scalars['String']>>;
};


/** Represents a version of a product such as different size or color. */
export type ProductVariantQuantityAvailableArgs = {
  address: InputMaybe<AddressInput>;
  countryCode: InputMaybe<CountryCode>;
};


/** Represents a version of a product such as different size or color. */
export type ProductVariantRevenueArgs = {
  period: InputMaybe<ReportingPeriod>;
};


/** Represents a version of a product such as different size or color. */
export type ProductVariantStocksArgs = {
  address: InputMaybe<AddressInput>;
  countryCode: InputMaybe<CountryCode>;
};


/** Represents a version of a product such as different size or color. */
export type ProductVariantTranslationArgs = {
  languageCode: LanguageCodeEnum;
};

/** Event sent when product variant is back in stock. */
export type ProductVariantBackInStock = Event & {
  __typename: 'ProductVariantBackInStock';
  /** Time of the event. */
  issuedAt: Maybe<Scalars['DateTime']>;
  /** The user or application that triggered the event. */
  issuingPrincipal: Maybe<IssuingPrincipal>;
  /** The product variant the event relates to. */
  productVariant: Maybe<ProductVariant>;
  /** The application receiving the webhook. */
  recipient: Maybe<App>;
  /** Saleor version that triggered the event. */
  version: Maybe<Scalars['String']>;
  /** Look up a warehouse. */
  warehouse: Maybe<Warehouse>;
};


/** Event sent when product variant is back in stock. */
export type ProductVariantBackInStockProductVariantArgs = {
  channel: InputMaybe<Scalars['String']>;
};

/**
 * Creates product variants for a given product.
 *
 * Requires one of the following permissions: MANAGE_PRODUCTS.
 */
export type ProductVariantBulkCreate = {
  __typename: 'ProductVariantBulkCreate';
  /** @deprecated Use `errors` field instead. */
  bulkProductErrors: Array<BulkProductError>;
  /** Returns how many objects were created. */
  count: Scalars['Int'];
  errors: Array<BulkProductError>;
  /** List of the created variants. */
  productVariants: Array<ProductVariant>;
  /** List of the created variants. */
  results: Array<ProductVariantBulkResult>;
};

export type ProductVariantBulkCreateInput = {
  /** List of attributes specific to this variant. */
  attributes: Array<BulkAttributeValueInput>;
  /** List of prices assigned to channels. */
  channelListings: InputMaybe<Array<ProductVariantChannelListingAddInput>>;
  /** External ID of this product variant. */
  externalReference: InputMaybe<Scalars['String']>;
  /**
   * Fields required to update the product variant metadata. Can be read by any API client authorized to read the object it's attached to.
   *
   * Warning: never store sensitive information, including financial data such as credit card details.
   */
  metadata: InputMaybe<Array<MetadataInput>>;
  /** Variant name. */
  name: InputMaybe<Scalars['String']>;
  /** Determines if variant is in preorder. */
  preorder: InputMaybe<PreorderSettingsInput>;
  /**
   * Fields required to update the product variant private metadata. Requires permissions to modify and to read the metadata of the object it's attached to.
   *
   * Warning: never store sensitive information, including financial data such as credit card details.
   */
  privateMetadata: InputMaybe<Array<MetadataInput>>;
  /** Determines maximum quantity of `ProductVariant`,that can be bought in a single checkout. */
  quantityLimitPerCustomer: InputMaybe<Scalars['Int']>;
  /** Stock keeping unit. */
  sku: InputMaybe<Scalars['String']>;
  /** Stocks of a product available for sale. */
  stocks: InputMaybe<Array<StockInput>>;
  /** Determines if the inventory of this variant should be tracked. If false, the quantity won't change when customers buy this item. If the field is not provided, `Shop.trackInventoryByDefault` will be used. */
  trackInventory: InputMaybe<Scalars['Boolean']>;
  /** Weight of the Product Variant. */
  weight: InputMaybe<Scalars['WeightScalar']>;
};

/**
 * Deletes product variants.
 *
 * Requires one of the following permissions: MANAGE_PRODUCTS.
 */
export type ProductVariantBulkDelete = {
  __typename: 'ProductVariantBulkDelete';
  /** Returns how many objects were affected. */
  count: Scalars['Int'];
  errors: Array<ProductError>;
  /** @deprecated Use `errors` field instead. */
  productErrors: Array<ProductError>;
};

export type ProductVariantBulkError = {
  __typename: 'ProductVariantBulkError';
  /** List of attributes IDs which causes the error. */
  attributes: Maybe<Array<Scalars['ID']>>;
  /** List of channel listings IDs which causes the error. */
  channelListings: Maybe<Array<Scalars['ID']>>;
  /** List of channel IDs which causes the error. */
  channels: Maybe<Array<Scalars['ID']>>;
  /** The error code. */
  code: ProductVariantBulkErrorCode;
  /** Name of a field that caused the error. A value of `null` indicates that the error isn't associated with a particular field. */
  field: Maybe<Scalars['String']>;
  /** The error message. */
  message: Maybe<Scalars['String']>;
  /** Path to field that caused the error. A value of `null` indicates that the error isn't associated with a particular field. */
  path: Maybe<Scalars['String']>;
  /** List of stocks IDs which causes the error. */
  stocks: Maybe<Array<Scalars['ID']>>;
  /** List of attribute values IDs which causes the error. */
  values: Maybe<Array<Scalars['ID']>>;
  /** List of warehouse IDs which causes the error. */
  warehouses: Maybe<Array<Scalars['ID']>>;
};

export type ProductVariantBulkErrorCode =
  | 'ATTRIBUTE_ALREADY_ASSIGNED'
  | 'ATTRIBUTE_CANNOT_BE_ASSIGNED'
  | 'ATTRIBUTE_VARIANTS_DISABLED'
  | 'DUPLICATED_INPUT_ITEM'
  | 'GRAPHQL_ERROR'
  | 'INVALID'
  | 'INVALID_PRICE'
  | 'NOT_FOUND'
  | 'NOT_PRODUCTS_VARIANT'
  | 'PRODUCT_NOT_ASSIGNED_TO_CHANNEL'
  | 'REQUIRED'
  | 'STOCK_ALREADY_EXISTS'
  | 'UNIQUE';

export type ProductVariantBulkResult = {
  __typename: 'ProductVariantBulkResult';
  /** List of errors occurred on create attempt. */
  errors: Maybe<Array<ProductVariantBulkError>>;
  /** Product variant data. */
  productVariant: Maybe<ProductVariant>;
};

/**
 * Creates/updates translations for product variants.
 *
 * Requires one of the following permissions: MANAGE_TRANSLATIONS.
 *
 * Triggers the following webhook events:
 * - TRANSLATION_CREATED (async): A translation was created.
 * - TRANSLATION_UPDATED (async): A translation was updated.
 */
export type ProductVariantBulkTranslate = {
  __typename: 'ProductVariantBulkTranslate';
  /** Returns how many translations were created/updated. */
  count: Scalars['Int'];
  errors: Array<ProductVariantBulkTranslateError>;
  /** List of the translations. */
  results: Array<ProductVariantBulkTranslateResult>;
};

export type ProductVariantBulkTranslateError = {
  __typename: 'ProductVariantBulkTranslateError';
  /** The error code. */
  code: ProductVariantTranslateErrorCode;
  /** The error message. */
  message: Maybe<Scalars['String']>;
  /** Path to field that caused the error. A value of `null` indicates that the error isn't associated with a particular field. */
  path: Maybe<Scalars['String']>;
};

export type ProductVariantBulkTranslateInput = {
  /** External reference of a product variant. */
  externalReference: InputMaybe<Scalars['String']>;
  /** Product variant ID. */
  id: InputMaybe<Scalars['ID']>;
  /** Translation language code. */
  languageCode: LanguageCodeEnum;
  /** Translation fields. */
  translationFields: NameTranslationInput;
};

export type ProductVariantBulkTranslateResult = {
  __typename: 'ProductVariantBulkTranslateResult';
  /** List of errors occurred on translation attempt. */
  errors: Maybe<Array<ProductVariantBulkTranslateError>>;
  /** Product variant translation data. */
  translation: Maybe<ProductVariantTranslation>;
};

/**
 * Updates multiple product variants.
 *
 * Requires one of the following permissions: MANAGE_PRODUCTS.
 */
export type ProductVariantBulkUpdate = {
  __typename: 'ProductVariantBulkUpdate';
  /** Returns how many objects were updated. */
  count: Scalars['Int'];
  errors: Array<ProductVariantBulkError>;
  /** List of the updated variants. */
  results: Array<ProductVariantBulkResult>;
};

/** Input fields to update product variants. */
export type ProductVariantBulkUpdateInput = {
  /** List of attributes specific to this variant. */
  attributes: InputMaybe<Array<BulkAttributeValueInput>>;
  /** Channel listings input. */
  channelListings: InputMaybe<ProductVariantChannelListingUpdateInput>;
  /** External ID of this product variant. */
  externalReference: InputMaybe<Scalars['String']>;
  /** ID of the product variant to update. */
  id: Scalars['ID'];
  /**
   * Fields required to update the product variant metadata. Can be read by any API client authorized to read the object it's attached to.
   *
   * Warning: never store sensitive information, including financial data such as credit card details.
   */
  metadata: InputMaybe<Array<MetadataInput>>;
  /** Variant name. */
  name: InputMaybe<Scalars['String']>;
  /** Determines if variant is in preorder. */
  preorder: InputMaybe<PreorderSettingsInput>;
  /**
   * Fields required to update the product variant private metadata. Requires permissions to modify and to read the metadata of the object it's attached to.
   *
   * Warning: never store sensitive information, including financial data such as credit card details.
   */
  privateMetadata: InputMaybe<Array<MetadataInput>>;
  /** Determines maximum quantity of `ProductVariant`,that can be bought in a single checkout. */
  quantityLimitPerCustomer: InputMaybe<Scalars['Int']>;
  /** Stock keeping unit. */
  sku: InputMaybe<Scalars['String']>;
  /** Stocks input. */
  stocks: InputMaybe<ProductVariantStocksUpdateInput>;
  /** Determines if the inventory of this variant should be tracked. If false, the quantity won't change when customers buy this item. If the field is not provided, `Shop.trackInventoryByDefault` will be used. */
  trackInventory: InputMaybe<Scalars['Boolean']>;
  /** Weight of the Product Variant. */
  weight: InputMaybe<Scalars['WeightScalar']>;
};

/** Represents product variant channel listing. */
export type ProductVariantChannelListing = Node & {
  __typename: 'ProductVariantChannelListing';
  /** The channel to which the variant listing belongs. */
  channel: Channel;
  /** Cost price of the variant. */
  costPrice: Maybe<Money>;
  /** The ID of the variant channel listing. */
  id: Scalars['ID'];
  /**
   * Gross margin percentage value.
   *
   * Requires one of the following permissions: MANAGE_PRODUCTS.
   */
  margin: Maybe<Scalars['Int']>;
  /** Preorder variant data. */
  preorderThreshold: Maybe<PreorderThreshold>;
  /** The price of the variant. */
  price: Maybe<Money>;
  /**
   * Prior price of the variant used for discount calculations.
   *
   * Added in Saleor 3.21.
   */
  priorPrice: Maybe<Money>;
};

export type ProductVariantChannelListingAddInput = {
  /** ID of a channel. */
  channelId: Scalars['ID'];
  /** Cost price of the variant in channel. */
  costPrice: InputMaybe<Scalars['PositiveDecimal']>;
  /** The threshold for preorder variant in channel. */
  preorderThreshold: InputMaybe<Scalars['Int']>;
  /** Price of the particular variant in channel. */
  price: Scalars['PositiveDecimal'];
  /**
   * Previous price of the variant in channel. Useful for providing promotion information required by customer protection laws such as EU Omnibus directive.
   *
   * Added in Saleor 3.21.
   */
  priorPrice: InputMaybe<Scalars['PositiveDecimal']>;
};

/**
 * Manage product variant prices in channels.
 *
 * Requires one of the following permissions: MANAGE_PRODUCTS.
 */
export type ProductVariantChannelListingUpdate = {
  __typename: 'ProductVariantChannelListingUpdate';
  errors: Array<ProductChannelListingError>;
  /** @deprecated Use `errors` field instead. */
  productChannelListingErrors: Array<ProductChannelListingError>;
  /** An updated product variant instance. */
  variant: Maybe<ProductVariant>;
};

export type ProductVariantChannelListingUpdateInput = {
  /** List of channels to create variant channel listings. */
  create: InputMaybe<Array<ProductVariantChannelListingAddInput>>;
  /** List of channel listings to remove. */
  remove: InputMaybe<Array<Scalars['ID']>>;
  /** List of channel listings to update. */
  update: InputMaybe<Array<ChannelListingUpdateInput>>;
};

export type ProductVariantCountableConnection = {
  __typename: 'ProductVariantCountableConnection';
  edges: Array<ProductVariantCountableEdge>;
  /** Pagination data for this connection. */
  pageInfo: PageInfo;
  /** A total count of items in the collection. */
  totalCount: Maybe<Scalars['Int']>;
};

export type ProductVariantCountableEdge = {
  __typename: 'ProductVariantCountableEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node: ProductVariant;
};

/**
 * Creates a new variant for a product.
 *
 * Requires one of the following permissions: MANAGE_PRODUCTS.
 */
export type ProductVariantCreate = {
  __typename: 'ProductVariantCreate';
  errors: Array<ProductError>;
  /** @deprecated Use `errors` field instead. */
  productErrors: Array<ProductError>;
  productVariant: Maybe<ProductVariant>;
};

export type ProductVariantCreateInput = {
  /** List of attributes specific to this variant. */
  attributes: Array<AttributeValueInput>;
  /** External ID of this product variant. */
  externalReference: InputMaybe<Scalars['String']>;
  /**
   * Fields required to update the product variant metadata. Can be read by any API client authorized to read the object it's attached to.
   *
   * Warning: never store sensitive information, including financial data such as credit card details.
   */
  metadata: InputMaybe<Array<MetadataInput>>;
  /** Variant name. */
  name: InputMaybe<Scalars['String']>;
  /** Determines if variant is in preorder. */
  preorder: InputMaybe<PreorderSettingsInput>;
  /**
   * Fields required to update the product variant private metadata. Requires permissions to modify and to read the metadata of the object it's attached to.
   *
   * Warning: never store sensitive information, including financial data such as credit card details.
   */
  privateMetadata: InputMaybe<Array<MetadataInput>>;
  /** Product ID of which type is the variant. */
  product: Scalars['ID'];
  /** Determines maximum quantity of `ProductVariant`,that can be bought in a single checkout. */
  quantityLimitPerCustomer: InputMaybe<Scalars['Int']>;
  /** Stock keeping unit. */
  sku: InputMaybe<Scalars['String']>;
  /** Stocks of a product available for sale. */
  stocks: InputMaybe<Array<StockInput>>;
  /** Determines if the inventory of this variant should be tracked. If false, the quantity won't change when customers buy this item. If the field is not provided, `Shop.trackInventoryByDefault` will be used. */
  trackInventory: InputMaybe<Scalars['Boolean']>;
  /** Weight of the Product Variant. */
  weight: InputMaybe<Scalars['WeightScalar']>;
};

/** Event sent when new product variant is created. */
export type ProductVariantCreated = Event & {
  __typename: 'ProductVariantCreated';
  /** Time of the event. */
  issuedAt: Maybe<Scalars['DateTime']>;
  /** The user or application that triggered the event. */
  issuingPrincipal: Maybe<IssuingPrincipal>;
  /** The product variant the event relates to. */
  productVariant: Maybe<ProductVariant>;
  /** The application receiving the webhook. */
  recipient: Maybe<App>;
  /** Saleor version that triggered the event. */
  version: Maybe<Scalars['String']>;
};


/** Event sent when new product variant is created. */
export type ProductVariantCreatedProductVariantArgs = {
  channel: InputMaybe<Scalars['String']>;
};

/**
 * Deletes a product variant.
 *
 * Requires one of the following permissions: MANAGE_PRODUCTS.
 */
export type ProductVariantDelete = {
  __typename: 'ProductVariantDelete';
  errors: Array<ProductError>;
  /** @deprecated Use `errors` field instead. */
  productErrors: Array<ProductError>;
  productVariant: Maybe<ProductVariant>;
};

/** Event sent when product variant is deleted. */
export type ProductVariantDeleted = Event & {
  __typename: 'ProductVariantDeleted';
  /** Time of the event. */
  issuedAt: Maybe<Scalars['DateTime']>;
  /** The user or application that triggered the event. */
  issuingPrincipal: Maybe<IssuingPrincipal>;
  /** The product variant the event relates to. */
  productVariant: Maybe<ProductVariant>;
  /** The application receiving the webhook. */
  recipient: Maybe<App>;
  /** Saleor version that triggered the event. */
  version: Maybe<Scalars['String']>;
};


/** Event sent when product variant is deleted. */
export type ProductVariantDeletedProductVariantArgs = {
  channel: InputMaybe<Scalars['String']>;
};

export type ProductVariantFilterInput = {
  isPreorder: InputMaybe<Scalars['Boolean']>;
  metadata: InputMaybe<Array<MetadataFilter>>;
  search: InputMaybe<Scalars['String']>;
  sku: InputMaybe<Array<Scalars['String']>>;
  updatedAt: InputMaybe<DateTimeRangeInput>;
};

export type ProductVariantInput = {
  /** List of attributes specific to this variant. */
  attributes: InputMaybe<Array<AttributeValueInput>>;
  /** External ID of this product variant. */
  externalReference: InputMaybe<Scalars['String']>;
  /**
   * Fields required to update the product variant metadata. Can be read by any API client authorized to read the object it's attached to.
   *
   * Warning: never store sensitive information, including financial data such as credit card details.
   */
  metadata: InputMaybe<Array<MetadataInput>>;
  /** Variant name. */
  name: InputMaybe<Scalars['String']>;
  /** Determines if variant is in preorder. */
  preorder: InputMaybe<PreorderSettingsInput>;
  /**
   * Fields required to update the product variant private metadata. Requires permissions to modify and to read the metadata of the object it's attached to.
   *
   * Warning: never store sensitive information, including financial data such as credit card details.
   */
  privateMetadata: InputMaybe<Array<MetadataInput>>;
  /** Determines maximum quantity of `ProductVariant`,that can be bought in a single checkout. */
  quantityLimitPerCustomer: InputMaybe<Scalars['Int']>;
  /** Stock keeping unit. */
  sku: InputMaybe<Scalars['String']>;
  /** Determines if the inventory of this variant should be tracked. If false, the quantity won't change when customers buy this item. If the field is not provided, `Shop.trackInventoryByDefault` will be used. */
  trackInventory: InputMaybe<Scalars['Boolean']>;
  /** Weight of the Product Variant. */
  weight: InputMaybe<Scalars['WeightScalar']>;
};

/** Event sent when product variant metadata is updated. */
export type ProductVariantMetadataUpdated = Event & {
  __typename: 'ProductVariantMetadataUpdated';
  /** Time of the event. */
  issuedAt: Maybe<Scalars['DateTime']>;
  /** The user or application that triggered the event. */
  issuingPrincipal: Maybe<IssuingPrincipal>;
  /** The product variant the event relates to. */
  productVariant: Maybe<ProductVariant>;
  /** The application receiving the webhook. */
  recipient: Maybe<App>;
  /** Saleor version that triggered the event. */
  version: Maybe<Scalars['String']>;
};


/** Event sent when product variant metadata is updated. */
export type ProductVariantMetadataUpdatedProductVariantArgs = {
  channel: InputMaybe<Scalars['String']>;
};

/** Event sent when product variant is out of stock. */
export type ProductVariantOutOfStock = Event & {
  __typename: 'ProductVariantOutOfStock';
  /** Time of the event. */
  issuedAt: Maybe<Scalars['DateTime']>;
  /** The user or application that triggered the event. */
  issuingPrincipal: Maybe<IssuingPrincipal>;
  /** The product variant the event relates to. */
  productVariant: Maybe<ProductVariant>;
  /** The application receiving the webhook. */
  recipient: Maybe<App>;
  /** Saleor version that triggered the event. */
  version: Maybe<Scalars['String']>;
  /** Look up a warehouse. */
  warehouse: Maybe<Warehouse>;
};


/** Event sent when product variant is out of stock. */
export type ProductVariantOutOfStockProductVariantArgs = {
  channel: InputMaybe<Scalars['String']>;
};

/**
 * Deactivates product variant preorder. It changes all preorder allocation into regular allocation.
 *
 * Requires one of the following permissions: MANAGE_PRODUCTS.
 */
export type ProductVariantPreorderDeactivate = {
  __typename: 'ProductVariantPreorderDeactivate';
  errors: Array<ProductError>;
  /** Product variant with ended preorder. */
  productVariant: Maybe<ProductVariant>;
};

/**
 * Reorder the variants of a product. Mutation updates updated_at on product and triggers PRODUCT_UPDATED webhook.
 *
 * Requires one of the following permissions: MANAGE_PRODUCTS.
 */
export type ProductVariantReorder = {
  __typename: 'ProductVariantReorder';
  errors: Array<ProductError>;
  product: Maybe<Product>;
  /** @deprecated Use `errors` field instead. */
  productErrors: Array<ProductError>;
};

/**
 * Reorder product variant attribute values.
 *
 * Requires one of the following permissions: MANAGE_PRODUCTS.
 */
export type ProductVariantReorderAttributeValues = {
  __typename: 'ProductVariantReorderAttributeValues';
  errors: Array<ProductError>;
  /** @deprecated Use `errors` field instead. */
  productErrors: Array<ProductError>;
  /** Product variant from which attribute values are reordered. */
  productVariant: Maybe<ProductVariant>;
};

/**
 * Set default variant for a product. Mutation triggers PRODUCT_UPDATED webhook.
 *
 * Requires one of the following permissions: MANAGE_PRODUCTS.
 */
export type ProductVariantSetDefault = {
  __typename: 'ProductVariantSetDefault';
  errors: Array<ProductError>;
  product: Maybe<Product>;
  /** @deprecated Use `errors` field instead. */
  productErrors: Array<ProductError>;
};

export type ProductVariantSortField =
  /** Sort product variants by last modification date. */
  | 'LAST_MODIFIED_AT';

export type ProductVariantSortingInput = {
  /** Specifies the direction in which to sort productVariants. */
  direction: OrderDirection;
  /** Sort productVariants by the selected field. */
  field: ProductVariantSortField;
};

/** Event sent when product variant stock is updated. */
export type ProductVariantStockUpdated = Event & {
  __typename: 'ProductVariantStockUpdated';
  /** Time of the event. */
  issuedAt: Maybe<Scalars['DateTime']>;
  /** The user or application that triggered the event. */
  issuingPrincipal: Maybe<IssuingPrincipal>;
  /** The product variant the event relates to. */
  productVariant: Maybe<ProductVariant>;
  /** The application receiving the webhook. */
  recipient: Maybe<App>;
  /** Saleor version that triggered the event. */
  version: Maybe<Scalars['String']>;
  /** Look up a warehouse. */
  warehouse: Maybe<Warehouse>;
};


/** Event sent when product variant stock is updated. */
export type ProductVariantStockUpdatedProductVariantArgs = {
  channel: InputMaybe<Scalars['String']>;
};

/**
 * Creates stocks for product variant.
 *
 * Requires one of the following permissions: MANAGE_PRODUCTS.
 */
export type ProductVariantStocksCreate = {
  __typename: 'ProductVariantStocksCreate';
  /** @deprecated Use `errors` field instead. */
  bulkStockErrors: Array<BulkStockError>;
  errors: Array<BulkStockError>;
  /** Updated product variant. */
  productVariant: Maybe<ProductVariant>;
};

/**
 * Deletes stocks from product variant.
 *
 * Requires one of the following permissions: MANAGE_PRODUCTS.
 */
export type ProductVariantStocksDelete = {
  __typename: 'ProductVariantStocksDelete';
  errors: Array<StockError>;
  /** Updated product variant. */
  productVariant: Maybe<ProductVariant>;
  /** @deprecated Use `errors` field instead. */
  stockErrors: Array<StockError>;
};

/**
 * Updates stocks for product variant.
 *
 * Requires one of the following permissions: MANAGE_PRODUCTS.
 */
export type ProductVariantStocksUpdate = {
  __typename: 'ProductVariantStocksUpdate';
  /** @deprecated Use `errors` field instead. */
  bulkStockErrors: Array<BulkStockError>;
  errors: Array<BulkStockError>;
  /** Updated product variant. */
  productVariant: Maybe<ProductVariant>;
};

export type ProductVariantStocksUpdateInput = {
  /** List of warehouses to create stocks. */
  create: InputMaybe<Array<StockInput>>;
  /** List of stocks to remove. */
  remove: InputMaybe<Array<Scalars['ID']>>;
  /** List of stocks to update. */
  update: InputMaybe<Array<StockUpdateInput>>;
};

/** Represents product variant's original translatable fields and related translations. */
export type ProductVariantTranslatableContent = Node & {
  __typename: 'ProductVariantTranslatableContent';
  /** List of product variant attribute values that can be translated. */
  attributeValues: Array<AttributeValueTranslatableContent>;
  /** The ID of the product variant translatable content. */
  id: Scalars['ID'];
  /** Name of the product variant to translate. */
  name: Scalars['String'];
  /**
   * Represents a version of a product such as different size or color.
   * @deprecated Get model fields from the root level queries.
   */
  productVariant: Maybe<ProductVariant>;
  /** The ID of the product variant to translate. */
  productVariantId: Scalars['ID'];
  /** Returns translated product variant fields for the given language code. */
  translation: Maybe<ProductVariantTranslation>;
};


/** Represents product variant's original translatable fields and related translations. */
export type ProductVariantTranslatableContentTranslationArgs = {
  languageCode: LanguageCodeEnum;
};

/**
 * Creates/updates translations for a product variant.
 *
 * Requires one of the following permissions: MANAGE_TRANSLATIONS.
 */
export type ProductVariantTranslate = {
  __typename: 'ProductVariantTranslate';
  errors: Array<TranslationError>;
  productVariant: Maybe<ProductVariant>;
  /** @deprecated Use `errors` field instead. */
  translationErrors: Array<TranslationError>;
};

export type ProductVariantTranslateErrorCode =
  | 'GRAPHQL_ERROR'
  | 'INVALID'
  | 'NOT_FOUND'
  | 'REQUIRED';

/** Represents product variant translations. */
export type ProductVariantTranslation = Node & {
  __typename: 'ProductVariantTranslation';
  /** The ID of the product variant translation. */
  id: Scalars['ID'];
  /** Translation language. */
  language: LanguageDisplay;
  /** Translated product variant name. */
  name: Scalars['String'];
  /** Represents the product variant fields to translate. */
  translatableContent: Maybe<ProductVariantTranslatableContent>;
};

/**
 * Updates an existing variant for product.
 *
 * Requires one of the following permissions: MANAGE_PRODUCTS.
 */
export type ProductVariantUpdate = {
  __typename: 'ProductVariantUpdate';
  errors: Array<ProductError>;
  /** @deprecated Use `errors` field instead. */
  productErrors: Array<ProductError>;
  productVariant: Maybe<ProductVariant>;
};

/** Event sent when product variant is updated. */
export type ProductVariantUpdated = Event & {
  __typename: 'ProductVariantUpdated';
  /** Time of the event. */
  issuedAt: Maybe<Scalars['DateTime']>;
  /** The user or application that triggered the event. */
  issuingPrincipal: Maybe<IssuingPrincipal>;
  /** The product variant the event relates to. */
  productVariant: Maybe<ProductVariant>;
  /** The application receiving the webhook. */
  recipient: Maybe<App>;
  /** Saleor version that triggered the event. */
  version: Maybe<Scalars['String']>;
};


/** Event sent when product variant is updated. */
export type ProductVariantUpdatedProductVariantArgs = {
  channel: InputMaybe<Scalars['String']>;
};

export type ProductVariantWhereInput = {
  /** List of conditions that must be met. */
  AND: InputMaybe<Array<ProductVariantWhereInput>>;
  /** A list of conditions of which at least one must be met. */
  OR: InputMaybe<Array<ProductVariantWhereInput>>;
  /**
   * Filter by attributes associated with the variant.
   *
   * Added in Saleor 3.22.
   */
  attributes: InputMaybe<Array<AssignedAttributeWhereInput>>;
  ids: InputMaybe<Array<Scalars['ID']>>;
  metadata: InputMaybe<Array<MetadataFilter>>;
  /** Filter by product SKU. */
  sku: InputMaybe<StringFilterInput>;
  /** Filter by when was the most recent update. */
  updatedAt: InputMaybe<DateTimeRangeInput>;
};

export type ProductWhereInput = {
  /** List of conditions that must be met. */
  AND: InputMaybe<Array<ProductWhereInput>>;
  /** A list of conditions of which at least one must be met. */
  OR: InputMaybe<Array<ProductWhereInput>>;
  /** Filter by attributes associated with the product. */
  attributes: InputMaybe<Array<AttributeInput>>;
  /** Filter by the date of availability for purchase. */
  availableFrom: InputMaybe<Scalars['DateTime']>;
  /** Filter by product category. */
  category: InputMaybe<GlobalIdFilterInput>;
  /** Filter by collection. */
  collection: InputMaybe<GlobalIdFilterInput>;
  /** Filter on whether product is a gift card or not. */
  giftCard: InputMaybe<Scalars['Boolean']>;
  /** Filter by product with category assigned. */
  hasCategory: InputMaybe<Scalars['Boolean']>;
  /** Filter by product with preordered variants. */
  hasPreorderedVariants: InputMaybe<Scalars['Boolean']>;
  ids: InputMaybe<Array<Scalars['ID']>>;
  /** Filter by availability for purchase. */
  isAvailable: InputMaybe<Scalars['Boolean']>;
  /** Filter by public visibility. */
  isPublished: InputMaybe<Scalars['Boolean']>;
  /** Filter by visibility on the channel. */
  isVisibleInListing: InputMaybe<Scalars['Boolean']>;
  metadata: InputMaybe<Array<MetadataFilter>>;
  /** Filter by the lowest variant price after discounts. */
  minimalPrice: InputMaybe<DecimalFilterInput>;
  /** Filter by product name. */
  name: InputMaybe<StringFilterInput>;
  /** Filter by product variant price. */
  price: InputMaybe<DecimalFilterInput>;
  /** Filter by product type. */
  productType: InputMaybe<GlobalIdFilterInput>;
  /** Filter by the publication date. */
  publishedFrom: InputMaybe<Scalars['DateTime']>;
  /** Filter by product slug. */
  slug: InputMaybe<StringFilterInput>;
  /** Filter by variants having specific stock status. */
  stockAvailability: InputMaybe<StockAvailability>;
  /** Filter by stock of the product variant. */
  stocks: InputMaybe<ProductStockFilterInput>;
  /** Filter by when was the most recent update. */
  updatedAt: InputMaybe<DateTimeFilterInput>;
};

/** Represents the promotion that allow creating discounts based on given conditions, and is visible to all the customers. */
export type Promotion = Node & ObjectWithMetadata & {
  __typename: 'Promotion';
  /** Date time of promotion creation. */
  createdAt: Scalars['DateTime'];
  /** Description of the promotion. */
  description: Maybe<Scalars['JSON']>;
  /** End date of the promotion. */
  endDate: Maybe<Scalars['DateTime']>;
  /** The list of events associated with the promotion. */
  events: Maybe<Array<PromotionEvent>>;
  id: Scalars['ID'];
  /** List of public metadata items. Can be accessed without permissions. */
  metadata: Array<MetadataItem>;
  /**
   * A single key from public metadata.
   *
   * Tip: Use GraphQL aliases to fetch multiple keys.
   */
  metafield: Maybe<Scalars['String']>;
  /** Public metadata. Use `keys` to control which fields you want to include. The default is to include everything. */
  metafields: Maybe<Scalars['Metadata']>;
  /** Name of the promotion. */
  name: Scalars['String'];
  /** List of private metadata items. Requires staff permissions to access. */
  privateMetadata: Array<MetadataItem>;
  /**
   * A single key from private metadata. Requires staff permissions to access.
   *
   * Tip: Use GraphQL aliases to fetch multiple keys.
   */
  privateMetafield: Maybe<Scalars['String']>;
  /** Private metadata. Requires staff permissions to access. Use `keys` to control which fields you want to include. The default is to include everything. */
  privateMetafields: Maybe<Scalars['Metadata']>;
  /** The list of promotion rules. */
  rules: Maybe<Array<PromotionRule>>;
  /** Start date of the promotion. */
  startDate: Scalars['DateTime'];
  /** Returns translated promotion fields for the given language code. */
  translation: Maybe<PromotionTranslation>;
  /**
   * The type of the promotion. Implicate if the discount is applied on catalogue or order level.
   *
   * Added in Saleor 3.19.
   *
   * Note: this API is currently in Feature Preview and can be subject to changes at later point.
   */
  type: Maybe<PromotionTypeEnum>;
  /** Date time of last update of promotion. */
  updatedAt: Scalars['DateTime'];
};


/** Represents the promotion that allow creating discounts based on given conditions, and is visible to all the customers. */
export type PromotionMetafieldArgs = {
  key: Scalars['String'];
};


/** Represents the promotion that allow creating discounts based on given conditions, and is visible to all the customers. */
export type PromotionMetafieldsArgs = {
  keys: InputMaybe<Array<Scalars['String']>>;
};


/** Represents the promotion that allow creating discounts based on given conditions, and is visible to all the customers. */
export type PromotionPrivateMetafieldArgs = {
  key: Scalars['String'];
};


/** Represents the promotion that allow creating discounts based on given conditions, and is visible to all the customers. */
export type PromotionPrivateMetafieldsArgs = {
  keys: InputMaybe<Array<Scalars['String']>>;
};


/** Represents the promotion that allow creating discounts based on given conditions, and is visible to all the customers. */
export type PromotionTranslationArgs = {
  languageCode: LanguageCodeEnum;
};

/**
 * Deletes promotions.
 *
 * Requires one of the following permissions: MANAGE_DISCOUNTS.
 *
 * Triggers the following webhook events:
 * - PROMOTION_DELETED (async): A promotion was deleted.
 */
export type PromotionBulkDelete = {
  __typename: 'PromotionBulkDelete';
  /** Returns how many objects were affected. */
  count: Scalars['Int'];
  errors: Array<DiscountError>;
};

export type PromotionCountableConnection = {
  __typename: 'PromotionCountableConnection';
  edges: Array<PromotionCountableEdge>;
  /** Pagination data for this connection. */
  pageInfo: PageInfo;
  /** A total count of items in the collection. */
  totalCount: Maybe<Scalars['Int']>;
};

export type PromotionCountableEdge = {
  __typename: 'PromotionCountableEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node: Promotion;
};

/**
 * Creates a new promotion.
 *
 * Requires one of the following permissions: MANAGE_DISCOUNTS.
 *
 * Triggers the following webhook events:
 * - PROMOTION_CREATED (async): A promotion was created.
 * - PROMOTION_STARTED (async): Optionally called if promotion was started.
 */
export type PromotionCreate = {
  __typename: 'PromotionCreate';
  errors: Array<PromotionCreateError>;
  promotion: Maybe<Promotion>;
};

export type PromotionCreateError = {
  __typename: 'PromotionCreateError';
  /** The error code. */
  code: PromotionCreateErrorCode;
  /** Name of a field that caused the error. A value of `null` indicates that the error isn't associated with a particular field. */
  field: Maybe<Scalars['String']>;
  /** Limit of gifts assigned to promotion rule. */
  giftsLimit: Maybe<Scalars['Int']>;
  /** Number of gifts defined for this promotion rule exceeding the limit. */
  giftsLimitExceedBy: Maybe<Scalars['Int']>;
  /** Index of an input list item that caused the error. */
  index: Maybe<Scalars['Int']>;
  /** The error message. */
  message: Maybe<Scalars['String']>;
  /** Limit of rules with orderPredicate defined. */
  rulesLimit: Maybe<Scalars['Int']>;
  /** Number of rules with orderPredicate defined exceeding the limit. */
  rulesLimitExceedBy: Maybe<Scalars['Int']>;
};

export type PromotionCreateErrorCode =
  | 'GIFTS_NUMBER_LIMIT'
  | 'GRAPHQL_ERROR'
  | 'INVALID'
  | 'INVALID_GIFT_TYPE'
  | 'INVALID_PRECISION'
  | 'MISSING_CHANNELS'
  | 'MULTIPLE_CURRENCIES_NOT_ALLOWED'
  | 'NOT_FOUND'
  | 'REQUIRED'
  | 'RULES_NUMBER_LIMIT';

export type PromotionCreateInput = {
  /** Promotion description. */
  description: InputMaybe<Scalars['JSON']>;
  /** The end date of the promotion in ISO 8601 format. */
  endDate: InputMaybe<Scalars['DateTime']>;
  /** Promotion name. */
  name: Scalars['String'];
  /** List of promotion rules. */
  rules: InputMaybe<Array<PromotionRuleInput>>;
  /** The start date of the promotion in ISO 8601 format. */
  startDate: InputMaybe<Scalars['DateTime']>;
  /**
   * Defines the promotion type. Implicate the required promotion rules predicate type and whether the promotion rules will give the catalogue or order discount.
   *
   * Added in Saleor 3.19.
   */
  type: PromotionTypeEnum;
};

/** Event sent when new promotion is created. */
export type PromotionCreated = Event & {
  __typename: 'PromotionCreated';
  /** Time of the event. */
  issuedAt: Maybe<Scalars['DateTime']>;
  /** The user or application that triggered the event. */
  issuingPrincipal: Maybe<IssuingPrincipal>;
  /** The promotion the event relates to. */
  promotion: Maybe<Promotion>;
  /** The application receiving the webhook. */
  recipient: Maybe<App>;
  /** Saleor version that triggered the event. */
  version: Maybe<Scalars['String']>;
};

/** History log of the promotion created event. */
export type PromotionCreatedEvent = Node & PromotionEventInterface & {
  __typename: 'PromotionCreatedEvent';
  /**
   * User or App that created the promotion event.
   *
   * Requires one of the following permissions: MANAGE_STAFF, MANAGE_APPS, OWNER.
   */
  createdBy: Maybe<UserOrApp>;
  /** Date when event happened. */
  date: Scalars['DateTime'];
  id: Scalars['ID'];
  /** Promotion event type. */
  type: PromotionEventsEnum;
};

/**
 * Deletes a promotion.
 *
 * Requires one of the following permissions: MANAGE_DISCOUNTS.
 *
 * Triggers the following webhook events:
 * - PROMOTION_DELETED (async): A promotion was deleted.
 */
export type PromotionDelete = {
  __typename: 'PromotionDelete';
  errors: Array<PromotionDeleteError>;
  promotion: Maybe<Promotion>;
};

export type PromotionDeleteError = {
  __typename: 'PromotionDeleteError';
  /** The error code. */
  code: PromotionDeleteErrorCode;
  /** Name of a field that caused the error. A value of `null` indicates that the error isn't associated with a particular field. */
  field: Maybe<Scalars['String']>;
  /** The error message. */
  message: Maybe<Scalars['String']>;
};

export type PromotionDeleteErrorCode =
  | 'GRAPHQL_ERROR'
  | 'NOT_FOUND';

/** Event sent when promotion is deleted. */
export type PromotionDeleted = Event & {
  __typename: 'PromotionDeleted';
  /** Time of the event. */
  issuedAt: Maybe<Scalars['DateTime']>;
  /** The user or application that triggered the event. */
  issuingPrincipal: Maybe<IssuingPrincipal>;
  /** The promotion the event relates to. */
  promotion: Maybe<Promotion>;
  /** The application receiving the webhook. */
  recipient: Maybe<App>;
  /** Saleor version that triggered the event. */
  version: Maybe<Scalars['String']>;
};

/** The event informs about the end of the promotion. */
export type PromotionEnded = Event & {
  __typename: 'PromotionEnded';
  /** Time of the event. */
  issuedAt: Maybe<Scalars['DateTime']>;
  /** The user or application that triggered the event. */
  issuingPrincipal: Maybe<IssuingPrincipal>;
  /** The promotion the event relates to. */
  promotion: Maybe<Promotion>;
  /** The application receiving the webhook. */
  recipient: Maybe<App>;
  /** Saleor version that triggered the event. */
  version: Maybe<Scalars['String']>;
};

/** History log of the promotion ended event. */
export type PromotionEndedEvent = Node & PromotionEventInterface & {
  __typename: 'PromotionEndedEvent';
  /**
   * User or App that created the promotion event.
   *
   * Requires one of the following permissions: MANAGE_STAFF, MANAGE_APPS, OWNER.
   */
  createdBy: Maybe<UserOrApp>;
  /** Date when event happened. */
  date: Scalars['DateTime'];
  id: Scalars['ID'];
  /** Promotion event type. */
  type: PromotionEventsEnum;
};

export type PromotionEvent = PromotionCreatedEvent | PromotionEndedEvent | PromotionRuleCreatedEvent | PromotionRuleDeletedEvent | PromotionRuleUpdatedEvent | PromotionStartedEvent | PromotionUpdatedEvent;

export type PromotionEventInterface = {
  /**
   * User or App that created the promotion event.
   *
   * Requires one of the following permissions: MANAGE_STAFF, MANAGE_APPS, OWNER.
   */
  createdBy: Maybe<UserOrApp>;
  /** Date when event happened. */
  date: Scalars['DateTime'];
  id: Scalars['ID'];
  /** Promotion event type. */
  type: PromotionEventsEnum;
};

export type PromotionEventsEnum =
  | 'PROMOTION_CREATED'
  | 'PROMOTION_ENDED'
  | 'PROMOTION_STARTED'
  | 'PROMOTION_UPDATED'
  | 'RULE_CREATED'
  | 'RULE_DELETED'
  | 'RULE_UPDATED';

/** Represents the promotion rule that specifies the conditions that must be met to apply the promotion discount. */
export type PromotionRule = Node & {
  __typename: 'PromotionRule';
  /** The catalogue predicate that must be met to apply the rule reward. */
  cataloguePredicate: Maybe<Scalars['JSON']>;
  /**
   * List of channels where the rule applies.
   *
   * Requires one of the following permissions: AUTHENTICATED_APP, AUTHENTICATED_STAFF_USER.
   */
  channels: Maybe<Array<Channel>>;
  /** Description of the promotion rule. */
  description: Maybe<Scalars['JSON']>;
  /**
   * Product variant IDs available as a gift to choose.
   *
   * Added in Saleor 3.19.
   *
   * Note: this API is currently in Feature Preview and can be subject to changes at later point.
   */
  giftIds: Maybe<Array<Scalars['ID']>>;
  /**
   * Defines the maximum number of gifts to choose from the gifts list.
   *
   * Added in Saleor 3.19.
   *
   * Note: this API is currently in Feature Preview and can be subject to changes at later point.
   */
  giftsLimit: Maybe<Scalars['Int']>;
  id: Scalars['ID'];
  /** Name of the promotion rule. */
  name: Maybe<Scalars['String']>;
  /**
   * The checkout/order predicate that must be met to apply the rule reward.
   *
   * Added in Saleor 3.19.
   *
   * Note: this API is currently in Feature Preview and can be subject to changes at later point.
   */
  orderPredicate: Maybe<Scalars['JSON']>;
  /**
   * The type of the predicate that must be met to apply the reward.
   *
   * Added in Saleor 3.19.
   *
   * Note: this API is currently in Feature Preview and can be subject to changes at later point.
   */
  predicateType: Maybe<PromotionTypeEnum>;
  /** Promotion to which the rule belongs. */
  promotion: Maybe<Promotion>;
  /**
   * The reward type of the promotion rule.
   *
   * Added in Saleor 3.19.
   *
   * Note: this API is currently in Feature Preview and can be subject to changes at later point.
   */
  rewardType: Maybe<RewardTypeEnum>;
  /**
   * The reward value of the promotion rule. Defines the discount value applied when the rule conditions are met.
   *
   * Added in Saleor 3.19.
   *
   * Note: this API is currently in Feature Preview and can be subject to changes at later point.
   */
  rewardValue: Maybe<Scalars['PositiveDecimal']>;
  /** The type of reward value of the promotion rule. */
  rewardValueType: Maybe<RewardValueTypeEnum>;
  /** Returns translated promotion rule fields for the given language code. */
  translation: Maybe<PromotionRuleTranslation>;
};


/** Represents the promotion rule that specifies the conditions that must be met to apply the promotion discount. */
export type PromotionRuleTranslationArgs = {
  languageCode: LanguageCodeEnum;
};

/**
 * Creates a new promotion rule.
 *
 * Requires one of the following permissions: MANAGE_DISCOUNTS.
 *
 * Triggers the following webhook events:
 * - PROMOTION_RULE_CREATED (async): A promotion rule was created.
 */
export type PromotionRuleCreate = {
  __typename: 'PromotionRuleCreate';
  errors: Array<PromotionRuleCreateError>;
  promotionRule: Maybe<PromotionRule>;
};

export type PromotionRuleCreateError = {
  __typename: 'PromotionRuleCreateError';
  /** The error code. */
  code: PromotionRuleCreateErrorCode;
  /** Name of a field that caused the error. A value of `null` indicates that the error isn't associated with a particular field. */
  field: Maybe<Scalars['String']>;
  /** Limit of gifts assigned to promotion rule. */
  giftsLimit: Maybe<Scalars['Int']>;
  /** Number of gifts defined for this promotion rule exceeding the limit. */
  giftsLimitExceedBy: Maybe<Scalars['Int']>;
  /** The error message. */
  message: Maybe<Scalars['String']>;
  /** Limit of rules with orderPredicate defined. */
  rulesLimit: Maybe<Scalars['Int']>;
  /** Number of rules with orderPredicate defined exceeding the limit. */
  rulesLimitExceedBy: Maybe<Scalars['Int']>;
};

export type PromotionRuleCreateErrorCode =
  | 'GIFTS_NUMBER_LIMIT'
  | 'GRAPHQL_ERROR'
  | 'INVALID'
  | 'INVALID_GIFT_TYPE'
  | 'INVALID_PRECISION'
  | 'MISSING_CHANNELS'
  | 'MULTIPLE_CURRENCIES_NOT_ALLOWED'
  | 'NOT_FOUND'
  | 'REQUIRED'
  | 'RULES_NUMBER_LIMIT';

export type PromotionRuleCreateInput = {
  /** Defines the conditions on the catalogue level that must be met for the reward to be applied. */
  cataloguePredicate: InputMaybe<CataloguePredicateInput>;
  /** List of channel ids to which the rule should apply to. */
  channels: InputMaybe<Array<Scalars['ID']>>;
  /** Promotion rule description. */
  description: InputMaybe<Scalars['JSON']>;
  /**
   * Product variant IDs available as a gift to choose.
   *
   * Added in Saleor 3.19.
   *
   * Note: this API is currently in Feature Preview and can be subject to changes at later point.
   */
  gifts: InputMaybe<Array<Scalars['ID']>>;
  /** Promotion rule name. */
  name: InputMaybe<Scalars['String']>;
  /**
   * Defines the conditions on the checkout/draft order level that must be met for the reward to be applied.
   *
   * Added in Saleor 3.19.
   *
   * Note: this API is currently in Feature Preview and can be subject to changes at later point.
   */
  orderPredicate: InputMaybe<OrderPredicateInput>;
  /** The ID of the promotion that rule belongs to. */
  promotion: Scalars['ID'];
  /**
   * Defines the reward type of the promotion rule.
   *
   * Added in Saleor 3.19.
   *
   * Note: this API is currently in Feature Preview and can be subject to changes at later point.
   */
  rewardType: InputMaybe<RewardTypeEnum>;
  /** Defines the discount value. Required when catalogue predicate is provided. */
  rewardValue: InputMaybe<Scalars['PositiveDecimal']>;
  /** Defines the promotion rule reward value type. Must be provided together with reward value. */
  rewardValueType: InputMaybe<RewardValueTypeEnum>;
};

/** Event sent when new promotion rule is created. */
export type PromotionRuleCreated = Event & {
  __typename: 'PromotionRuleCreated';
  /** Time of the event. */
  issuedAt: Maybe<Scalars['DateTime']>;
  /** The user or application that triggered the event. */
  issuingPrincipal: Maybe<IssuingPrincipal>;
  /** The promotion rule the event relates to. */
  promotionRule: Maybe<PromotionRule>;
  /** The application receiving the webhook. */
  recipient: Maybe<App>;
  /** Saleor version that triggered the event. */
  version: Maybe<Scalars['String']>;
};

/** History log of the promotion rule created event. */
export type PromotionRuleCreatedEvent = Node & PromotionEventInterface & PromotionRuleEventInterface & {
  __typename: 'PromotionRuleCreatedEvent';
  /**
   * User or App that created the promotion event.
   *
   * Requires one of the following permissions: MANAGE_STAFF, MANAGE_APPS, OWNER.
   */
  createdBy: Maybe<UserOrApp>;
  /** Date when event happened. */
  date: Scalars['DateTime'];
  id: Scalars['ID'];
  /** The rule ID associated with the promotion event. */
  ruleId: Maybe<Scalars['String']>;
  /** Promotion event type. */
  type: PromotionEventsEnum;
};

/**
 * Deletes a promotion rule.
 *
 * Requires one of the following permissions: MANAGE_DISCOUNTS.
 *
 * Triggers the following webhook events:
 * - PROMOTION_RULE_DELETED (async): A promotion rule was deleted.
 */
export type PromotionRuleDelete = {
  __typename: 'PromotionRuleDelete';
  errors: Array<PromotionRuleDeleteError>;
  promotionRule: Maybe<PromotionRule>;
};

export type PromotionRuleDeleteError = {
  __typename: 'PromotionRuleDeleteError';
  /** The error code. */
  code: PromotionRuleDeleteErrorCode;
  /** Name of a field that caused the error. A value of `null` indicates that the error isn't associated with a particular field. */
  field: Maybe<Scalars['String']>;
  /** The error message. */
  message: Maybe<Scalars['String']>;
};

export type PromotionRuleDeleteErrorCode =
  | 'GRAPHQL_ERROR'
  | 'NOT_FOUND';

/** Event sent when new promotion rule is deleted. */
export type PromotionRuleDeleted = Event & {
  __typename: 'PromotionRuleDeleted';
  /** Time of the event. */
  issuedAt: Maybe<Scalars['DateTime']>;
  /** The user or application that triggered the event. */
  issuingPrincipal: Maybe<IssuingPrincipal>;
  /** The promotion rule the event relates to. */
  promotionRule: Maybe<PromotionRule>;
  /** The application receiving the webhook. */
  recipient: Maybe<App>;
  /** Saleor version that triggered the event. */
  version: Maybe<Scalars['String']>;
};

/** History log of the promotion rule created event. */
export type PromotionRuleDeletedEvent = Node & PromotionEventInterface & PromotionRuleEventInterface & {
  __typename: 'PromotionRuleDeletedEvent';
  /**
   * User or App that created the promotion event.
   *
   * Requires one of the following permissions: MANAGE_STAFF, MANAGE_APPS, OWNER.
   */
  createdBy: Maybe<UserOrApp>;
  /** Date when event happened. */
  date: Scalars['DateTime'];
  id: Scalars['ID'];
  /** The rule ID associated with the promotion event. */
  ruleId: Maybe<Scalars['String']>;
  /** Promotion event type. */
  type: PromotionEventsEnum;
};

/** History log of the promotion event related to rule. */
export type PromotionRuleEventInterface = {
  /** The rule ID associated with the promotion event. */
  ruleId: Maybe<Scalars['String']>;
};

export type PromotionRuleInput = {
  /** Defines the conditions on the catalogue level that must be met for the reward to be applied. */
  cataloguePredicate: InputMaybe<CataloguePredicateInput>;
  /** List of channel ids to which the rule should apply to. */
  channels: InputMaybe<Array<Scalars['ID']>>;
  /** Promotion rule description. */
  description: InputMaybe<Scalars['JSON']>;
  /**
   * Product variant IDs available as a gift to choose.
   *
   * Added in Saleor 3.19.
   *
   * Note: this API is currently in Feature Preview and can be subject to changes at later point.
   */
  gifts: InputMaybe<Array<Scalars['ID']>>;
  /** Promotion rule name. */
  name: InputMaybe<Scalars['String']>;
  /**
   * Defines the conditions on the checkout/draft order level that must be met for the reward to be applied.
   *
   * Added in Saleor 3.19.
   *
   * Note: this API is currently in Feature Preview and can be subject to changes at later point.
   */
  orderPredicate: InputMaybe<OrderPredicateInput>;
  /**
   * Defines the reward type of the promotion rule.
   *
   * Added in Saleor 3.19.
   *
   * Note: this API is currently in Feature Preview and can be subject to changes at later point.
   */
  rewardType: InputMaybe<RewardTypeEnum>;
  /** Defines the discount value. Required when catalogue predicate is provided. */
  rewardValue: InputMaybe<Scalars['PositiveDecimal']>;
  /** Defines the promotion rule reward value type. Must be provided together with reward value. */
  rewardValueType: InputMaybe<RewardValueTypeEnum>;
};

/** Represents promotion rule's original translatable fields and related translations. */
export type PromotionRuleTranslatableContent = Node & {
  __typename: 'PromotionRuleTranslatableContent';
  /**
   * Description of the promotion rule.
   *
   * Rich text format. For reference see https://editorjs.io/
   */
  description: Maybe<Scalars['JSONString']>;
  /** ID of the promotion rule translatable content. */
  id: Scalars['ID'];
  /** Name of the promotion rule. */
  name: Maybe<Scalars['String']>;
  /** ID of the promotion rule to translate. */
  promotionRuleId: Scalars['ID'];
  /** Returns translated promotion rule fields for the given language code. */
  translation: Maybe<PromotionRuleTranslation>;
};


/** Represents promotion rule's original translatable fields and related translations. */
export type PromotionRuleTranslatableContentTranslationArgs = {
  languageCode: LanguageCodeEnum;
};

/**
 * Creates/updates translations for a promotion rule.
 *
 * Requires one of the following permissions: MANAGE_TRANSLATIONS.
 */
export type PromotionRuleTranslate = {
  __typename: 'PromotionRuleTranslate';
  errors: Array<TranslationError>;
  promotionRule: Maybe<PromotionRule>;
};

/** Represents promotion rule translations. */
export type PromotionRuleTranslation = Node & {
  __typename: 'PromotionRuleTranslation';
  /**
   * Translated description of the promotion rule.
   *
   * Rich text format. For reference see https://editorjs.io/
   */
  description: Maybe<Scalars['JSONString']>;
  /** ID of the promotion rule translation. */
  id: Scalars['ID'];
  /** Translation language. */
  language: LanguageDisplay;
  /** Translated name of the promotion rule. */
  name: Maybe<Scalars['String']>;
  /** Represents the promotion rule fields to translate. */
  translatableContent: Maybe<PromotionRuleTranslatableContent>;
};

export type PromotionRuleTranslationInput = {
  /**
   * Translated promotion description.
   *
   * Rich text format. For reference see https://editorjs.io/
   */
  description: InputMaybe<Scalars['JSON']>;
  name: InputMaybe<Scalars['String']>;
};

/**
 * Updates an existing promotion rule.
 *
 * Requires one of the following permissions: MANAGE_DISCOUNTS.
 *
 * Triggers the following webhook events:
 * - PROMOTION_RULE_UPDATED (async): A promotion rule was updated.
 */
export type PromotionRuleUpdate = {
  __typename: 'PromotionRuleUpdate';
  errors: Array<PromotionRuleUpdateError>;
  promotionRule: Maybe<PromotionRule>;
};

export type PromotionRuleUpdateError = {
  __typename: 'PromotionRuleUpdateError';
  /** List of channel IDs which causes the error. */
  channels: Maybe<Array<Scalars['ID']>>;
  /** The error code. */
  code: PromotionRuleUpdateErrorCode;
  /** Name of a field that caused the error. A value of `null` indicates that the error isn't associated with a particular field. */
  field: Maybe<Scalars['String']>;
  /** Limit of gifts assigned to promotion rule. */
  giftsLimit: Maybe<Scalars['Int']>;
  /** Number of gifts defined for this promotion rule exceeding the limit. */
  giftsLimitExceedBy: Maybe<Scalars['Int']>;
  /** The error message. */
  message: Maybe<Scalars['String']>;
};

export type PromotionRuleUpdateErrorCode =
  | 'DUPLICATED_INPUT_ITEM'
  | 'GIFTS_NUMBER_LIMIT'
  | 'GRAPHQL_ERROR'
  | 'INVALID'
  | 'INVALID_GIFT_TYPE'
  | 'INVALID_PRECISION'
  | 'MISSING_CHANNELS'
  | 'MULTIPLE_CURRENCIES_NOT_ALLOWED'
  | 'NOT_FOUND'
  | 'REQUIRED';

export type PromotionRuleUpdateInput = {
  /** List of channel ids to add. */
  addChannels: InputMaybe<Array<Scalars['ID']>>;
  /**
   * List of variant IDs available as a gift to add.
   *
   * Added in Saleor 3.19.
   *
   * Note: this API is currently in Feature Preview and can be subject to changes at later point.
   */
  addGifts: InputMaybe<Array<Scalars['ID']>>;
  /** Defines the conditions on the catalogue level that must be met for the reward to be applied. */
  cataloguePredicate: InputMaybe<CataloguePredicateInput>;
  /** Promotion rule description. */
  description: InputMaybe<Scalars['JSON']>;
  /** Promotion rule name. */
  name: InputMaybe<Scalars['String']>;
  /**
   * Defines the conditions on the checkout/draft order level that must be met for the reward to be applied.
   *
   * Added in Saleor 3.19.
   *
   * Note: this API is currently in Feature Preview and can be subject to changes at later point.
   */
  orderPredicate: InputMaybe<OrderPredicateInput>;
  /** List of channel ids to remove. */
  removeChannels: InputMaybe<Array<Scalars['ID']>>;
  /**
   * List of variant IDs available as a gift to remove.
   *
   * Added in Saleor 3.19.
   *
   * Note: this API is currently in Feature Preview and can be subject to changes at later point.
   */
  removeGifts: InputMaybe<Array<Scalars['ID']>>;
  /**
   * Defines the reward type of the promotion rule.
   *
   * Added in Saleor 3.19.
   *
   * Note: this API is currently in Feature Preview and can be subject to changes at later point.
   */
  rewardType: InputMaybe<RewardTypeEnum>;
  /** Defines the discount value. Required when catalogue predicate is provided. */
  rewardValue: InputMaybe<Scalars['PositiveDecimal']>;
  /** Defines the promotion rule reward value type. Must be provided together with reward value. */
  rewardValueType: InputMaybe<RewardValueTypeEnum>;
};

/** Event sent when new promotion rule is updated. */
export type PromotionRuleUpdated = Event & {
  __typename: 'PromotionRuleUpdated';
  /** Time of the event. */
  issuedAt: Maybe<Scalars['DateTime']>;
  /** The user or application that triggered the event. */
  issuingPrincipal: Maybe<IssuingPrincipal>;
  /** The promotion rule the event relates to. */
  promotionRule: Maybe<PromotionRule>;
  /** The application receiving the webhook. */
  recipient: Maybe<App>;
  /** Saleor version that triggered the event. */
  version: Maybe<Scalars['String']>;
};

/** History log of the promotion rule created event. */
export type PromotionRuleUpdatedEvent = Node & PromotionEventInterface & PromotionRuleEventInterface & {
  __typename: 'PromotionRuleUpdatedEvent';
  /**
   * User or App that created the promotion event.
   *
   * Requires one of the following permissions: MANAGE_STAFF, MANAGE_APPS, OWNER.
   */
  createdBy: Maybe<UserOrApp>;
  /** Date when event happened. */
  date: Scalars['DateTime'];
  id: Scalars['ID'];
  /** The rule ID associated with the promotion event. */
  ruleId: Maybe<Scalars['String']>;
  /** Promotion event type. */
  type: PromotionEventsEnum;
};

export type PromotionSortField =
  /** Sort promotions by creation date. */
  | 'CREATED_AT'
  /** Sort promotions by end date. */
  | 'END_DATE'
  /** Sort promotions by name. */
  | 'NAME'
  /** Sort promotions by start date. */
  | 'START_DATE';

export type PromotionSortingInput = {
  /** Specifies the direction in which to sort promotions. */
  direction: OrderDirection;
  /** Sort promotions by the selected field. */
  field: PromotionSortField;
};

/** The event informs about the start of the promotion. */
export type PromotionStarted = Event & {
  __typename: 'PromotionStarted';
  /** Time of the event. */
  issuedAt: Maybe<Scalars['DateTime']>;
  /** The user or application that triggered the event. */
  issuingPrincipal: Maybe<IssuingPrincipal>;
  /** The promotion the event relates to. */
  promotion: Maybe<Promotion>;
  /** The application receiving the webhook. */
  recipient: Maybe<App>;
  /** Saleor version that triggered the event. */
  version: Maybe<Scalars['String']>;
};

/** History log of the promotion started event. */
export type PromotionStartedEvent = Node & PromotionEventInterface & {
  __typename: 'PromotionStartedEvent';
  /**
   * User or App that created the promotion event.
   *
   * Requires one of the following permissions: MANAGE_STAFF, MANAGE_APPS, OWNER.
   */
  createdBy: Maybe<UserOrApp>;
  /** Date when event happened. */
  date: Scalars['DateTime'];
  id: Scalars['ID'];
  /** Promotion event type. */
  type: PromotionEventsEnum;
};

/** Represents promotion's original translatable fields and related translations. */
export type PromotionTranslatableContent = Node & {
  __typename: 'PromotionTranslatableContent';
  /**
   * Description of the promotion.
   *
   * Rich text format. For reference see https://editorjs.io/
   */
  description: Maybe<Scalars['JSONString']>;
  /** ID of the promotion translatable content. */
  id: Scalars['ID'];
  /** Name of the promotion. */
  name: Scalars['String'];
  /** ID of the promotion to translate. */
  promotionId: Scalars['ID'];
  /** Returns translated promotion fields for the given language code. */
  translation: Maybe<PromotionTranslation>;
};


/** Represents promotion's original translatable fields and related translations. */
export type PromotionTranslatableContentTranslationArgs = {
  languageCode: LanguageCodeEnum;
};

/**
 * Creates/updates translations for a promotion.
 *
 * Requires one of the following permissions: MANAGE_TRANSLATIONS.
 */
export type PromotionTranslate = {
  __typename: 'PromotionTranslate';
  errors: Array<TranslationError>;
  promotion: Maybe<Promotion>;
};

/** Represents promotion translations. */
export type PromotionTranslation = Node & {
  __typename: 'PromotionTranslation';
  /**
   * Translated description of the promotion.
   *
   * Rich text format. For reference see https://editorjs.io/
   */
  description: Maybe<Scalars['JSONString']>;
  /** ID of the promotion translation. */
  id: Scalars['ID'];
  /** Translation language. */
  language: LanguageDisplay;
  /** Translated name of the promotion. */
  name: Maybe<Scalars['String']>;
  /** Represents the promotion fields to translate. */
  translatableContent: Maybe<PromotionTranslatableContent>;
};

export type PromotionTranslationInput = {
  /**
   * Translated promotion description.
   *
   * Rich text format. For reference see https://editorjs.io/
   */
  description: InputMaybe<Scalars['JSON']>;
  name: InputMaybe<Scalars['String']>;
};

export type PromotionTypeEnum =
  | 'CATALOGUE'
  | 'ORDER';

export type PromotionTypeEnumFilterInput = {
  /** The value equal to. */
  eq: InputMaybe<PromotionTypeEnum>;
  /** The value included in. */
  oneOf: InputMaybe<Array<PromotionTypeEnum>>;
};

/**
 * Updates an existing promotion.
 *
 * Requires one of the following permissions: MANAGE_DISCOUNTS.
 *
 * Triggers the following webhook events:
 * - PROMOTION_UPDATED (async): A promotion was updated.
 * - PROMOTION_STARTED (async): Optionally called if promotion was started.
 * - PROMOTION_ENDED (async): Optionally called if promotion was ended.
 */
export type PromotionUpdate = {
  __typename: 'PromotionUpdate';
  errors: Array<PromotionUpdateError>;
  promotion: Maybe<Promotion>;
};

export type PromotionUpdateError = {
  __typename: 'PromotionUpdateError';
  /** The error code. */
  code: PromotionUpdateErrorCode;
  /** Name of a field that caused the error. A value of `null` indicates that the error isn't associated with a particular field. */
  field: Maybe<Scalars['String']>;
  /** The error message. */
  message: Maybe<Scalars['String']>;
};

export type PromotionUpdateErrorCode =
  | 'GRAPHQL_ERROR'
  | 'INVALID'
  | 'NOT_FOUND'
  | 'REQUIRED';

export type PromotionUpdateInput = {
  /** Promotion description. */
  description: InputMaybe<Scalars['JSON']>;
  /** The end date of the promotion in ISO 8601 format. */
  endDate: InputMaybe<Scalars['DateTime']>;
  /** Promotion name. */
  name: InputMaybe<Scalars['String']>;
  /** The start date of the promotion in ISO 8601 format. */
  startDate: InputMaybe<Scalars['DateTime']>;
};

/** Event sent when promotion is updated. */
export type PromotionUpdated = Event & {
  __typename: 'PromotionUpdated';
  /** Time of the event. */
  issuedAt: Maybe<Scalars['DateTime']>;
  /** The user or application that triggered the event. */
  issuingPrincipal: Maybe<IssuingPrincipal>;
  /** The promotion the event relates to. */
  promotion: Maybe<Promotion>;
  /** The application receiving the webhook. */
  recipient: Maybe<App>;
  /** Saleor version that triggered the event. */
  version: Maybe<Scalars['String']>;
};

/** History log of the promotion updated event. */
export type PromotionUpdatedEvent = Node & PromotionEventInterface & {
  __typename: 'PromotionUpdatedEvent';
  /**
   * User or App that created the promotion event.
   *
   * Requires one of the following permissions: MANAGE_STAFF, MANAGE_APPS, OWNER.
   */
  createdBy: Maybe<UserOrApp>;
  /** Date when event happened. */
  date: Scalars['DateTime'];
  id: Scalars['ID'];
  /** Promotion event type. */
  type: PromotionEventsEnum;
};

export type PromotionWhereInput = {
  /** List of conditions that must be met. */
  AND: InputMaybe<Array<PromotionWhereInput>>;
  /** A list of conditions of which at least one must be met. */
  OR: InputMaybe<Array<PromotionWhereInput>>;
  /** Filter promotions by end date. */
  endDate: InputMaybe<DateTimeFilterInput>;
  ids: InputMaybe<Array<Scalars['ID']>>;
  isOldSale: InputMaybe<Scalars['Boolean']>;
  metadata: InputMaybe<Array<MetadataFilter>>;
  /** Filter by promotion name. */
  name: InputMaybe<StringFilterInput>;
  /** Filter promotions by start date. */
  startDate: InputMaybe<DateTimeFilterInput>;
  type: InputMaybe<PromotionTypeEnumFilterInput>;
};

export type PublishableChannelListingInput = {
  /** ID of a channel. */
  channelId: Scalars['ID'];
  /** Determines if object is visible to customers. */
  isPublished: InputMaybe<Scalars['Boolean']>;
  /**
   * Publication date. ISO 8601 standard.
   * @deprecated Use `publishedAt` field instead.
   */
  publicationDate: InputMaybe<Scalars['Date']>;
  /** Publication date time. ISO 8601 standard. */
  publishedAt: InputMaybe<Scalars['DateTime']>;
};

export type Query = {
  __typename: 'Query';
  _entities: Maybe<Array<Maybe<_Entity>>>;
  _service: Maybe<_Service>;
  /**
   * Look up an address by ID.
   *
   * Requires one of the following permissions: MANAGE_USERS, OWNER.
   */
  address: Maybe<Address>;
  /** Returns address validation rules. */
  addressValidationRules: Maybe<AddressValidationData>;
  /**
   * Look up an app by ID. If ID is not provided, return the currently authenticated app.
   *
   * Requires one of the following permissions: AUTHENTICATED_STAFF_USER AUTHENTICATED_APP. The authenticated app has access to its resources. Fetching different apps requires MANAGE_APPS permission.
   */
  app: Maybe<App>;
  /**
   * Look up an app extension by ID.
   *
   * Requires one of the following permissions: AUTHENTICATED_STAFF_USER, AUTHENTICATED_APP.
   */
  appExtension: Maybe<AppExtension>;
  /**
   * List of all extensions.
   *
   * Requires one of the following permissions: AUTHENTICATED_STAFF_USER, AUTHENTICATED_APP.
   */
  appExtensions: Maybe<AppExtensionCountableConnection>;
  /**
   * List of the apps.
   *
   * Requires one of the following permissions: AUTHENTICATED_STAFF_USER, MANAGE_APPS.
   */
  apps: Maybe<AppCountableConnection>;
  /**
   * List of all apps installations
   *
   * Requires one of the following permissions: MANAGE_APPS.
   */
  appsInstallations: Array<AppInstallation>;
  /** Look up an attribute by ID, slug or external reference. */
  attribute: Maybe<Attribute>;
  /** List of the shop's attributes. */
  attributes: Maybe<AttributeCountableConnection>;
  /** List of the shop's categories. */
  categories: Maybe<CategoryCountableConnection>;
  /** Look up a category by ID or slug. */
  category: Maybe<Category>;
  /** Look up a channel by ID or slug. */
  channel: Maybe<Channel>;
  /**
   * List of all channels.
   *
   * Requires one of the following permissions: AUTHENTICATED_APP, AUTHENTICATED_STAFF_USER.
   */
  channels: Maybe<Array<Channel>>;
  /**
   * Look up a checkout by id.
   *
   * Requires one of the following permissions to query a checkout, if a checkout is in inactive channel: MANAGE_CHECKOUTS, IMPERSONATE_USER, HANDLE_PAYMENTS.
   */
  checkout: Maybe<Checkout>;
  /**
   * List of checkout lines. The query will not initiate any external requests, including fetching external shipping methods, filtering available shipping methods, or performing external tax calculations.
   *
   * Requires one of the following permissions: MANAGE_CHECKOUTS.
   */
  checkoutLines: Maybe<CheckoutLineCountableConnection>;
  /**
   * List of checkouts. The query will not initiate any external requests, including fetching external shipping methods, filtering available shipping methods, or performing external tax calculations.
   *
   * Requires one of the following permissions: MANAGE_CHECKOUTS, HANDLE_PAYMENTS.
   */
  checkouts: Maybe<CheckoutCountableConnection>;
  /** Look up a collection by ID or slug. If slugLanguageCode is provided, category will be fetched by slug translation. Requires one of the following permissions to include the unpublished items: MANAGE_ORDERS, MANAGE_DISCOUNTS, MANAGE_PRODUCTS. */
  collection: Maybe<Collection>;
  /** List of the shop's collections. Requires one of the following permissions to include the unpublished items: MANAGE_ORDERS, MANAGE_DISCOUNTS, MANAGE_PRODUCTS. */
  collections: Maybe<CollectionCountableConnection>;
  /**
   * List of the shop's customers. This list includes all users who registered through the accountRegister mutation. Additionally, staff users who have placed an order using their account will also appear in this list.
   *
   * Requires one of the following permissions: MANAGE_ORDERS, MANAGE_USERS.
   */
  customers: Maybe<UserCountableConnection>;
  /**
   * Look up digital content by ID.
   *
   * Requires one of the following permissions: MANAGE_PRODUCTS.
   * @deprecated Support for Digital Content is deprecated and will be removed in Saleor v3.23.0. This functionality is legacy and undocumented, and is not part of the supported API. Users should not rely on this behavior.
   */
  digitalContent: Maybe<DigitalContent>;
  /**
   * List of digital content.
   *
   * Requires one of the following permissions: MANAGE_PRODUCTS.
   * @deprecated Support for Digital Content is deprecated and will be removed in Saleor v3.23.0. This functionality is legacy and undocumented, and is not part of the supported API. Users should not rely on this behavior.
   */
  digitalContents: Maybe<DigitalContentCountableConnection>;
  /**
   * List of draft orders. The query will not initiate any external requests, including filtering available shipping methods, or performing external tax calculations.
   *
   * Requires one of the following permissions: MANAGE_ORDERS.
   */
  draftOrders: Maybe<OrderCountableConnection>;
  /**
   * Look up a export file by ID.
   *
   * Requires one of the following permissions: MANAGE_PRODUCTS.
   */
  exportFile: Maybe<ExportFile>;
  /**
   * List of export files.
   *
   * Requires one of the following permissions: MANAGE_PRODUCTS.
   */
  exportFiles: Maybe<ExportFileCountableConnection>;
  /**
   * Look up a gift card by ID.
   *
   * Requires one of the following permissions: MANAGE_GIFT_CARD.
   */
  giftCard: Maybe<GiftCard>;
  /**
   * List of gift card currencies.
   *
   * Requires one of the following permissions: MANAGE_GIFT_CARD.
   */
  giftCardCurrencies: Array<Scalars['String']>;
  /**
   * Gift card related settings from site settings.
   *
   * Requires one of the following permissions: MANAGE_GIFT_CARD.
   */
  giftCardSettings: GiftCardSettings;
  /**
   * List of gift card tags.
   *
   * Requires one of the following permissions: MANAGE_GIFT_CARD.
   */
  giftCardTags: Maybe<GiftCardTagCountableConnection>;
  /**
   * List of gift cards.
   *
   * Requires one of the following permissions: MANAGE_GIFT_CARD.
   */
  giftCards: Maybe<GiftCardCountableConnection>;
  /**
   * List of activity events to display on homepage (at the moment it only contains order-events).
   *
   * Requires one of the following permissions: MANAGE_ORDERS.
   * @deprecated Field no longer supported
   */
  homepageEvents: Maybe<OrderEventCountableConnection>;
  /** Return the currently authenticated user. */
  me: Maybe<User>;
  /** Look up a navigation menu by ID or name. */
  menu: Maybe<Menu>;
  /** Look up a menu item by ID. */
  menuItem: Maybe<MenuItem>;
  /** List of the storefronts's menu items. */
  menuItems: Maybe<MenuItemCountableConnection>;
  /** List of the storefront's menus. */
  menus: Maybe<MenuCountableConnection>;
  /** Look up an order by ID or external reference. */
  order: Maybe<Order>;
  /**
   * Look up an order by token.
   * @deprecated Field no longer supported
   */
  orderByToken: Maybe<Order>;
  /**
   * Order related settings from site settings. Returns `orderSettings` for the first `channel` in alphabetical order.
   *
   * Requires one of the following permissions: MANAGE_ORDERS.
   * @deprecated Use the `channel` query to fetch the `orderSettings` field instead.
   */
  orderSettings: Maybe<OrderSettings>;
  /**
   * List of orders. The query will not initiate any external requests, including filtering available shipping methods, or performing external tax calculations.
   *
   * Requires one of the following permissions: MANAGE_ORDERS.
   */
  orders: Maybe<OrderCountableConnection>;
  /**
   * Return the total sales amount from a specific period.
   *
   * Requires one of the following permissions: MANAGE_ORDERS.
   * @deprecated Field no longer supported
   */
  ordersTotal: Maybe<TaxedMoney>;
  /** Look up a page by ID or slug. */
  page: Maybe<Page>;
  /** Look up a page type by ID. */
  pageType: Maybe<PageType>;
  /** List of the page types. */
  pageTypes: Maybe<PageTypeCountableConnection>;
  /** List of the shop's pages. */
  pages: Maybe<PageCountableConnection>;
  /**
   * Look up a payment by ID.
   *
   * Requires one of the following permissions: MANAGE_ORDERS.
   */
  payment: Maybe<Payment>;
  /**
   * List of payments.
   *
   * Requires one of the following permissions: MANAGE_ORDERS.
   */
  payments: Maybe<PaymentCountableConnection>;
  /**
   * Look up permission group by ID.
   *
   * Requires one of the following permissions: MANAGE_STAFF.
   */
  permissionGroup: Maybe<Group>;
  /**
   * List of permission groups.
   *
   * Requires one of the following permissions: MANAGE_STAFF.
   */
  permissionGroups: Maybe<GroupCountableConnection>;
  /**
   * Look up a plugin by ID.
   *
   * Requires one of the following permissions: MANAGE_PLUGINS.
   */
  plugin: Maybe<Plugin>;
  /**
   * List of plugins.
   *
   * Requires one of the following permissions: MANAGE_PLUGINS.
   */
  plugins: Maybe<PluginCountableConnection>;
  /** Look up a product by ID. Requires one of the following permissions to include the unpublished items: MANAGE_ORDERS, MANAGE_DISCOUNTS, MANAGE_PRODUCTS. */
  product: Maybe<Product>;
  /** Look up a product type by ID. */
  productType: Maybe<ProductType>;
  /** List of the shop's product types. */
  productTypes: Maybe<ProductTypeCountableConnection>;
  /** Look up a product variant by ID or SKU. Requires one of the following permissions to include the unpublished items: MANAGE_ORDERS, MANAGE_DISCOUNTS, MANAGE_PRODUCTS. */
  productVariant: Maybe<ProductVariant>;
  /** List of product variants. Requires one of the following permissions to include the unpublished items: MANAGE_ORDERS, MANAGE_DISCOUNTS, MANAGE_PRODUCTS. */
  productVariants: Maybe<ProductVariantCountableConnection>;
  /** List of the shop's products. Requires one of the following permissions to include the unpublished items: MANAGE_ORDERS, MANAGE_DISCOUNTS, MANAGE_PRODUCTS. */
  products: Maybe<ProductCountableConnection>;
  /**
   * Look up a promotion by ID.
   *
   * Requires one of the following permissions: MANAGE_DISCOUNTS.
   */
  promotion: Maybe<Promotion>;
  /**
   * List of the promotions.
   *
   * Requires one of the following permissions: MANAGE_DISCOUNTS.
   */
  promotions: Maybe<PromotionCountableConnection>;
  /** Refunds related settings. Returns `RefundSettings` configuration, global for the entire shop. */
  refundSettings: RefundSettings;
  /**
   * List of top selling products.
   *
   * Requires one of the following permissions: MANAGE_PRODUCTS.
   * @deprecated Field no longer supported
   */
  reportProductSales: Maybe<ProductVariantCountableConnection>;
  /**
   * Look up a sale by ID.
   *
   * Requires one of the following permissions: MANAGE_DISCOUNTS.
   * @deprecated Use the `promotion` query instead.
   */
  sale: Maybe<Sale>;
  /**
   * List of the shop's sales.
   *
   * Requires one of the following permissions: MANAGE_DISCOUNTS.
   * @deprecated Use the `promotions` query instead.
   */
  sales: Maybe<SaleCountableConnection>;
  /**
   * Look up a shipping zone by ID.
   *
   * Requires one of the following permissions: MANAGE_SHIPPING.
   */
  shippingZone: Maybe<ShippingZone>;
  /**
   * List of the shop's shipping zones.
   *
   * Requires one of the following permissions: MANAGE_SHIPPING.
   */
  shippingZones: Maybe<ShippingZoneCountableConnection>;
  /** Return information about the shop. */
  shop: Shop;
  /**
   * List of the shop's staff users.
   *
   * Requires one of the following permissions: MANAGE_STAFF.
   */
  staffUsers: Maybe<UserCountableConnection>;
  /**
   * Look up a stock by ID
   *
   * Requires one of the following permissions: MANAGE_PRODUCTS.
   */
  stock: Maybe<Stock>;
  /**
   * List of stocks.
   *
   * Requires one of the following permissions: MANAGE_PRODUCTS.
   */
  stocks: Maybe<StockCountableConnection>;
  /**
   * Look up a tax class.
   *
   * Requires one of the following permissions: AUTHENTICATED_STAFF_USER, AUTHENTICATED_APP.
   */
  taxClass: Maybe<TaxClass>;
  /**
   * List of tax classes.
   *
   * Requires one of the following permissions: AUTHENTICATED_STAFF_USER, AUTHENTICATED_APP.
   */
  taxClasses: Maybe<TaxClassCountableConnection>;
  /**
   * Look up a tax configuration.
   *
   * Requires one of the following permissions: AUTHENTICATED_STAFF_USER, AUTHENTICATED_APP.
   */
  taxConfiguration: Maybe<TaxConfiguration>;
  /**
   * List of tax configurations.
   *
   * Requires one of the following permissions: AUTHENTICATED_STAFF_USER, AUTHENTICATED_APP.
   */
  taxConfigurations: Maybe<TaxConfigurationCountableConnection>;
  /**
   * Tax class rates grouped by country.
   *
   * Requires one of the following permissions: AUTHENTICATED_STAFF_USER, AUTHENTICATED_APP.
   */
  taxCountryConfiguration: Maybe<TaxCountryConfiguration>;
  /** \n\nRequires one of the following permissions: AUTHENTICATED_STAFF_USER, AUTHENTICATED_APP. */
  taxCountryConfigurations: Maybe<Array<TaxCountryConfiguration>>;
  /**
   * List of all tax rates available from tax gateway.
   * @deprecated Use `taxClasses` field instead.
   */
  taxTypes: Maybe<Array<TaxType>>;
  /**
   * Look up a transaction by ID.
   *
   * Requires one of the following permissions: HANDLE_PAYMENTS, MANAGE_ORDERS.
   */
  transaction: Maybe<TransactionItem>;
  /**
   * List of transactions. For apps with `MANAGE_ORDERS` permission, returns all transactions. For apps with just `HANDLE_PAYMENTS` permission, returns only transactions created by that app. For staff users, returns transactions from orders and checkouts in channels they have access to.
   *
   * Added in Saleor 3.22.
   *
   * Requires one of the following permissions: HANDLE_PAYMENTS, MANAGE_ORDERS.
   */
  transactions: Maybe<TransactionCountableConnection>;
  /**
   * Lookup a translatable item by ID.
   *
   * Requires one of the following permissions: MANAGE_TRANSLATIONS.
   */
  translation: Maybe<TranslatableItem>;
  /**
   * Returns a list of all translatable items of a given kind.
   *
   * Requires one of the following permissions: MANAGE_TRANSLATIONS.
   */
  translations: Maybe<TranslatableItemConnection>;
  /**
   * Look up a user by ID or email address.
   *
   * Requires one of the following permissions: MANAGE_STAFF, MANAGE_USERS, MANAGE_ORDERS.
   */
  user: Maybe<User>;
  /**
   * Look up a voucher by ID.
   *
   * Requires one of the following permissions: MANAGE_DISCOUNTS.
   */
  voucher: Maybe<Voucher>;
  /**
   * List of the shop's vouchers.
   *
   * Requires one of the following permissions: MANAGE_DISCOUNTS.
   */
  vouchers: Maybe<VoucherCountableConnection>;
  /**
   * Look up a warehouse by ID.
   *
   * Requires one of the following permissions: MANAGE_PRODUCTS, MANAGE_ORDERS, MANAGE_SHIPPING.
   */
  warehouse: Maybe<Warehouse>;
  /**
   * List of warehouses.
   *
   * Requires one of the following permissions: MANAGE_PRODUCTS, MANAGE_ORDERS, MANAGE_SHIPPING.
   */
  warehouses: Maybe<WarehouseCountableConnection>;
  /** Look up a webhook by ID. Requires one of the following permissions: MANAGE_APPS, OWNER. */
  webhook: Maybe<Webhook>;
  /**
   * List of all available webhook events.
   *
   * Requires one of the following permissions: MANAGE_APPS.
   * @deprecated Use `WebhookEventTypeAsyncEnum` and `WebhookEventTypeSyncEnum` to get available event types.
   */
  webhookEvents: Maybe<Array<WebhookEvent>>;
  /** Retrieve a sample payload for a given webhook event based on real data. It can be useful for some integrations where sample payload is required. */
  webhookSamplePayload: Maybe<Scalars['JSONString']>;
};


export type Query_EntitiesArgs = {
  representations: InputMaybe<Array<InputMaybe<Scalars['_Any']>>>;
};


export type QueryAddressArgs = {
  id: Scalars['ID'];
};


export type QueryAddressValidationRulesArgs = {
  city: InputMaybe<Scalars['String']>;
  cityArea: InputMaybe<Scalars['String']>;
  countryArea: InputMaybe<Scalars['String']>;
  countryCode: CountryCode;
};


export type QueryAppArgs = {
  id: InputMaybe<Scalars['ID']>;
};


export type QueryAppExtensionArgs = {
  id: Scalars['ID'];
};


export type QueryAppExtensionsArgs = {
  after: InputMaybe<Scalars['String']>;
  before: InputMaybe<Scalars['String']>;
  filter: InputMaybe<AppExtensionFilterInput>;
  first: InputMaybe<Scalars['Int']>;
  last: InputMaybe<Scalars['Int']>;
};


export type QueryAppsArgs = {
  after: InputMaybe<Scalars['String']>;
  before: InputMaybe<Scalars['String']>;
  filter: InputMaybe<AppFilterInput>;
  first: InputMaybe<Scalars['Int']>;
  last: InputMaybe<Scalars['Int']>;
  sortBy: InputMaybe<AppSortingInput>;
};


export type QueryAttributeArgs = {
  externalReference: InputMaybe<Scalars['String']>;
  id: InputMaybe<Scalars['ID']>;
  slug: InputMaybe<Scalars['String']>;
};


export type QueryAttributesArgs = {
  after: InputMaybe<Scalars['String']>;
  before: InputMaybe<Scalars['String']>;
  channel: InputMaybe<Scalars['String']>;
  filter: InputMaybe<AttributeFilterInput>;
  first: InputMaybe<Scalars['Int']>;
  last: InputMaybe<Scalars['Int']>;
  search: InputMaybe<Scalars['String']>;
  sortBy: InputMaybe<AttributeSortingInput>;
  where: InputMaybe<AttributeWhereInput>;
};


export type QueryCategoriesArgs = {
  after: InputMaybe<Scalars['String']>;
  before: InputMaybe<Scalars['String']>;
  filter: InputMaybe<CategoryFilterInput>;
  first: InputMaybe<Scalars['Int']>;
  last: InputMaybe<Scalars['Int']>;
  level: InputMaybe<Scalars['Int']>;
  sortBy: InputMaybe<CategorySortingInput>;
  where: InputMaybe<CategoryWhereInput>;
};


export type QueryCategoryArgs = {
  id: InputMaybe<Scalars['ID']>;
  slug: InputMaybe<Scalars['String']>;
  slugLanguageCode: InputMaybe<LanguageCodeEnum>;
};


export type QueryChannelArgs = {
  id: InputMaybe<Scalars['ID']>;
  slug: InputMaybe<Scalars['String']>;
};


export type QueryCheckoutArgs = {
  id: InputMaybe<Scalars['ID']>;
  token: InputMaybe<Scalars['UUID']>;
};


export type QueryCheckoutLinesArgs = {
  after: InputMaybe<Scalars['String']>;
  before: InputMaybe<Scalars['String']>;
  first: InputMaybe<Scalars['Int']>;
  last: InputMaybe<Scalars['Int']>;
};


export type QueryCheckoutsArgs = {
  after: InputMaybe<Scalars['String']>;
  before: InputMaybe<Scalars['String']>;
  channel: InputMaybe<Scalars['String']>;
  filter: InputMaybe<CheckoutFilterInput>;
  first: InputMaybe<Scalars['Int']>;
  last: InputMaybe<Scalars['Int']>;
  sortBy: InputMaybe<CheckoutSortingInput>;
};


export type QueryCollectionArgs = {
  channel: InputMaybe<Scalars['String']>;
  id: InputMaybe<Scalars['ID']>;
  slug: InputMaybe<Scalars['String']>;
  slugLanguageCode: InputMaybe<LanguageCodeEnum>;
};


export type QueryCollectionsArgs = {
  after: InputMaybe<Scalars['String']>;
  before: InputMaybe<Scalars['String']>;
  channel: InputMaybe<Scalars['String']>;
  filter: InputMaybe<CollectionFilterInput>;
  first: InputMaybe<Scalars['Int']>;
  last: InputMaybe<Scalars['Int']>;
  sortBy: InputMaybe<CollectionSortingInput>;
  where: InputMaybe<CollectionWhereInput>;
};


export type QueryCustomersArgs = {
  after: InputMaybe<Scalars['String']>;
  before: InputMaybe<Scalars['String']>;
  filter: InputMaybe<CustomerFilterInput>;
  first: InputMaybe<Scalars['Int']>;
  last: InputMaybe<Scalars['Int']>;
  search: InputMaybe<Scalars['String']>;
  sortBy: InputMaybe<UserSortingInput>;
  where: InputMaybe<CustomerWhereInput>;
};


export type QueryDigitalContentArgs = {
  id: Scalars['ID'];
};


export type QueryDigitalContentsArgs = {
  after: InputMaybe<Scalars['String']>;
  before: InputMaybe<Scalars['String']>;
  first: InputMaybe<Scalars['Int']>;
  last: InputMaybe<Scalars['Int']>;
};


export type QueryDraftOrdersArgs = {
  after: InputMaybe<Scalars['String']>;
  before: InputMaybe<Scalars['String']>;
  filter: InputMaybe<OrderDraftFilterInput>;
  first: InputMaybe<Scalars['Int']>;
  last: InputMaybe<Scalars['Int']>;
  search: InputMaybe<Scalars['String']>;
  sortBy: InputMaybe<OrderSortingInput>;
  where: InputMaybe<DraftOrderWhereInput>;
};


export type QueryExportFileArgs = {
  id: Scalars['ID'];
};


export type QueryExportFilesArgs = {
  after: InputMaybe<Scalars['String']>;
  before: InputMaybe<Scalars['String']>;
  filter: InputMaybe<ExportFileFilterInput>;
  first: InputMaybe<Scalars['Int']>;
  last: InputMaybe<Scalars['Int']>;
  sortBy: InputMaybe<ExportFileSortingInput>;
};


export type QueryGiftCardArgs = {
  id: Scalars['ID'];
};


export type QueryGiftCardTagsArgs = {
  after: InputMaybe<Scalars['String']>;
  before: InputMaybe<Scalars['String']>;
  filter: InputMaybe<GiftCardTagFilterInput>;
  first: InputMaybe<Scalars['Int']>;
  last: InputMaybe<Scalars['Int']>;
};


export type QueryGiftCardsArgs = {
  after: InputMaybe<Scalars['String']>;
  before: InputMaybe<Scalars['String']>;
  filter: InputMaybe<GiftCardFilterInput>;
  first: InputMaybe<Scalars['Int']>;
  last: InputMaybe<Scalars['Int']>;
  search: InputMaybe<Scalars['String']>;
  sortBy: InputMaybe<GiftCardSortingInput>;
};


export type QueryHomepageEventsArgs = {
  after: InputMaybe<Scalars['String']>;
  before: InputMaybe<Scalars['String']>;
  first: InputMaybe<Scalars['Int']>;
  last: InputMaybe<Scalars['Int']>;
};


export type QueryMenuArgs = {
  channel: InputMaybe<Scalars['String']>;
  id: InputMaybe<Scalars['ID']>;
  name: InputMaybe<Scalars['String']>;
  slug: InputMaybe<Scalars['String']>;
};


export type QueryMenuItemArgs = {
  channel: InputMaybe<Scalars['String']>;
  id: Scalars['ID'];
};


export type QueryMenuItemsArgs = {
  after: InputMaybe<Scalars['String']>;
  before: InputMaybe<Scalars['String']>;
  channel: InputMaybe<Scalars['String']>;
  filter: InputMaybe<MenuItemFilterInput>;
  first: InputMaybe<Scalars['Int']>;
  last: InputMaybe<Scalars['Int']>;
  sortBy: InputMaybe<MenuItemSortingInput>;
};


export type QueryMenusArgs = {
  after: InputMaybe<Scalars['String']>;
  before: InputMaybe<Scalars['String']>;
  channel: InputMaybe<Scalars['String']>;
  filter: InputMaybe<MenuFilterInput>;
  first: InputMaybe<Scalars['Int']>;
  last: InputMaybe<Scalars['Int']>;
  sortBy: InputMaybe<MenuSortingInput>;
};


export type QueryOrderArgs = {
  externalReference: InputMaybe<Scalars['String']>;
  id: InputMaybe<Scalars['ID']>;
};


export type QueryOrderByTokenArgs = {
  token: Scalars['UUID'];
};


export type QueryOrdersArgs = {
  after: InputMaybe<Scalars['String']>;
  before: InputMaybe<Scalars['String']>;
  channel: InputMaybe<Scalars['String']>;
  filter: InputMaybe<OrderFilterInput>;
  first: InputMaybe<Scalars['Int']>;
  last: InputMaybe<Scalars['Int']>;
  search: InputMaybe<Scalars['String']>;
  sortBy: InputMaybe<OrderSortingInput>;
  where: InputMaybe<OrderWhereInput>;
};


export type QueryOrdersTotalArgs = {
  channel: InputMaybe<Scalars['String']>;
  period: InputMaybe<ReportingPeriod>;
};


export type QueryPageArgs = {
  channel: InputMaybe<Scalars['String']>;
  id: InputMaybe<Scalars['ID']>;
  slug: InputMaybe<Scalars['String']>;
  slugLanguageCode: InputMaybe<LanguageCodeEnum>;
};


export type QueryPageTypeArgs = {
  id: Scalars['ID'];
};


export type QueryPageTypesArgs = {
  after: InputMaybe<Scalars['String']>;
  before: InputMaybe<Scalars['String']>;
  filter: InputMaybe<PageTypeFilterInput>;
  first: InputMaybe<Scalars['Int']>;
  last: InputMaybe<Scalars['Int']>;
  sortBy: InputMaybe<PageTypeSortingInput>;
};


export type QueryPagesArgs = {
  after: InputMaybe<Scalars['String']>;
  before: InputMaybe<Scalars['String']>;
  channel: InputMaybe<Scalars['String']>;
  filter: InputMaybe<PageFilterInput>;
  first: InputMaybe<Scalars['Int']>;
  last: InputMaybe<Scalars['Int']>;
  search: InputMaybe<Scalars['String']>;
  sortBy: InputMaybe<PageSortingInput>;
  where: InputMaybe<PageWhereInput>;
};


export type QueryPaymentArgs = {
  id: Scalars['ID'];
};


export type QueryPaymentsArgs = {
  after: InputMaybe<Scalars['String']>;
  before: InputMaybe<Scalars['String']>;
  filter: InputMaybe<PaymentFilterInput>;
  first: InputMaybe<Scalars['Int']>;
  last: InputMaybe<Scalars['Int']>;
};


export type QueryPermissionGroupArgs = {
  id: Scalars['ID'];
};


export type QueryPermissionGroupsArgs = {
  after: InputMaybe<Scalars['String']>;
  before: InputMaybe<Scalars['String']>;
  filter: InputMaybe<PermissionGroupFilterInput>;
  first: InputMaybe<Scalars['Int']>;
  last: InputMaybe<Scalars['Int']>;
  sortBy: InputMaybe<PermissionGroupSortingInput>;
};


export type QueryPluginArgs = {
  id: Scalars['ID'];
};


export type QueryPluginsArgs = {
  after: InputMaybe<Scalars['String']>;
  before: InputMaybe<Scalars['String']>;
  filter: InputMaybe<PluginFilterInput>;
  first: InputMaybe<Scalars['Int']>;
  last: InputMaybe<Scalars['Int']>;
  sortBy: InputMaybe<PluginSortingInput>;
};


export type QueryProductArgs = {
  channel: InputMaybe<Scalars['String']>;
  externalReference: InputMaybe<Scalars['String']>;
  id: InputMaybe<Scalars['ID']>;
  slug: InputMaybe<Scalars['String']>;
  slugLanguageCode: InputMaybe<LanguageCodeEnum>;
};


export type QueryProductTypeArgs = {
  id: Scalars['ID'];
};


export type QueryProductTypesArgs = {
  after: InputMaybe<Scalars['String']>;
  before: InputMaybe<Scalars['String']>;
  filter: InputMaybe<ProductTypeFilterInput>;
  first: InputMaybe<Scalars['Int']>;
  last: InputMaybe<Scalars['Int']>;
  sortBy: InputMaybe<ProductTypeSortingInput>;
};


export type QueryProductVariantArgs = {
  channel: InputMaybe<Scalars['String']>;
  externalReference: InputMaybe<Scalars['String']>;
  id: InputMaybe<Scalars['ID']>;
  sku: InputMaybe<Scalars['String']>;
};


export type QueryProductVariantsArgs = {
  after: InputMaybe<Scalars['String']>;
  before: InputMaybe<Scalars['String']>;
  channel: InputMaybe<Scalars['String']>;
  filter: InputMaybe<ProductVariantFilterInput>;
  first: InputMaybe<Scalars['Int']>;
  ids: InputMaybe<Array<Scalars['ID']>>;
  last: InputMaybe<Scalars['Int']>;
  search: InputMaybe<Scalars['String']>;
  sortBy: InputMaybe<ProductVariantSortingInput>;
  where: InputMaybe<ProductVariantWhereInput>;
};


export type QueryProductsArgs = {
  after: InputMaybe<Scalars['String']>;
  before: InputMaybe<Scalars['String']>;
  channel: InputMaybe<Scalars['String']>;
  filter: InputMaybe<ProductFilterInput>;
  first: InputMaybe<Scalars['Int']>;
  last: InputMaybe<Scalars['Int']>;
  search: InputMaybe<Scalars['String']>;
  sortBy: InputMaybe<ProductOrder>;
  where: InputMaybe<ProductWhereInput>;
};


export type QueryPromotionArgs = {
  id: Scalars['ID'];
};


export type QueryPromotionsArgs = {
  after: InputMaybe<Scalars['String']>;
  before: InputMaybe<Scalars['String']>;
  first: InputMaybe<Scalars['Int']>;
  last: InputMaybe<Scalars['Int']>;
  sortBy: InputMaybe<PromotionSortingInput>;
  where: InputMaybe<PromotionWhereInput>;
};


export type QueryReportProductSalesArgs = {
  after: InputMaybe<Scalars['String']>;
  before: InputMaybe<Scalars['String']>;
  channel: Scalars['String'];
  first: InputMaybe<Scalars['Int']>;
  last: InputMaybe<Scalars['Int']>;
  period: ReportingPeriod;
};


export type QuerySaleArgs = {
  channel: InputMaybe<Scalars['String']>;
  id: Scalars['ID'];
};


export type QuerySalesArgs = {
  after: InputMaybe<Scalars['String']>;
  before: InputMaybe<Scalars['String']>;
  channel: InputMaybe<Scalars['String']>;
  filter: InputMaybe<SaleFilterInput>;
  first: InputMaybe<Scalars['Int']>;
  last: InputMaybe<Scalars['Int']>;
  query: InputMaybe<Scalars['String']>;
  sortBy: InputMaybe<SaleSortingInput>;
};


export type QueryShippingZoneArgs = {
  channel: InputMaybe<Scalars['String']>;
  id: Scalars['ID'];
};


export type QueryShippingZonesArgs = {
  after: InputMaybe<Scalars['String']>;
  before: InputMaybe<Scalars['String']>;
  channel: InputMaybe<Scalars['String']>;
  filter: InputMaybe<ShippingZoneFilterInput>;
  first: InputMaybe<Scalars['Int']>;
  last: InputMaybe<Scalars['Int']>;
};


export type QueryStaffUsersArgs = {
  after: InputMaybe<Scalars['String']>;
  before: InputMaybe<Scalars['String']>;
  filter: InputMaybe<StaffUserInput>;
  first: InputMaybe<Scalars['Int']>;
  last: InputMaybe<Scalars['Int']>;
  sortBy: InputMaybe<UserSortingInput>;
};


export type QueryStockArgs = {
  id: Scalars['ID'];
};


export type QueryStocksArgs = {
  after: InputMaybe<Scalars['String']>;
  before: InputMaybe<Scalars['String']>;
  filter: InputMaybe<StockFilterInput>;
  first: InputMaybe<Scalars['Int']>;
  last: InputMaybe<Scalars['Int']>;
};


export type QueryTaxClassArgs = {
  id: Scalars['ID'];
};


export type QueryTaxClassesArgs = {
  after: InputMaybe<Scalars['String']>;
  before: InputMaybe<Scalars['String']>;
  filter: InputMaybe<TaxClassFilterInput>;
  first: InputMaybe<Scalars['Int']>;
  last: InputMaybe<Scalars['Int']>;
  sortBy: InputMaybe<TaxClassSortingInput>;
};


export type QueryTaxConfigurationArgs = {
  id: Scalars['ID'];
};


export type QueryTaxConfigurationsArgs = {
  after: InputMaybe<Scalars['String']>;
  before: InputMaybe<Scalars['String']>;
  filter: InputMaybe<TaxConfigurationFilterInput>;
  first: InputMaybe<Scalars['Int']>;
  last: InputMaybe<Scalars['Int']>;
};


export type QueryTaxCountryConfigurationArgs = {
  countryCode: CountryCode;
};


export type QueryTransactionArgs = {
  id: InputMaybe<Scalars['ID']>;
  token: InputMaybe<Scalars['UUID']>;
};


export type QueryTransactionsArgs = {
  after: InputMaybe<Scalars['String']>;
  before: InputMaybe<Scalars['String']>;
  first: InputMaybe<Scalars['Int']>;
  last: InputMaybe<Scalars['Int']>;
  where: InputMaybe<TransactionWhereInput>;
};


export type QueryTranslationArgs = {
  id: Scalars['ID'];
  kind: TranslatableKinds;
};


export type QueryTranslationsArgs = {
  after: InputMaybe<Scalars['String']>;
  before: InputMaybe<Scalars['String']>;
  first: InputMaybe<Scalars['Int']>;
  kind: TranslatableKinds;
  last: InputMaybe<Scalars['Int']>;
};


export type QueryUserArgs = {
  email: InputMaybe<Scalars['String']>;
  externalReference: InputMaybe<Scalars['String']>;
  id: InputMaybe<Scalars['ID']>;
};


export type QueryVoucherArgs = {
  channel: InputMaybe<Scalars['String']>;
  id: Scalars['ID'];
};


export type QueryVouchersArgs = {
  after: InputMaybe<Scalars['String']>;
  before: InputMaybe<Scalars['String']>;
  channel: InputMaybe<Scalars['String']>;
  filter: InputMaybe<VoucherFilterInput>;
  first: InputMaybe<Scalars['Int']>;
  last: InputMaybe<Scalars['Int']>;
  query: InputMaybe<Scalars['String']>;
  sortBy: InputMaybe<VoucherSortingInput>;
};


export type QueryWarehouseArgs = {
  externalReference: InputMaybe<Scalars['String']>;
  id: InputMaybe<Scalars['ID']>;
};


export type QueryWarehousesArgs = {
  after: InputMaybe<Scalars['String']>;
  before: InputMaybe<Scalars['String']>;
  filter: InputMaybe<WarehouseFilterInput>;
  first: InputMaybe<Scalars['Int']>;
  last: InputMaybe<Scalars['Int']>;
  sortBy: InputMaybe<WarehouseSortingInput>;
};


export type QueryWebhookArgs = {
  id: Scalars['ID'];
};


export type QueryWebhookSamplePayloadArgs = {
  eventType: WebhookSampleEventTypeEnum;
};

/** Represents a reduced VAT rate for a particular type of goods. */
export type ReducedRate = {
  __typename: 'ReducedRate';
  /** Reduced VAT rate in percent. */
  rate: Scalars['Float'];
  /** A type of goods. */
  rateType: Scalars['String'];
};

/**
 * The reference types (product or page type) that are used to narrow down the choices of reference objects.
 * ProductType applicable for reference attribute with `PRODUCT` or `PRODUCT_VARIANT` entity type.
 * PageType applicable for reference attribute with `PAGE` entity type.
 */
export type ReferenceType = PageType | ProductType;

/** Refresh JWT token. Mutation tries to take refreshToken from the input. If it fails it will try to take `refreshToken` from the http-only cookie `refreshToken`. `csrfToken` is required when `refreshToken` is provided as a cookie. */
export type RefreshToken = {
  __typename: 'RefreshToken';
  /** @deprecated Use `errors` field instead. */
  accountErrors: Array<AccountError>;
  errors: Array<AccountError>;
  /** JWT token, required to authenticate. */
  token: Maybe<Scalars['String']>;
  /** A user instance. */
  user: Maybe<User>;
};

/**
 * Updates RefundSettings. The `Page` (Model) Type will be cleared from `reasonReferenceType`. When it's cleared, passing reason reference to refund mutations is no longer accepted and will raise error.
 *
 * Added in Saleor 3.22.
 *
 * Requires one of the following permissions: MANAGE_SETTINGS.
 */
export type RefundReasonReferenceTypeClear = {
  __typename: 'RefundReasonReferenceTypeClear';
  errors: Array<RefundReasonReferenceTypeClearError>;
  /** Refund settings. */
  refundSettings: RefundSettings;
  /** @deprecated Use `errors` field instead. */
  refundSettingsErrors: Array<RefundReasonReferenceTypeClearError>;
};

export type RefundReasonReferenceTypeClearError = {
  __typename: 'RefundReasonReferenceTypeClearError';
  /** Failed to clear refund reason reference type */
  code: RefundSettingsErrorCode;
  /** Name of a field that caused the error. A value of `null` indicates that the error isn't associated with a particular field. */
  field: Maybe<Scalars['String']>;
  /** The error message. */
  message: Maybe<Scalars['String']>;
};

/**
 * Refund related settings from site settings.
 *
 * Added in Saleor 3.22.
 */
export type RefundSettings = {
  __typename: 'RefundSettings';
  /** Model type used for refund reasons. */
  reasonReferenceType: Maybe<PageType>;
};

export type RefundSettingsErrorCode =
  | 'GRAPHQL_ERROR'
  | 'INVALID'
  | 'REQUIRED';

/**
 * Update refund settings across all channels.
 *
 * Added in Saleor 3.22.
 *
 * Requires one of the following permissions: MANAGE_SETTINGS.
 */
export type RefundSettingsUpdate = {
  __typename: 'RefundSettingsUpdate';
  errors: Array<RefundSettingsUpdateError>;
  /** Refund settings. */
  refundSettings: RefundSettings;
  /** @deprecated Use `errors` field instead. */
  refundSettingsErrors: Array<RefundSettingsUpdateError>;
};

export type RefundSettingsUpdateError = {
  __typename: 'RefundSettingsUpdateError';
  /** Failed to update Refund Settings */
  code: RefundSettingsErrorCode;
  /** Name of a field that caused the error. A value of `null` indicates that the error isn't associated with a particular field. */
  field: Maybe<Scalars['String']>;
  /** The error message. */
  message: Maybe<Scalars['String']>;
};

export type RefundSettingsUpdateInput = {
  /**
   * The ID of a model type, that will be used to reference refund reasons. All models with of this type will be accepted as refund reasons.
   *
   * Added in Saleor 3.22.
   */
  refundReasonReferenceType: Scalars['ID'];
};

export type ReorderInput = {
  /** The ID of the item to move. */
  id: Scalars['ID'];
  /** The new relative sorting position of the item (from -inf to +inf). 1 moves the item one position forward, -1 moves the item one position backward, 0 leaves the item unchanged. */
  sortOrder: InputMaybe<Scalars['Int']>;
};

export type ReportingPeriod =
  | 'THIS_MONTH'
  | 'TODAY';

/**
 * Request email change of the logged in user.
 *
 * Requires one of the following permissions: AUTHENTICATED_USER.
 *
 * Triggers the following webhook events:
 * - NOTIFY_USER (async): A notification for account email change.
 * - ACCOUNT_CHANGE_EMAIL_REQUESTED (async): An account email change was requested.
 */
export type RequestEmailChange = {
  __typename: 'RequestEmailChange';
  /** @deprecated Use `errors` field instead. */
  accountErrors: Array<AccountError>;
  errors: Array<AccountError>;
  /** A user instance. */
  user: Maybe<User>;
};

/**
 * Sends an email with the account password modification link.
 *
 * Triggers the following webhook events:
 * - NOTIFY_USER (async): A notification for password reset.
 * - ACCOUNT_SET_PASSWORD_REQUESTED (async): Setting a new password for the account is requested.
 * - STAFF_SET_PASSWORD_REQUESTED (async): Setting a new password for the staff account is requested.
 */
export type RequestPasswordReset = {
  __typename: 'RequestPasswordReset';
  /** @deprecated Use `errors` field instead. */
  accountErrors: Array<AccountError>;
  errors: Array<AccountError>;
};

export type RewardTypeEnum =
  | 'GIFT'
  | 'SUBTOTAL_DISCOUNT';

export type RewardValueTypeEnum =
  | 'FIXED'
  | 'PERCENTAGE';

/**
 * Sales allow creating discounts for categories, collections or products and are visible to all the customers.
 *
 * DEPRECATED: this type will be removed. Use `Promotion` type instead.
 */
export type Sale = Node & ObjectWithMetadata & {
  __typename: 'Sale';
  /** List of categories this sale applies to. */
  categories: Maybe<CategoryCountableConnection>;
  /**
   * List of channels available for the sale.
   *
   * Requires one of the following permissions: MANAGE_DISCOUNTS.
   */
  channelListings: Maybe<Array<SaleChannelListing>>;
  /**
   * List of collections this sale applies to.
   *
   * Requires one of the following permissions: MANAGE_DISCOUNTS.
   */
  collections: Maybe<CollectionCountableConnection>;
  /** The date and time when the sale was created. */
  created: Scalars['DateTime'];
  /** Currency code for sale. */
  currency: Maybe<Scalars['String']>;
  /** Sale value. */
  discountValue: Maybe<Scalars['Float']>;
  /** The end date and time of the sale. */
  endDate: Maybe<Scalars['DateTime']>;
  /** The ID of the sale. */
  id: Scalars['ID'];
  /** List of public metadata items. Can be accessed without permissions. */
  metadata: Array<MetadataItem>;
  /**
   * A single key from public metadata.
   *
   * Tip: Use GraphQL aliases to fetch multiple keys.
   */
  metafield: Maybe<Scalars['String']>;
  /** Public metadata. Use `keys` to control which fields you want to include. The default is to include everything. */
  metafields: Maybe<Scalars['Metadata']>;
  /** The name of the sale. */
  name: Scalars['String'];
  /** List of private metadata items. Requires staff permissions to access. */
  privateMetadata: Array<MetadataItem>;
  /**
   * A single key from private metadata. Requires staff permissions to access.
   *
   * Tip: Use GraphQL aliases to fetch multiple keys.
   */
  privateMetafield: Maybe<Scalars['String']>;
  /** Private metadata. Requires staff permissions to access. Use `keys` to control which fields you want to include. The default is to include everything. */
  privateMetafields: Maybe<Scalars['Metadata']>;
  /**
   * List of products this sale applies to.
   *
   * Requires one of the following permissions: MANAGE_DISCOUNTS.
   */
  products: Maybe<ProductCountableConnection>;
  /** The start date and time of the sale. */
  startDate: Scalars['DateTime'];
  /** Returns translated sale fields for the given language code. */
  translation: Maybe<SaleTranslation>;
  /** Type of the sale, fixed or percentage. */
  type: SaleType;
  /** The date and time when the sale was updated. */
  updatedAt: Scalars['DateTime'];
  /**
   * List of product variants this sale applies to.
   *
   * Requires one of the following permissions: MANAGE_DISCOUNTS.
   */
  variants: Maybe<ProductVariantCountableConnection>;
};


/**
 * Sales allow creating discounts for categories, collections or products and are visible to all the customers.
 *
 * DEPRECATED: this type will be removed. Use `Promotion` type instead.
 */
export type SaleCategoriesArgs = {
  after: InputMaybe<Scalars['String']>;
  before: InputMaybe<Scalars['String']>;
  first: InputMaybe<Scalars['Int']>;
  last: InputMaybe<Scalars['Int']>;
};


/**
 * Sales allow creating discounts for categories, collections or products and are visible to all the customers.
 *
 * DEPRECATED: this type will be removed. Use `Promotion` type instead.
 */
export type SaleCollectionsArgs = {
  after: InputMaybe<Scalars['String']>;
  before: InputMaybe<Scalars['String']>;
  first: InputMaybe<Scalars['Int']>;
  last: InputMaybe<Scalars['Int']>;
};


/**
 * Sales allow creating discounts for categories, collections or products and are visible to all the customers.
 *
 * DEPRECATED: this type will be removed. Use `Promotion` type instead.
 */
export type SaleMetafieldArgs = {
  key: Scalars['String'];
};


/**
 * Sales allow creating discounts for categories, collections or products and are visible to all the customers.
 *
 * DEPRECATED: this type will be removed. Use `Promotion` type instead.
 */
export type SaleMetafieldsArgs = {
  keys: InputMaybe<Array<Scalars['String']>>;
};


/**
 * Sales allow creating discounts for categories, collections or products and are visible to all the customers.
 *
 * DEPRECATED: this type will be removed. Use `Promotion` type instead.
 */
export type SalePrivateMetafieldArgs = {
  key: Scalars['String'];
};


/**
 * Sales allow creating discounts for categories, collections or products and are visible to all the customers.
 *
 * DEPRECATED: this type will be removed. Use `Promotion` type instead.
 */
export type SalePrivateMetafieldsArgs = {
  keys: InputMaybe<Array<Scalars['String']>>;
};


/**
 * Sales allow creating discounts for categories, collections or products and are visible to all the customers.
 *
 * DEPRECATED: this type will be removed. Use `Promotion` type instead.
 */
export type SaleProductsArgs = {
  after: InputMaybe<Scalars['String']>;
  before: InputMaybe<Scalars['String']>;
  first: InputMaybe<Scalars['Int']>;
  last: InputMaybe<Scalars['Int']>;
};


/**
 * Sales allow creating discounts for categories, collections or products and are visible to all the customers.
 *
 * DEPRECATED: this type will be removed. Use `Promotion` type instead.
 */
export type SaleTranslationArgs = {
  languageCode: LanguageCodeEnum;
};


/**
 * Sales allow creating discounts for categories, collections or products and are visible to all the customers.
 *
 * DEPRECATED: this type will be removed. Use `Promotion` type instead.
 */
export type SaleVariantsArgs = {
  after: InputMaybe<Scalars['String']>;
  before: InputMaybe<Scalars['String']>;
  first: InputMaybe<Scalars['Int']>;
  last: InputMaybe<Scalars['Int']>;
};

/**
 * Adds products, categories, collections to a sale.
 *
 * Requires one of the following permissions: MANAGE_DISCOUNTS.
 *
 * Triggers the following webhook events:
 * - SALE_UPDATED (async): A sale was updated.
 */
export type SaleAddCatalogues = {
  __typename: 'SaleAddCatalogues';
  /** @deprecated Use `errors` field instead. */
  discountErrors: Array<DiscountError>;
  errors: Array<DiscountError>;
  /** Sale of which catalogue IDs will be modified. */
  sale: Maybe<Sale>;
};

/**
 * Deletes sales.
 *
 * Requires one of the following permissions: MANAGE_DISCOUNTS.
 *
 * Triggers the following webhook events:
 * - SALE_DELETED (async): A sale was deleted.
 */
export type SaleBulkDelete = {
  __typename: 'SaleBulkDelete';
  /** Returns how many objects were affected. */
  count: Scalars['Int'];
  /** @deprecated Use `errors` field instead. */
  discountErrors: Array<DiscountError>;
  errors: Array<DiscountError>;
};

/**
 * Represents sale channel listing.
 *
 * DEPRECATED: this type will be removed. Use `PromotionRule` type instead.
 */
export type SaleChannelListing = Node & {
  __typename: 'SaleChannelListing';
  /** The channel in which the sale is available. */
  channel: Channel;
  /** The currency in which the discount value is specified. */
  currency: Scalars['String'];
  /** The value of the discount applied to the sale in the channel. */
  discountValue: Scalars['Float'];
  /** The ID of the channel listing. */
  id: Scalars['ID'];
};

export type SaleChannelListingAddInput = {
  /** ID of a channel. */
  channelId: Scalars['ID'];
  /** The value of the discount. */
  discountValue: Scalars['PositiveDecimal'];
};

export type SaleChannelListingInput = {
  /** List of channels to which the sale should be assigned. */
  addChannels: InputMaybe<Array<SaleChannelListingAddInput>>;
  /** List of channels from which the sale should be unassigned. */
  removeChannels: InputMaybe<Array<Scalars['ID']>>;
};

/**
 * Manage sale's availability in channels.
 *
 * Requires one of the following permissions: MANAGE_DISCOUNTS.
 */
export type SaleChannelListingUpdate = {
  __typename: 'SaleChannelListingUpdate';
  /** @deprecated Use `errors` field instead. */
  discountErrors: Array<DiscountError>;
  errors: Array<DiscountError>;
  /** An updated sale instance. */
  sale: Maybe<Sale>;
};

export type SaleCountableConnection = {
  __typename: 'SaleCountableConnection';
  edges: Array<SaleCountableEdge>;
  /** Pagination data for this connection. */
  pageInfo: PageInfo;
  /** A total count of items in the collection. */
  totalCount: Maybe<Scalars['Int']>;
};

export type SaleCountableEdge = {
  __typename: 'SaleCountableEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node: Sale;
};

/**
 * Creates a new sale.
 *
 * Requires one of the following permissions: MANAGE_DISCOUNTS.
 *
 * Triggers the following webhook events:
 * - SALE_CREATED (async): A sale was created.
 */
export type SaleCreate = {
  __typename: 'SaleCreate';
  /** @deprecated Use `errors` field instead. */
  discountErrors: Array<DiscountError>;
  errors: Array<DiscountError>;
  sale: Maybe<Sale>;
};

/**
 * Event sent when new sale is created.
 *
 * DEPRECATED: this event will be removed. Use `PromotionCreated` event instead.
 */
export type SaleCreated = Event & {
  __typename: 'SaleCreated';
  /** Time of the event. */
  issuedAt: Maybe<Scalars['DateTime']>;
  /** The user or application that triggered the event. */
  issuingPrincipal: Maybe<IssuingPrincipal>;
  /** The application receiving the webhook. */
  recipient: Maybe<App>;
  /** The sale the event relates to. */
  sale: Maybe<Sale>;
  /** Saleor version that triggered the event. */
  version: Maybe<Scalars['String']>;
};


/**
 * Event sent when new sale is created.
 *
 * DEPRECATED: this event will be removed. Use `PromotionCreated` event instead.
 */
export type SaleCreatedSaleArgs = {
  channel: InputMaybe<Scalars['String']>;
};

/**
 * Deletes a sale.
 *
 * Requires one of the following permissions: MANAGE_DISCOUNTS.
 *
 * Triggers the following webhook events:
 * - SALE_DELETED (async): A sale was deleted.
 */
export type SaleDelete = {
  __typename: 'SaleDelete';
  /** @deprecated Use `errors` field instead. */
  discountErrors: Array<DiscountError>;
  errors: Array<DiscountError>;
  sale: Maybe<Sale>;
};

/**
 * Event sent when sale is deleted.
 *
 * DEPRECATED: this event will be removed. Use `PromotionDeleted` event instead.
 */
export type SaleDeleted = Event & {
  __typename: 'SaleDeleted';
  /** Time of the event. */
  issuedAt: Maybe<Scalars['DateTime']>;
  /** The user or application that triggered the event. */
  issuingPrincipal: Maybe<IssuingPrincipal>;
  /** The application receiving the webhook. */
  recipient: Maybe<App>;
  /** The sale the event relates to. */
  sale: Maybe<Sale>;
  /** Saleor version that triggered the event. */
  version: Maybe<Scalars['String']>;
};


/**
 * Event sent when sale is deleted.
 *
 * DEPRECATED: this event will be removed. Use `PromotionDeleted` event instead.
 */
export type SaleDeletedSaleArgs = {
  channel: InputMaybe<Scalars['String']>;
};

export type SaleFilterInput = {
  metadata: InputMaybe<Array<MetadataFilter>>;
  saleType: InputMaybe<DiscountValueTypeEnum>;
  search: InputMaybe<Scalars['String']>;
  started: InputMaybe<DateTimeRangeInput>;
  status: InputMaybe<Array<DiscountStatusEnum>>;
  updatedAt: InputMaybe<DateTimeRangeInput>;
};

export type SaleInput = {
  /** Categories related to the discount. */
  categories: InputMaybe<Array<Scalars['ID']>>;
  /** Collections related to the discount. */
  collections: InputMaybe<Array<Scalars['ID']>>;
  /** End date of the voucher in ISO 8601 format. */
  endDate: InputMaybe<Scalars['DateTime']>;
  /** Voucher name. */
  name: InputMaybe<Scalars['String']>;
  /** Products related to the discount. */
  products: InputMaybe<Array<Scalars['ID']>>;
  /** Start date of the voucher in ISO 8601 format. */
  startDate: InputMaybe<Scalars['DateTime']>;
  /** Fixed or percentage. */
  type: InputMaybe<DiscountValueTypeEnum>;
  /** Value of the voucher. */
  value: InputMaybe<Scalars['PositiveDecimal']>;
  variants: InputMaybe<Array<Scalars['ID']>>;
};

/**
 * Removes products, categories, collections from a sale.
 *
 * Requires one of the following permissions: MANAGE_DISCOUNTS.
 *
 * Triggers the following webhook events:
 * - SALE_UPDATED (async): A sale was updated.
 */
export type SaleRemoveCatalogues = {
  __typename: 'SaleRemoveCatalogues';
  /** @deprecated Use `errors` field instead. */
  discountErrors: Array<DiscountError>;
  errors: Array<DiscountError>;
  /** Sale of which catalogue IDs will be modified. */
  sale: Maybe<Sale>;
};

export type SaleSortField =
  /** Sort sales by creation date. */
  | 'CREATED_AT'
  /** Sort sales by end date. */
  | 'END_DATE'
  /** Sort sales by last modification date. */
  | 'LAST_MODIFIED_AT'
  /** Sort sales by name. */
  | 'NAME'
  /** Sort sales by start date. */
  | 'START_DATE'
  /** Sort sales by type. */
  | 'TYPE'
  /**
   * Sort sales by value.
   *
   * This option requires a channel filter to work as the values can vary between channels.
   */
  | 'VALUE';

export type SaleSortingInput = {
  /**
   * Specifies the channel in which to sort the data.
   * @deprecated Use root-level channel argument instead.
   */
  channel: InputMaybe<Scalars['String']>;
  /** Specifies the direction in which to sort sales. */
  direction: OrderDirection;
  /** Sort sales by the selected field. */
  field: SaleSortField;
};

/**
 * The event informs about the start or end of the sale.
 *
 * DEPRECATED: this event will be removed. Use `PromotionStarted` and `PromotionEnded` events instead.
 */
export type SaleToggle = Event & {
  __typename: 'SaleToggle';
  /** Time of the event. */
  issuedAt: Maybe<Scalars['DateTime']>;
  /** The user or application that triggered the event. */
  issuingPrincipal: Maybe<IssuingPrincipal>;
  /** The application receiving the webhook. */
  recipient: Maybe<App>;
  /** The sale the event relates to. */
  sale: Maybe<Sale>;
  /** Saleor version that triggered the event. */
  version: Maybe<Scalars['String']>;
};


/**
 * The event informs about the start or end of the sale.
 *
 * DEPRECATED: this event will be removed. Use `PromotionStarted` and `PromotionEnded` events instead.
 */
export type SaleToggleSaleArgs = {
  channel: InputMaybe<Scalars['String']>;
};

/**
 * Represents sale's original translatable fields and related translations.
 *
 * DEPRECATED: this type will be removed. Use `PromotionTranslatableContent` instead.
 */
export type SaleTranslatableContent = Node & {
  __typename: 'SaleTranslatableContent';
  /** The ID of the sale translatable content. */
  id: Scalars['ID'];
  /** Name of the sale to translate. */
  name: Scalars['String'];
  /**
   * Sales allow creating discounts for categories, collections or products and are visible to all the customers.
   *
   * Requires one of the following permissions: MANAGE_DISCOUNTS.
   * @deprecated Get model fields from the root level queries.
   */
  sale: Maybe<Sale>;
  /** The ID of the sale to translate. */
  saleId: Scalars['ID'];
  /** Returns translated sale fields for the given language code. */
  translation: Maybe<SaleTranslation>;
};


/**
 * Represents sale's original translatable fields and related translations.
 *
 * DEPRECATED: this type will be removed. Use `PromotionTranslatableContent` instead.
 */
export type SaleTranslatableContentTranslationArgs = {
  languageCode: LanguageCodeEnum;
};

/**
 * Creates/updates translations for a sale.
 *
 * Requires one of the following permissions: MANAGE_TRANSLATIONS.
 */
export type SaleTranslate = {
  __typename: 'SaleTranslate';
  errors: Array<TranslationError>;
  sale: Maybe<Sale>;
  /** @deprecated Use `errors` field instead. */
  translationErrors: Array<TranslationError>;
};

/**
 * Represents sale translations.
 *
 * DEPRECATED: this type will be removed. Use `PromotionTranslation` instead.
 */
export type SaleTranslation = Node & {
  __typename: 'SaleTranslation';
  /** The ID of the sale translation. */
  id: Scalars['ID'];
  /** Translation language. */
  language: LanguageDisplay;
  /** Translated name of sale. */
  name: Maybe<Scalars['String']>;
  /** Represents the sale fields to translate. */
  translatableContent: Maybe<SaleTranslatableContent>;
};

export type SaleType =
  | 'FIXED'
  | 'PERCENTAGE';

/**
 * Updates a sale.
 *
 * Requires one of the following permissions: MANAGE_DISCOUNTS.
 *
 * Triggers the following webhook events:
 * - SALE_UPDATED (async): A sale was updated.
 * - SALE_TOGGLE (async): Optionally triggered when a sale is started or stopped.
 */
export type SaleUpdate = {
  __typename: 'SaleUpdate';
  /** @deprecated Use `errors` field instead. */
  discountErrors: Array<DiscountError>;
  errors: Array<DiscountError>;
  sale: Maybe<Sale>;
};

/**
 * Event sent when sale is updated.
 *
 * DEPRECATED: this event will be removed. Use `PromotionUpdated` event instead.
 */
export type SaleUpdated = Event & {
  __typename: 'SaleUpdated';
  /** Time of the event. */
  issuedAt: Maybe<Scalars['DateTime']>;
  /** The user or application that triggered the event. */
  issuingPrincipal: Maybe<IssuingPrincipal>;
  /** The application receiving the webhook. */
  recipient: Maybe<App>;
  /** The sale the event relates to. */
  sale: Maybe<Sale>;
  /** Saleor version that triggered the event. */
  version: Maybe<Scalars['String']>;
};


/**
 * Event sent when sale is updated.
 *
 * DEPRECATED: this event will be removed. Use `PromotionUpdated` event instead.
 */
export type SaleUpdatedSaleArgs = {
  channel: InputMaybe<Scalars['String']>;
};

/** Represents an assigned attribute to an object. */
export type SelectedAttribute = {
  __typename: 'SelectedAttribute';
  /** Name of an attribute displayed in the interface. */
  attribute: Attribute;
  /** Values of an attribute. */
  values: Array<AttributeValue>;
};

/**
 * Sends a notification confirmation.
 *
 * Requires one of the following permissions: AUTHENTICATED_USER.
 *
 * Triggers the following webhook events:
 * - NOTIFY_USER (async): A notification for account confirmation.
 * - ACCOUNT_CONFIRMATION_REQUESTED (async): An account confirmation was requested. This event is always sent regardless of settings.
 */
export type SendConfirmationEmail = {
  __typename: 'SendConfirmationEmail';
  errors: Array<SendConfirmationEmailError>;
};

export type SendConfirmationEmailError = {
  __typename: 'SendConfirmationEmailError';
  /** The error code. */
  code: SendConfirmationEmailErrorCode;
  /** Name of a field that caused the error. A value of `null` indicates that the error isn't associated with a particular field. */
  field: Maybe<Scalars['String']>;
  /** The error message. */
  message: Maybe<Scalars['String']>;
};

export type SendConfirmationEmailErrorCode =
  | 'ACCOUNT_CONFIRMED'
  | 'CONFIRMATION_ALREADY_REQUESTED'
  | 'INVALID'
  | 'MISSING_CHANNEL_SLUG';

export type SeoInput = {
  /** SEO description. */
  description: InputMaybe<Scalars['String']>;
  /** SEO title. */
  title: InputMaybe<Scalars['String']>;
};

/** Sets the user's password from the token sent by email using the RequestPasswordReset mutation. */
export type SetPassword = {
  __typename: 'SetPassword';
  /** @deprecated Use `errors` field instead. */
  accountErrors: Array<AccountError>;
  /** CSRF token required to re-generate access token. */
  csrfToken: Maybe<Scalars['String']>;
  errors: Array<AccountError>;
  /** JWT refresh token, required to re-generate access token. */
  refreshToken: Maybe<Scalars['String']>;
  /** JWT token, required to authenticate. */
  token: Maybe<Scalars['String']>;
  /** A user instance. */
  user: Maybe<User>;
};

export type ShippingError = {
  __typename: 'ShippingError';
  /** List of channels IDs which causes the error. */
  channels: Maybe<Array<Scalars['ID']>>;
  /** The error code. */
  code: ShippingErrorCode;
  /** Name of a field that caused the error. A value of `null` indicates that the error isn't associated with a particular field. */
  field: Maybe<Scalars['String']>;
  /** The error message. */
  message: Maybe<Scalars['String']>;
  /** List of warehouse IDs which causes the error. */
  warehouses: Maybe<Array<Scalars['ID']>>;
};

export type ShippingErrorCode =
  | 'ALREADY_EXISTS'
  | 'DUPLICATED_INPUT_ITEM'
  | 'GRAPHQL_ERROR'
  | 'INVALID'
  | 'MAX_LESS_THAN_MIN'
  | 'NOT_FOUND'
  | 'REQUIRED'
  | 'UNIQUE';

/** List shipping methods for checkout. */
export type ShippingListMethodsForCheckout = Event & {
  __typename: 'ShippingListMethodsForCheckout';
  /** The checkout the event relates to. */
  checkout: Maybe<Checkout>;
  /** Time of the event. */
  issuedAt: Maybe<Scalars['DateTime']>;
  /** The user or application that triggered the event. */
  issuingPrincipal: Maybe<IssuingPrincipal>;
  /** The application receiving the webhook. */
  recipient: Maybe<App>;
  /** Shipping methods that can be used with this checkout. */
  shippingMethods: Maybe<Array<ShippingMethod>>;
  /** Saleor version that triggered the event. */
  version: Maybe<Scalars['String']>;
};

/** Shipping methods that can be used as means of shipping for orders and checkouts. */
export type ShippingMethod = Node & ObjectWithMetadata & {
  __typename: 'ShippingMethod';
  /** Describes if this shipping method is active and can be selected. */
  active: Scalars['Boolean'];
  /**
   * Shipping method description.
   *
   * Rich text format. For reference see https://editorjs.io/
   */
  description: Maybe<Scalars['JSONString']>;
  /** Unique ID of ShippingMethod available for Order. */
  id: Scalars['ID'];
  /** Maximum delivery days for this shipping method. */
  maximumDeliveryDays: Maybe<Scalars['Int']>;
  /** Maximum order price for this shipping method. */
  maximumOrderPrice: Maybe<Money>;
  /**
   * Maximum order weight for this shipping method.
   * @deprecated Field no longer supported
   */
  maximumOrderWeight: Maybe<Weight>;
  /** Message connected to this shipping method. */
  message: Maybe<Scalars['String']>;
  /** List of public metadata items. Can be accessed without permissions. */
  metadata: Array<MetadataItem>;
  /**
   * A single key from public metadata.
   *
   * Tip: Use GraphQL aliases to fetch multiple keys.
   */
  metafield: Maybe<Scalars['String']>;
  /** Public metadata. Use `keys` to control which fields you want to include. The default is to include everything. */
  metafields: Maybe<Scalars['Metadata']>;
  /** Minimum delivery days for this shipping method. */
  minimumDeliveryDays: Maybe<Scalars['Int']>;
  /** Minimal order price for this shipping method. */
  minimumOrderPrice: Maybe<Money>;
  /**
   * Minimum order weight for this shipping method.
   * @deprecated Field no longer supported
   */
  minimumOrderWeight: Maybe<Weight>;
  /** Shipping method name. */
  name: Scalars['String'];
  /** The price of selected shipping method. */
  price: Money;
  /** List of private metadata items. Requires staff permissions to access. */
  privateMetadata: Array<MetadataItem>;
  /**
   * A single key from private metadata. Requires staff permissions to access.
   *
   * Tip: Use GraphQL aliases to fetch multiple keys.
   */
  privateMetafield: Maybe<Scalars['String']>;
  /** Private metadata. Requires staff permissions to access. Use `keys` to control which fields you want to include. The default is to include everything. */
  privateMetafields: Maybe<Scalars['Metadata']>;
  /** Returns translated shipping method fields for the given language code. */
  translation: Maybe<ShippingMethodTranslation>;
  /**
   * Type of the shipping method.
   * @deprecated Field no longer supported
   */
  type: Maybe<ShippingMethodTypeEnum>;
};


/** Shipping methods that can be used as means of shipping for orders and checkouts. */
export type ShippingMethodMetafieldArgs = {
  key: Scalars['String'];
};


/** Shipping methods that can be used as means of shipping for orders and checkouts. */
export type ShippingMethodMetafieldsArgs = {
  keys: InputMaybe<Array<Scalars['String']>>;
};


/** Shipping methods that can be used as means of shipping for orders and checkouts. */
export type ShippingMethodPrivateMetafieldArgs = {
  key: Scalars['String'];
};


/** Shipping methods that can be used as means of shipping for orders and checkouts. */
export type ShippingMethodPrivateMetafieldsArgs = {
  keys: InputMaybe<Array<Scalars['String']>>;
};


/** Shipping methods that can be used as means of shipping for orders and checkouts. */
export type ShippingMethodTranslationArgs = {
  languageCode: LanguageCodeEnum;
};

/** Represents shipping method channel listing. */
export type ShippingMethodChannelListing = Node & {
  __typename: 'ShippingMethodChannelListing';
  /** The channel associated with the shipping method channel listing. */
  channel: Channel;
  /** The ID of shipping method channel listing. */
  id: Scalars['ID'];
  /** Maximum order price. */
  maximumOrderPrice: Maybe<Money>;
  /** Minimum order price. */
  minimumOrderPrice: Maybe<Money>;
  /** Price of the shipping method in the associated channel. */
  price: Maybe<Money>;
};

export type ShippingMethodChannelListingAddInput = {
  /** ID of a channel. */
  channelId: Scalars['ID'];
  /** Maximum order price to use this shipping method. */
  maximumOrderPrice: InputMaybe<Scalars['PositiveDecimal']>;
  /** Minimum order price to use this shipping method. */
  minimumOrderPrice: InputMaybe<Scalars['PositiveDecimal']>;
  /** Shipping price of the shipping method in this channel. */
  price: InputMaybe<Scalars['PositiveDecimal']>;
};

export type ShippingMethodChannelListingInput = {
  /** List of channels to which the shipping method should be assigned. */
  addChannels: InputMaybe<Array<ShippingMethodChannelListingAddInput>>;
  /** List of channels from which the shipping method should be unassigned. */
  removeChannels: InputMaybe<Array<Scalars['ID']>>;
};

/**
 * Manage shipping method's availability in channels.
 *
 * Requires one of the following permissions: MANAGE_SHIPPING.
 */
export type ShippingMethodChannelListingUpdate = {
  __typename: 'ShippingMethodChannelListingUpdate';
  errors: Array<ShippingError>;
  /** @deprecated Use `errors` field instead. */
  shippingErrors: Array<ShippingError>;
  /** An updated shipping method instance. */
  shippingMethod: Maybe<ShippingMethodType>;
};

/** Represents shipping method postal code rule. */
export type ShippingMethodPostalCodeRule = Node & {
  __typename: 'ShippingMethodPostalCodeRule';
  /** End address range. */
  end: Maybe<Scalars['String']>;
  /** The ID of the object. */
  id: Scalars['ID'];
  /** Inclusion type of the postal code rule. */
  inclusionType: Maybe<PostalCodeRuleInclusionTypeEnum>;
  /** Start address range. */
  start: Maybe<Scalars['String']>;
};

/** Represents shipping method's original translatable fields and related translations. */
export type ShippingMethodTranslatableContent = Node & {
  __typename: 'ShippingMethodTranslatableContent';
  /**
   * Shipping method description to translate.
   *
   * Rich text format. For reference see https://editorjs.io/
   */
  description: Maybe<Scalars['JSONString']>;
  /** The ID of the shipping method translatable content. */
  id: Scalars['ID'];
  /** Shipping method name to translate. */
  name: Scalars['String'];
  /**
   * Shipping method are the methods you'll use to get customer's orders  to them. They are directly exposed to the customers.
   *
   * Requires one of the following permissions: MANAGE_SHIPPING.
   * @deprecated Get model fields from the root level queries.
   */
  shippingMethod: Maybe<ShippingMethodType>;
  /** The ID of the shipping method to translate. */
  shippingMethodId: Scalars['ID'];
  /** Returns translated shipping method fields for the given language code. */
  translation: Maybe<ShippingMethodTranslation>;
};


/** Represents shipping method's original translatable fields and related translations. */
export type ShippingMethodTranslatableContentTranslationArgs = {
  languageCode: LanguageCodeEnum;
};

/** Represents shipping method translations. */
export type ShippingMethodTranslation = Node & {
  __typename: 'ShippingMethodTranslation';
  /**
   * Translated description of the shipping method.
   *
   * Rich text format. For reference see https://editorjs.io/
   */
  description: Maybe<Scalars['JSONString']>;
  /** The ID of the shipping method translation. */
  id: Scalars['ID'];
  /** Translation language. */
  language: LanguageDisplay;
  /** Translated shipping method name. */
  name: Maybe<Scalars['String']>;
  /** Represents the shipping method fields to translate. */
  translatableContent: Maybe<ShippingMethodTranslatableContent>;
};

/** Shipping method are the methods you'll use to get customer's orders to them. They are directly exposed to the customers. */
export type ShippingMethodType = Node & ObjectWithMetadata & {
  __typename: 'ShippingMethodType';
  /**
   * List of channels available for the method.
   *
   * Requires one of the following permissions: MANAGE_SHIPPING.
   */
  channelListings: Maybe<Array<ShippingMethodChannelListing>>;
  /**
   * Shipping method description.
   *
   * Rich text format. For reference see https://editorjs.io/
   */
  description: Maybe<Scalars['JSONString']>;
  /**
   * List of excluded products for the shipping method.
   *
   * Requires one of the following permissions: MANAGE_SHIPPING.
   */
  excludedProducts: Maybe<ProductCountableConnection>;
  /** Shipping method ID. */
  id: Scalars['ID'];
  /** Maximum number of days for delivery. */
  maximumDeliveryDays: Maybe<Scalars['Int']>;
  /** The price of the cheapest variant (including discounts). */
  maximumOrderPrice: Maybe<Money>;
  /** Maximum order weight to use this shipping method. */
  maximumOrderWeight: Maybe<Weight>;
  /** List of public metadata items. Can be accessed without permissions. */
  metadata: Array<MetadataItem>;
  /**
   * A single key from public metadata.
   *
   * Tip: Use GraphQL aliases to fetch multiple keys.
   */
  metafield: Maybe<Scalars['String']>;
  /** Public metadata. Use `keys` to control which fields you want to include. The default is to include everything. */
  metafields: Maybe<Scalars['Metadata']>;
  /** Minimal number of days for delivery. */
  minimumDeliveryDays: Maybe<Scalars['Int']>;
  /** The price of the cheapest variant (including discounts). */
  minimumOrderPrice: Maybe<Money>;
  /** Minimum order weight to use this shipping method. */
  minimumOrderWeight: Maybe<Weight>;
  /** Shipping method name. */
  name: Scalars['String'];
  /** Postal code ranges rule of exclusion or inclusion of the shipping method. */
  postalCodeRules: Maybe<Array<ShippingMethodPostalCodeRule>>;
  /** List of private metadata items. Requires staff permissions to access. */
  privateMetadata: Array<MetadataItem>;
  /**
   * A single key from private metadata. Requires staff permissions to access.
   *
   * Tip: Use GraphQL aliases to fetch multiple keys.
   */
  privateMetafield: Maybe<Scalars['String']>;
  /** Private metadata. Requires staff permissions to access. Use `keys` to control which fields you want to include. The default is to include everything. */
  privateMetafields: Maybe<Scalars['Metadata']>;
  /**
   * Tax class assigned to this shipping method.
   *
   * Requires one of the following permissions: AUTHENTICATED_STAFF_USER, AUTHENTICATED_APP.
   */
  taxClass: Maybe<TaxClass>;
  /** Returns translated shipping method fields for the given language code. */
  translation: Maybe<ShippingMethodTranslation>;
  /** Type of the shipping method. */
  type: Maybe<ShippingMethodTypeEnum>;
};


/** Shipping method are the methods you'll use to get customer's orders to them. They are directly exposed to the customers. */
export type ShippingMethodTypeExcludedProductsArgs = {
  after: InputMaybe<Scalars['String']>;
  before: InputMaybe<Scalars['String']>;
  first: InputMaybe<Scalars['Int']>;
  last: InputMaybe<Scalars['Int']>;
};


/** Shipping method are the methods you'll use to get customer's orders to them. They are directly exposed to the customers. */
export type ShippingMethodTypeMetafieldArgs = {
  key: Scalars['String'];
};


/** Shipping method are the methods you'll use to get customer's orders to them. They are directly exposed to the customers. */
export type ShippingMethodTypeMetafieldsArgs = {
  keys: InputMaybe<Array<Scalars['String']>>;
};


/** Shipping method are the methods you'll use to get customer's orders to them. They are directly exposed to the customers. */
export type ShippingMethodTypePrivateMetafieldArgs = {
  key: Scalars['String'];
};


/** Shipping method are the methods you'll use to get customer's orders to them. They are directly exposed to the customers. */
export type ShippingMethodTypePrivateMetafieldsArgs = {
  keys: InputMaybe<Array<Scalars['String']>>;
};


/** Shipping method are the methods you'll use to get customer's orders to them. They are directly exposed to the customers. */
export type ShippingMethodTypeTranslationArgs = {
  languageCode: LanguageCodeEnum;
};

export type ShippingMethodTypeEnum =
  | 'PRICE'
  | 'WEIGHT';

/** List of shipping methods available for the country. */
export type ShippingMethodsPerCountry = {
  __typename: 'ShippingMethodsPerCountry';
  /** The country code. */
  countryCode: CountryCode;
  /** List of available shipping methods. */
  shippingMethods: Maybe<Array<ShippingMethod>>;
};

export type ShippingPostalCodeRulesCreateInputRange = {
  /** End range of the postal code. */
  end: InputMaybe<Scalars['String']>;
  /** Start range of the postal code. */
  start: Scalars['String'];
};

/**
 * Deletes shipping prices.
 *
 * Requires one of the following permissions: MANAGE_SHIPPING.
 */
export type ShippingPriceBulkDelete = {
  __typename: 'ShippingPriceBulkDelete';
  /** Returns how many objects were affected. */
  count: Scalars['Int'];
  errors: Array<ShippingError>;
  /** @deprecated Use `errors` field instead. */
  shippingErrors: Array<ShippingError>;
};

/**
 * Creates a new shipping price.
 *
 * Requires one of the following permissions: MANAGE_SHIPPING.
 */
export type ShippingPriceCreate = {
  __typename: 'ShippingPriceCreate';
  errors: Array<ShippingError>;
  /** @deprecated Use `errors` field instead. */
  shippingErrors: Array<ShippingError>;
  shippingMethod: Maybe<ShippingMethodType>;
  /** A shipping zone to which the shipping method belongs. */
  shippingZone: Maybe<ShippingZone>;
};

/** Event sent when new shipping price is created. */
export type ShippingPriceCreated = Event & {
  __typename: 'ShippingPriceCreated';
  /** Time of the event. */
  issuedAt: Maybe<Scalars['DateTime']>;
  /** The user or application that triggered the event. */
  issuingPrincipal: Maybe<IssuingPrincipal>;
  /** The application receiving the webhook. */
  recipient: Maybe<App>;
  /** The shipping method the event relates to. */
  shippingMethod: Maybe<ShippingMethodType>;
  /** The shipping zone the shipping method belongs to. */
  shippingZone: Maybe<ShippingZone>;
  /** Saleor version that triggered the event. */
  version: Maybe<Scalars['String']>;
};


/** Event sent when new shipping price is created. */
export type ShippingPriceCreatedShippingMethodArgs = {
  channel: InputMaybe<Scalars['String']>;
};


/** Event sent when new shipping price is created. */
export type ShippingPriceCreatedShippingZoneArgs = {
  channel: InputMaybe<Scalars['String']>;
};

/**
 * Deletes a shipping price.
 *
 * Requires one of the following permissions: MANAGE_SHIPPING.
 */
export type ShippingPriceDelete = {
  __typename: 'ShippingPriceDelete';
  errors: Array<ShippingError>;
  /** @deprecated Use `errors` field instead. */
  shippingErrors: Array<ShippingError>;
  /** A shipping method to delete. */
  shippingMethod: Maybe<ShippingMethodType>;
  /** A shipping zone to which the shipping method belongs. */
  shippingZone: Maybe<ShippingZone>;
};

/** Event sent when shipping price is deleted. */
export type ShippingPriceDeleted = Event & {
  __typename: 'ShippingPriceDeleted';
  /** Time of the event. */
  issuedAt: Maybe<Scalars['DateTime']>;
  /** The user or application that triggered the event. */
  issuingPrincipal: Maybe<IssuingPrincipal>;
  /** The application receiving the webhook. */
  recipient: Maybe<App>;
  /** The shipping method the event relates to. */
  shippingMethod: Maybe<ShippingMethodType>;
  /** The shipping zone the shipping method belongs to. */
  shippingZone: Maybe<ShippingZone>;
  /** Saleor version that triggered the event. */
  version: Maybe<Scalars['String']>;
};


/** Event sent when shipping price is deleted. */
export type ShippingPriceDeletedShippingMethodArgs = {
  channel: InputMaybe<Scalars['String']>;
};


/** Event sent when shipping price is deleted. */
export type ShippingPriceDeletedShippingZoneArgs = {
  channel: InputMaybe<Scalars['String']>;
};

/**
 * Exclude products from shipping price.
 *
 * Requires one of the following permissions: MANAGE_SHIPPING.
 */
export type ShippingPriceExcludeProducts = {
  __typename: 'ShippingPriceExcludeProducts';
  errors: Array<ShippingError>;
  /** @deprecated Use `errors` field instead. */
  shippingErrors: Array<ShippingError>;
  /** A shipping method with new list of excluded products. */
  shippingMethod: Maybe<ShippingMethodType>;
};

export type ShippingPriceExcludeProductsInput = {
  /** List of products which will be excluded. */
  products: Array<Scalars['ID']>;
};

export type ShippingPriceInput = {
  /** Postal code rules to add. */
  addPostalCodeRules: InputMaybe<Array<ShippingPostalCodeRulesCreateInputRange>>;
  /** Postal code rules to delete. */
  deletePostalCodeRules: InputMaybe<Array<Scalars['ID']>>;
  /** Shipping method description. */
  description: InputMaybe<Scalars['JSONString']>;
  /** Inclusion type for currently assigned postal code rules. */
  inclusionType: InputMaybe<PostalCodeRuleInclusionTypeEnum>;
  /** Maximum number of days for delivery. */
  maximumDeliveryDays: InputMaybe<Scalars['Int']>;
  /** Maximum order weight to use this shipping method. */
  maximumOrderWeight: InputMaybe<Scalars['WeightScalar']>;
  /** Minimal number of days for delivery. */
  minimumDeliveryDays: InputMaybe<Scalars['Int']>;
  /** Minimum order weight to use this shipping method. */
  minimumOrderWeight: InputMaybe<Scalars['WeightScalar']>;
  /** Name of the shipping method. */
  name: InputMaybe<Scalars['String']>;
  /** Shipping zone this method belongs to. */
  shippingZone: InputMaybe<Scalars['ID']>;
  /** ID of a tax class to assign to this shipping method. If not provided, the default tax class will be used. */
  taxClass: InputMaybe<Scalars['ID']>;
  /** Shipping type: price or weight based. */
  type: InputMaybe<ShippingMethodTypeEnum>;
};

/**
 * Remove product from excluded list for shipping price.
 *
 * Requires one of the following permissions: MANAGE_SHIPPING.
 */
export type ShippingPriceRemoveProductFromExclude = {
  __typename: 'ShippingPriceRemoveProductFromExclude';
  errors: Array<ShippingError>;
  /** @deprecated Use `errors` field instead. */
  shippingErrors: Array<ShippingError>;
  /** A shipping method with new list of excluded products. */
  shippingMethod: Maybe<ShippingMethodType>;
};

/**
 * Creates/updates translations for a shipping method.
 *
 * Requires one of the following permissions: MANAGE_TRANSLATIONS.
 */
export type ShippingPriceTranslate = {
  __typename: 'ShippingPriceTranslate';
  errors: Array<TranslationError>;
  shippingMethod: Maybe<ShippingMethodType>;
  /** @deprecated Use `errors` field instead. */
  translationErrors: Array<TranslationError>;
};

export type ShippingPriceTranslationInput = {
  /**
   * Translated shipping method description.
   *
   * Rich text format. For reference see https://editorjs.io/
   */
  description: InputMaybe<Scalars['JSONString']>;
  name: InputMaybe<Scalars['String']>;
};

/**
 * Updates a new shipping price.
 *
 * Requires one of the following permissions: MANAGE_SHIPPING.
 */
export type ShippingPriceUpdate = {
  __typename: 'ShippingPriceUpdate';
  errors: Array<ShippingError>;
  /** @deprecated Use `errors` field instead. */
  shippingErrors: Array<ShippingError>;
  shippingMethod: Maybe<ShippingMethodType>;
  /** A shipping zone to which the shipping method belongs. */
  shippingZone: Maybe<ShippingZone>;
};

/** Event sent when shipping price is updated. */
export type ShippingPriceUpdated = Event & {
  __typename: 'ShippingPriceUpdated';
  /** Time of the event. */
  issuedAt: Maybe<Scalars['DateTime']>;
  /** The user or application that triggered the event. */
  issuingPrincipal: Maybe<IssuingPrincipal>;
  /** The application receiving the webhook. */
  recipient: Maybe<App>;
  /** The shipping method the event relates to. */
  shippingMethod: Maybe<ShippingMethodType>;
  /** The shipping zone the shipping method belongs to. */
  shippingZone: Maybe<ShippingZone>;
  /** Saleor version that triggered the event. */
  version: Maybe<Scalars['String']>;
};


/** Event sent when shipping price is updated. */
export type ShippingPriceUpdatedShippingMethodArgs = {
  channel: InputMaybe<Scalars['String']>;
};


/** Event sent when shipping price is updated. */
export type ShippingPriceUpdatedShippingZoneArgs = {
  channel: InputMaybe<Scalars['String']>;
};

/** Represents a shipping zone in the shop. Zones are the concept used only for grouping shipping methods in the dashboard, and are never exposed to the customers directly. */
export type ShippingZone = Node & ObjectWithMetadata & {
  __typename: 'ShippingZone';
  /** List of channels for shipping zone. */
  channels: Array<Channel>;
  /** List of countries available for the method. */
  countries: Array<CountryDisplay>;
  /** Indicates if the shipping zone is default one. */
  default: Scalars['Boolean'];
  /** Description of a shipping zone. */
  description: Maybe<Scalars['String']>;
  /** The ID of shipping zone. */
  id: Scalars['ID'];
  /** List of public metadata items. Can be accessed without permissions. */
  metadata: Array<MetadataItem>;
  /**
   * A single key from public metadata.
   *
   * Tip: Use GraphQL aliases to fetch multiple keys.
   */
  metafield: Maybe<Scalars['String']>;
  /** Public metadata. Use `keys` to control which fields you want to include. The default is to include everything. */
  metafields: Maybe<Scalars['Metadata']>;
  /** Shipping zone name. */
  name: Scalars['String'];
  /** Lowest and highest prices for the shipping. */
  priceRange: Maybe<MoneyRange>;
  /** List of private metadata items. Requires staff permissions to access. */
  privateMetadata: Array<MetadataItem>;
  /**
   * A single key from private metadata. Requires staff permissions to access.
   *
   * Tip: Use GraphQL aliases to fetch multiple keys.
   */
  privateMetafield: Maybe<Scalars['String']>;
  /** Private metadata. Requires staff permissions to access. Use `keys` to control which fields you want to include. The default is to include everything. */
  privateMetafields: Maybe<Scalars['Metadata']>;
  /** List of shipping methods available for orders shipped to countries within this shipping zone. */
  shippingMethods: Maybe<Array<ShippingMethodType>>;
  /** List of warehouses for shipping zone. */
  warehouses: Array<Warehouse>;
};


/** Represents a shipping zone in the shop. Zones are the concept used only for grouping shipping methods in the dashboard, and are never exposed to the customers directly. */
export type ShippingZoneMetafieldArgs = {
  key: Scalars['String'];
};


/** Represents a shipping zone in the shop. Zones are the concept used only for grouping shipping methods in the dashboard, and are never exposed to the customers directly. */
export type ShippingZoneMetafieldsArgs = {
  keys: InputMaybe<Array<Scalars['String']>>;
};


/** Represents a shipping zone in the shop. Zones are the concept used only for grouping shipping methods in the dashboard, and are never exposed to the customers directly. */
export type ShippingZonePrivateMetafieldArgs = {
  key: Scalars['String'];
};


/** Represents a shipping zone in the shop. Zones are the concept used only for grouping shipping methods in the dashboard, and are never exposed to the customers directly. */
export type ShippingZonePrivateMetafieldsArgs = {
  keys: InputMaybe<Array<Scalars['String']>>;
};

/**
 * Deletes shipping zones.
 *
 * Requires one of the following permissions: MANAGE_SHIPPING.
 */
export type ShippingZoneBulkDelete = {
  __typename: 'ShippingZoneBulkDelete';
  /** Returns how many objects were affected. */
  count: Scalars['Int'];
  errors: Array<ShippingError>;
  /** @deprecated Use `errors` field instead. */
  shippingErrors: Array<ShippingError>;
};

export type ShippingZoneCountableConnection = {
  __typename: 'ShippingZoneCountableConnection';
  edges: Array<ShippingZoneCountableEdge>;
  /** Pagination data for this connection. */
  pageInfo: PageInfo;
  /** A total count of items in the collection. */
  totalCount: Maybe<Scalars['Int']>;
};

export type ShippingZoneCountableEdge = {
  __typename: 'ShippingZoneCountableEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node: ShippingZone;
};

/**
 * Creates a new shipping zone.
 *
 * Requires one of the following permissions: MANAGE_SHIPPING.
 */
export type ShippingZoneCreate = {
  __typename: 'ShippingZoneCreate';
  errors: Array<ShippingError>;
  /** @deprecated Use `errors` field instead. */
  shippingErrors: Array<ShippingError>;
  shippingZone: Maybe<ShippingZone>;
};

export type ShippingZoneCreateInput = {
  /** List of channels to assign to the shipping zone. */
  addChannels: InputMaybe<Array<Scalars['ID']>>;
  /** List of warehouses to assign to a shipping zone */
  addWarehouses: InputMaybe<Array<Scalars['ID']>>;
  /** List of countries in this shipping zone. */
  countries: InputMaybe<Array<Scalars['String']>>;
  /** Default shipping zone will be used for countries not covered by other zones. */
  default: InputMaybe<Scalars['Boolean']>;
  /** Description of the shipping zone. */
  description: InputMaybe<Scalars['String']>;
  /** Shipping zone's name. Visible only to the staff. */
  name: InputMaybe<Scalars['String']>;
};

/** Event sent when new shipping zone is created. */
export type ShippingZoneCreated = Event & {
  __typename: 'ShippingZoneCreated';
  /** Time of the event. */
  issuedAt: Maybe<Scalars['DateTime']>;
  /** The user or application that triggered the event. */
  issuingPrincipal: Maybe<IssuingPrincipal>;
  /** The application receiving the webhook. */
  recipient: Maybe<App>;
  /** The shipping zone the event relates to. */
  shippingZone: Maybe<ShippingZone>;
  /** Saleor version that triggered the event. */
  version: Maybe<Scalars['String']>;
};


/** Event sent when new shipping zone is created. */
export type ShippingZoneCreatedShippingZoneArgs = {
  channel: InputMaybe<Scalars['String']>;
};

/**
 * Deletes a shipping zone.
 *
 * Requires one of the following permissions: MANAGE_SHIPPING.
 */
export type ShippingZoneDelete = {
  __typename: 'ShippingZoneDelete';
  errors: Array<ShippingError>;
  /** @deprecated Use `errors` field instead. */
  shippingErrors: Array<ShippingError>;
  shippingZone: Maybe<ShippingZone>;
};

/** Event sent when shipping zone is deleted. */
export type ShippingZoneDeleted = Event & {
  __typename: 'ShippingZoneDeleted';
  /** Time of the event. */
  issuedAt: Maybe<Scalars['DateTime']>;
  /** The user or application that triggered the event. */
  issuingPrincipal: Maybe<IssuingPrincipal>;
  /** The application receiving the webhook. */
  recipient: Maybe<App>;
  /** The shipping zone the event relates to. */
  shippingZone: Maybe<ShippingZone>;
  /** Saleor version that triggered the event. */
  version: Maybe<Scalars['String']>;
};


/** Event sent when shipping zone is deleted. */
export type ShippingZoneDeletedShippingZoneArgs = {
  channel: InputMaybe<Scalars['String']>;
};

export type ShippingZoneFilterInput = {
  channels: InputMaybe<Array<Scalars['ID']>>;
  search: InputMaybe<Scalars['String']>;
};

/** Event sent when shipping zone metadata is updated. */
export type ShippingZoneMetadataUpdated = Event & {
  __typename: 'ShippingZoneMetadataUpdated';
  /** Time of the event. */
  issuedAt: Maybe<Scalars['DateTime']>;
  /** The user or application that triggered the event. */
  issuingPrincipal: Maybe<IssuingPrincipal>;
  /** The application receiving the webhook. */
  recipient: Maybe<App>;
  /** The shipping zone the event relates to. */
  shippingZone: Maybe<ShippingZone>;
  /** Saleor version that triggered the event. */
  version: Maybe<Scalars['String']>;
};


/** Event sent when shipping zone metadata is updated. */
export type ShippingZoneMetadataUpdatedShippingZoneArgs = {
  channel: InputMaybe<Scalars['String']>;
};

/**
 * Updates a new shipping zone.
 *
 * Requires one of the following permissions: MANAGE_SHIPPING.
 */
export type ShippingZoneUpdate = {
  __typename: 'ShippingZoneUpdate';
  errors: Array<ShippingError>;
  /** @deprecated Use `errors` field instead. */
  shippingErrors: Array<ShippingError>;
  shippingZone: Maybe<ShippingZone>;
};

export type ShippingZoneUpdateInput = {
  /** List of channels to assign to the shipping zone. */
  addChannels: InputMaybe<Array<Scalars['ID']>>;
  /** List of warehouses to assign to a shipping zone */
  addWarehouses: InputMaybe<Array<Scalars['ID']>>;
  /** List of countries in this shipping zone. */
  countries: InputMaybe<Array<Scalars['String']>>;
  /** Default shipping zone will be used for countries not covered by other zones. */
  default: InputMaybe<Scalars['Boolean']>;
  /** Description of the shipping zone. */
  description: InputMaybe<Scalars['String']>;
  /** Shipping zone's name. Visible only to the staff. */
  name: InputMaybe<Scalars['String']>;
  /** List of channels to unassign from the shipping zone. */
  removeChannels: InputMaybe<Array<Scalars['ID']>>;
  /** List of warehouses to unassign from a shipping zone */
  removeWarehouses: InputMaybe<Array<Scalars['ID']>>;
};

/** Event sent when shipping zone is updated. */
export type ShippingZoneUpdated = Event & {
  __typename: 'ShippingZoneUpdated';
  /** Time of the event. */
  issuedAt: Maybe<Scalars['DateTime']>;
  /** The user or application that triggered the event. */
  issuingPrincipal: Maybe<IssuingPrincipal>;
  /** The application receiving the webhook. */
  recipient: Maybe<App>;
  /** The shipping zone the event relates to. */
  shippingZone: Maybe<ShippingZone>;
  /** Saleor version that triggered the event. */
  version: Maybe<Scalars['String']>;
};


/** Event sent when shipping zone is updated. */
export type ShippingZoneUpdatedShippingZoneArgs = {
  channel: InputMaybe<Scalars['String']>;
};

/** Represents a shop resource containing general shop data and configuration. */
export type Shop = ObjectWithMetadata & {
  __typename: 'Shop';
  /**
   * Determines if user can login without confirmation when `enableAccountConfirmation` is enabled.
   *
   * Requires one of the following permissions: MANAGE_SETTINGS.
   */
  allowLoginWithoutConfirmation: Maybe<Scalars['Boolean']>;
  /**
   * Enable automatic fulfillment for all digital products.
   *
   * Requires one of the following permissions: MANAGE_SETTINGS.
   */
  automaticFulfillmentDigitalProducts: Maybe<Scalars['Boolean']>;
  /** List of available external authentications. */
  availableExternalAuthentications: Array<ExternalAuthentication>;
  /** List of available payment gateways. */
  availablePaymentGateways: Array<PaymentGateway>;
  /** Shipping methods that are available for the shop. */
  availableShippingMethods: Maybe<Array<ShippingMethod>>;
  /**
   * List of tax apps that can be assigned to the channel. The list will be calculated by Saleor based on the apps that are subscribed to webhooks related to tax calculations: CHECKOUT_CALCULATE_TAXES
   *
   * Added in Saleor 3.19.
   *
   * Requires one of the following permissions: AUTHENTICATED_STAFF_USER, MANAGE_APPS.
   */
  availableTaxApps: Array<App>;
  /**
   * List of all currencies supported by shop's channels.
   *
   * Requires one of the following permissions: AUTHENTICATED_STAFF_USER, AUTHENTICATED_APP.
   */
  channelCurrencies: Array<Scalars['String']>;
  /**
   * Charge taxes on shipping.
   * @deprecated Use `ShippingMethodType.taxClass` to determine whether taxes are calculated for shipping methods; if a tax class is set, the taxes will be calculated, otherwise no tax rate will be applied.
   */
  chargeTaxesOnShipping: Scalars['Boolean'];
  /** Company address. */
  companyAddress: Maybe<Address>;
  /** List of countries available in the shop. */
  countries: Array<CountryDisplay>;
  /** URL of a view where customers can set their password. */
  customerSetPasswordUrl: Maybe<Scalars['String']>;
  /** Shop's default country. */
  defaultCountry: Maybe<CountryDisplay>;
  /**
   * Default number of max downloads per digital content URL.
   *
   * Requires one of the following permissions: MANAGE_SETTINGS.
   */
  defaultDigitalMaxDownloads: Maybe<Scalars['Int']>;
  /**
   * Default number of days which digital content URL will be valid.
   *
   * Requires one of the following permissions: MANAGE_SETTINGS.
   */
  defaultDigitalUrlValidDays: Maybe<Scalars['Int']>;
  /**
   * Default shop's email sender's address.
   *
   * Requires one of the following permissions: MANAGE_SETTINGS.
   */
  defaultMailSenderAddress: Maybe<Scalars['String']>;
  /**
   * Default shop's email sender's name.
   *
   * Requires one of the following permissions: MANAGE_SETTINGS.
   */
  defaultMailSenderName: Maybe<Scalars['String']>;
  /** Default weight unit. */
  defaultWeightUnit: Maybe<WeightUnitsEnum>;
  /** Shop's description. */
  description: Maybe<Scalars['String']>;
  /**
   * Display prices with tax in store.
   * @deprecated Use `Channel.taxConfiguration` to determine whether to display gross or net prices.
   */
  displayGrossPrices: Scalars['Boolean'];
  /** Shop's domain data. */
  domain: Domain;
  /**
   * Determines if account confirmation by email is enabled.
   *
   * Requires one of the following permissions: MANAGE_SETTINGS.
   */
  enableAccountConfirmationByEmail: Maybe<Scalars['Boolean']>;
  /** Allow to approve fulfillments which are unpaid. */
  fulfillmentAllowUnpaid: Scalars['Boolean'];
  /** Automatically approve all new fulfillments. */
  fulfillmentAutoApprove: Scalars['Boolean'];
  /** Header text. */
  headerText: Maybe<Scalars['String']>;
  /** ID of the shop. */
  id: Scalars['ID'];
  /**
   * Include taxes in prices.
   * @deprecated Use `Channel.taxConfiguration.pricesEnteredWithTax` to determine whether prices are entered with tax.
   */
  includeTaxesInPrices: Scalars['Boolean'];
  /** List of the shops's supported languages. */
  languages: Array<LanguageDisplay>;
  /**
   * Default number of maximum line quantity in single checkout (per single checkout line).
   *
   * Requires one of the following permissions: MANAGE_SETTINGS.
   */
  limitQuantityPerCheckout: Maybe<Scalars['Int']>;
  /**
   * Resource limitations and current usage if any set for a shop
   *
   * Requires one of the following permissions: AUTHENTICATED_STAFF_USER.
   * @deprecated Field no longer supported
   */
  limits: LimitInfo;
  /** List of public metadata items. Can be accessed without permissions. */
  metadata: Array<MetadataItem>;
  /**
   * A single key from public metadata.
   *
   * Tip: Use GraphQL aliases to fetch multiple keys.
   */
  metafield: Maybe<Scalars['String']>;
  /** Public metadata. Use `keys` to control which fields you want to include. The default is to include everything. */
  metafields: Maybe<Scalars['Metadata']>;
  /** Shop's name. */
  name: Scalars['String'];
  /** List of available permissions. */
  permissions: Array<Permission>;
  /** List of possible phone prefixes. */
  phonePrefixes: Array<Scalars['String']>;
  /**
   * When enabled, address fields that are not valid for a given country (according to Google's i18n address data) will be preserved instead of being removed during validation. Validation errors are still returned.
   *
   * Added in Saleor 3.22.
   *
   * Requires one of the following permissions: MANAGE_SETTINGS.
   */
  preserveAllAddressFields: Scalars['Boolean'];
  /** List of private metadata items. Requires staff permissions to access. */
  privateMetadata: Array<MetadataItem>;
  /**
   * A single key from private metadata. Requires staff permissions to access.
   *
   * Tip: Use GraphQL aliases to fetch multiple keys.
   */
  privateMetafield: Maybe<Scalars['String']>;
  /** Private metadata. Requires staff permissions to access. Use `keys` to control which fields you want to include. The default is to include everything. */
  privateMetafields: Maybe<Scalars['Metadata']>;
  /**
   * Default number of minutes stock will be reserved for anonymous checkout or null when stock reservation is disabled.
   *
   * Requires one of the following permissions: MANAGE_SETTINGS.
   */
  reserveStockDurationAnonymousUser: Maybe<Scalars['Int']>;
  /**
   * Default number of minutes stock will be reserved for authenticated checkout or null when stock reservation is disabled.
   *
   * Requires one of the following permissions: MANAGE_SETTINGS.
   */
  reserveStockDurationAuthenticatedUser: Maybe<Scalars['Int']>;
  /** Minor Saleor API version. */
  schemaVersion: Scalars['String'];
  /**
   * List of staff notification recipients.
   *
   * Requires one of the following permissions: MANAGE_SETTINGS.
   */
  staffNotificationRecipients: Maybe<Array<StaffNotificationRecipient>>;
  /** This field is used as a default value for `ProductVariant.trackInventory`. */
  trackInventoryByDefault: Maybe<Scalars['Boolean']>;
  /** Returns translated shop fields for the given language code. */
  translation: Maybe<ShopTranslation>;
  /**
   * Use legacy update webhook emission. When enabled, update webhooks (e.g. `customerUpdated`,`productVariantUpdated`) are sent even when only metadata changes. When disabled, update webhooks are not sent for metadata-only changes; only metadata-specific webhooks (e.g., `customerMetadataUpdated`, `productVariantMetadataUpdated`) are sent.
   *
   * Added in Saleor 3.22.
   * @deprecated Field no longer supported
   */
  useLegacyUpdateWebhookEmission: Maybe<Scalars['Boolean']>;
  /**
   * Saleor API version.
   *
   * Requires one of the following permissions: AUTHENTICATED_STAFF_USER, AUTHENTICATED_APP.
   */
  version: Scalars['String'];
};


/** Represents a shop resource containing general shop data and configuration. */
export type ShopAvailablePaymentGatewaysArgs = {
  channel: InputMaybe<Scalars['String']>;
  currency: InputMaybe<Scalars['String']>;
};


/** Represents a shop resource containing general shop data and configuration. */
export type ShopAvailableShippingMethodsArgs = {
  address: InputMaybe<AddressInput>;
  channel: Scalars['String'];
};


/** Represents a shop resource containing general shop data and configuration. */
export type ShopCountriesArgs = {
  filter: InputMaybe<CountryFilterInput>;
  languageCode: InputMaybe<LanguageCodeEnum>;
};


/** Represents a shop resource containing general shop data and configuration. */
export type ShopMetafieldArgs = {
  key: Scalars['String'];
};


/** Represents a shop resource containing general shop data and configuration. */
export type ShopMetafieldsArgs = {
  keys: InputMaybe<Array<Scalars['String']>>;
};


/** Represents a shop resource containing general shop data and configuration. */
export type ShopPrivateMetafieldArgs = {
  key: Scalars['String'];
};


/** Represents a shop resource containing general shop data and configuration. */
export type ShopPrivateMetafieldsArgs = {
  keys: InputMaybe<Array<Scalars['String']>>;
};


/** Represents a shop resource containing general shop data and configuration. */
export type ShopTranslationArgs = {
  languageCode: LanguageCodeEnum;
};

/**
 * Update the shop's address. If the `null` value is passed, the currently selected address will be deleted.
 *
 * Requires one of the following permissions: MANAGE_SETTINGS.
 */
export type ShopAddressUpdate = {
  __typename: 'ShopAddressUpdate';
  errors: Array<ShopError>;
  /** Updated shop. */
  shop: Maybe<Shop>;
  /** @deprecated Use `errors` field instead. */
  shopErrors: Array<ShopError>;
};

/**
 * Updates site domain of the shop.
 *
 * Requires one of the following permissions: MANAGE_SETTINGS.
 */
export type ShopDomainUpdate = {
  __typename: 'ShopDomainUpdate';
  errors: Array<ShopError>;
  /** Updated shop. */
  shop: Maybe<Shop>;
  /** @deprecated Use `errors` field instead. */
  shopErrors: Array<ShopError>;
};

export type ShopError = {
  __typename: 'ShopError';
  /** The error code. */
  code: ShopErrorCode;
  /** Name of a field that caused the error. A value of `null` indicates that the error isn't associated with a particular field. */
  field: Maybe<Scalars['String']>;
  /** The error message. */
  message: Maybe<Scalars['String']>;
};

export type ShopErrorCode =
  | 'ALREADY_EXISTS'
  | 'CANNOT_FETCH_TAX_RATES'
  | 'GRAPHQL_ERROR'
  | 'INVALID'
  | 'NOT_FOUND'
  | 'REQUIRED'
  | 'UNIQUE';

/**
 * Fetch tax rates.
 *
 * Requires one of the following permissions: MANAGE_SETTINGS.
 */
export type ShopFetchTaxRates = {
  __typename: 'ShopFetchTaxRates';
  errors: Array<ShopError>;
  /** Updated shop. */
  shop: Maybe<Shop>;
  /** @deprecated Use `errors` field instead. */
  shopErrors: Array<ShopError>;
};

/** Event sent when shop metadata is updated. */
export type ShopMetadataUpdated = Event & {
  __typename: 'ShopMetadataUpdated';
  /** Time of the event. */
  issuedAt: Maybe<Scalars['DateTime']>;
  /** The user or application that triggered the event. */
  issuingPrincipal: Maybe<IssuingPrincipal>;
  /** The application receiving the webhook. */
  recipient: Maybe<App>;
  /** Shop data. */
  shop: Maybe<Shop>;
  /** Saleor version that triggered the event. */
  version: Maybe<Scalars['String']>;
};

export type ShopSettingsInput = {
  /** Enable possibility to login without account confirmation. */
  allowLoginWithoutConfirmation: InputMaybe<Scalars['Boolean']>;
  /** Enable automatic fulfillment for all digital products. */
  automaticFulfillmentDigitalProducts: InputMaybe<Scalars['Boolean']>;
  /**
   * Charge taxes on shipping.
   * @deprecated To enable taxes for a shipping method, assign a tax class to the shipping method with `shippingPriceCreate` or `shippingPriceUpdate` mutations.
   */
  chargeTaxesOnShipping: InputMaybe<Scalars['Boolean']>;
  /** URL of a view where customers can set their password. */
  customerSetPasswordUrl: InputMaybe<Scalars['String']>;
  /** Default number of max downloads per digital content URL. */
  defaultDigitalMaxDownloads: InputMaybe<Scalars['Int']>;
  /** Default number of days which digital content URL will be valid. */
  defaultDigitalUrlValidDays: InputMaybe<Scalars['Int']>;
  /** Default email sender's address. */
  defaultMailSenderAddress: InputMaybe<Scalars['String']>;
  /** Default email sender's name. */
  defaultMailSenderName: InputMaybe<Scalars['String']>;
  /** Default weight unit. */
  defaultWeightUnit: InputMaybe<WeightUnitsEnum>;
  /** SEO description. */
  description: InputMaybe<Scalars['String']>;
  /**
   * Display prices with tax in store.
   * @deprecated Use `taxConfigurationUpdate` mutation to configure this setting per channel or country.
   */
  displayGrossPrices: InputMaybe<Scalars['Boolean']>;
  /** Enable automatic account confirmation by email. */
  enableAccountConfirmationByEmail: InputMaybe<Scalars['Boolean']>;
  /** Enable ability to approve fulfillments which are unpaid. */
  fulfillmentAllowUnpaid: InputMaybe<Scalars['Boolean']>;
  /** Enable automatic approval of all new fulfillments. */
  fulfillmentAutoApprove: InputMaybe<Scalars['Boolean']>;
  /** Header text. */
  headerText: InputMaybe<Scalars['String']>;
  /**
   * Include taxes in prices.
   * @deprecated Use `taxConfigurationUpdate` mutation to configure this setting per channel or country.
   */
  includeTaxesInPrices: InputMaybe<Scalars['Boolean']>;
  /** Default number of maximum line quantity in single checkout. Minimum possible value is 1, default value is 50. */
  limitQuantityPerCheckout: InputMaybe<Scalars['Int']>;
  /**
   * Shop public metadata. Can be read by any API client authorized to read the object it's attached to.
   *
   * Warning: never store sensitive information, including financial data such as credit card details.
   */
  metadata: InputMaybe<Array<MetadataInput>>;
  /**
   * When enabled, address fields that are not valid for a given country (according to Google's i18n address data) will be preserved instead of being removed during validation. Validation errors are still returned.
   *
   * Added in Saleor 3.22.
   */
  preserveAllAddressFields: InputMaybe<Scalars['Boolean']>;
  /**
   * Shop private metadata. Requires permissions to modify and to read the metadata of the object it's attached to.
   *
   * Warning: never store sensitive information, including financial data such as credit card details.
   */
  privateMetadata: InputMaybe<Array<MetadataInput>>;
  /** Default number of minutes stock will be reserved for anonymous checkout. Enter 0 or null to disable. */
  reserveStockDurationAnonymousUser: InputMaybe<Scalars['Int']>;
  /** Default number of minutes stock will be reserved for authenticated checkout. Enter 0 or null to disable. */
  reserveStockDurationAuthenticatedUser: InputMaybe<Scalars['Int']>;
  /** This field is used as a default value for `ProductVariant.trackInventory`. */
  trackInventoryByDefault: InputMaybe<Scalars['Boolean']>;
  /**
   * Use legacy update webhook emission. When enabled, update webhooks (e.g. `customerUpdated`,`productVariantUpdated`) are sent even when only metadata changes. When disabled, update webhooks are not sent for metadata-only changes; only metadata-specific webhooks (e.g., `customerMetadataUpdated`, `productVariantMetadataUpdated`) are sent.
   *
   * Added in Saleor 3.22.
   * @deprecated Field no longer supported
   */
  useLegacyUpdateWebhookEmission: InputMaybe<Scalars['Boolean']>;
};

/**
 * Creates/updates translations for shop settings.
 *
 * Requires one of the following permissions: MANAGE_TRANSLATIONS.
 */
export type ShopSettingsTranslate = {
  __typename: 'ShopSettingsTranslate';
  errors: Array<TranslationError>;
  /** Updated shop settings. */
  shop: Maybe<Shop>;
  /** @deprecated Use `errors` field instead. */
  translationErrors: Array<TranslationError>;
};

export type ShopSettingsTranslationInput = {
  description: InputMaybe<Scalars['String']>;
  headerText: InputMaybe<Scalars['String']>;
};

/**
 * Updates shop settings.
 *
 * Requires one of the following permissions: MANAGE_SETTINGS.
 *
 * Triggers the following webhook events:
 * - SHOP_METADATA_UPDATED (async): Optionally triggered when public or private metadata is updated.
 */
export type ShopSettingsUpdate = {
  __typename: 'ShopSettingsUpdate';
  errors: Array<ShopError>;
  /** Updated shop. */
  shop: Maybe<Shop>;
  /** @deprecated Use `errors` field instead. */
  shopErrors: Array<ShopError>;
};

/** Represents shop translations. */
export type ShopTranslation = Node & {
  __typename: 'ShopTranslation';
  /** Translated description of sale. */
  description: Scalars['String'];
  /** Translated header text of sale. */
  headerText: Scalars['String'];
  /** The ID of the shop translation. */
  id: Scalars['ID'];
  /** Translation language. */
  language: LanguageDisplay;
};

export type SiteDomainInput = {
  /** Domain name for shop. */
  domain: InputMaybe<Scalars['String']>;
  /** Shop site name. */
  name: InputMaybe<Scalars['String']>;
};

/**
 * Deletes staff users. Apps are not allowed to perform this mutation.
 *
 * Requires one of the following permissions: MANAGE_STAFF.
 *
 * Triggers the following webhook events:
 * - STAFF_DELETED (async): A staff account was deleted.
 */
export type StaffBulkDelete = {
  __typename: 'StaffBulkDelete';
  /** Returns how many objects were affected. */
  count: Scalars['Int'];
  errors: Array<StaffError>;
  /** @deprecated Use `errors` field instead. */
  staffErrors: Array<StaffError>;
};

/**
 * Creates a new staff user. Apps are not allowed to perform this mutation.
 *
 * Requires one of the following permissions: MANAGE_STAFF.
 *
 * Triggers the following webhook events:
 * - STAFF_CREATED (async): A new staff account was created.
 * - NOTIFY_USER (async): A notification for setting the password.
 * - STAFF_SET_PASSWORD_REQUESTED (async): Setting a new password for the staff account is requested.
 */
export type StaffCreate = {
  __typename: 'StaffCreate';
  errors: Array<StaffError>;
  /** @deprecated Use `errors` field instead. */
  staffErrors: Array<StaffError>;
  user: Maybe<User>;
};

/** Fields required to create a staff user. */
export type StaffCreateInput = {
  /** List of permission group IDs to which user should be assigned. */
  addGroups: InputMaybe<Array<Scalars['ID']>>;
  /** The unique email address of the user. */
  email: InputMaybe<Scalars['String']>;
  /** Given name. */
  firstName: InputMaybe<Scalars['String']>;
  /** User account is active. */
  isActive: InputMaybe<Scalars['Boolean']>;
  /** Family name. */
  lastName: InputMaybe<Scalars['String']>;
  /**
   * Fields required to update the user metadata. Can be read by any API client authorized to read the object it's attached to.
   *
   * Warning: never store sensitive information, including financial data such as credit card details.
   */
  metadata: InputMaybe<Array<MetadataInput>>;
  /** A note about the user. */
  note: InputMaybe<Scalars['String']>;
  /**
   * Fields required to update the user private metadata. Requires permissions to modify and to read the metadata of the object it's attached to.
   *
   * Warning: never store sensitive information, including financial data such as credit card details.
   */
  privateMetadata: InputMaybe<Array<MetadataInput>>;
  /** URL of a view where users should be redirected to set the password. URL in RFC 1808 format. */
  redirectUrl: InputMaybe<Scalars['String']>;
};

/** Event sent when new staff user is created. */
export type StaffCreated = Event & {
  __typename: 'StaffCreated';
  /** Time of the event. */
  issuedAt: Maybe<Scalars['DateTime']>;
  /** The user or application that triggered the event. */
  issuingPrincipal: Maybe<IssuingPrincipal>;
  /** The application receiving the webhook. */
  recipient: Maybe<App>;
  /** The user the event relates to. */
  user: Maybe<User>;
  /** Saleor version that triggered the event. */
  version: Maybe<Scalars['String']>;
};

/**
 * Deletes a staff user. Apps are not allowed to perform this mutation.
 *
 * Requires one of the following permissions: MANAGE_STAFF.
 *
 * Triggers the following webhook events:
 * - STAFF_DELETED (async): A staff account was deleted.
 */
export type StaffDelete = {
  __typename: 'StaffDelete';
  errors: Array<StaffError>;
  /** @deprecated Use `errors` field instead. */
  staffErrors: Array<StaffError>;
  user: Maybe<User>;
};

/** Event sent when staff user is deleted. */
export type StaffDeleted = Event & {
  __typename: 'StaffDeleted';
  /** Time of the event. */
  issuedAt: Maybe<Scalars['DateTime']>;
  /** The user or application that triggered the event. */
  issuingPrincipal: Maybe<IssuingPrincipal>;
  /** The application receiving the webhook. */
  recipient: Maybe<App>;
  /** The user the event relates to. */
  user: Maybe<User>;
  /** Saleor version that triggered the event. */
  version: Maybe<Scalars['String']>;
};

export type StaffError = {
  __typename: 'StaffError';
  /** A type of address that causes the error. */
  addressType: Maybe<AddressTypeEnum>;
  /** The error code. */
  code: AccountErrorCode;
  /** Name of a field that caused the error. A value of `null` indicates that the error isn't associated with a particular field. */
  field: Maybe<Scalars['String']>;
  /** List of permission group IDs which cause the error. */
  groups: Maybe<Array<Scalars['ID']>>;
  /** The error message. */
  message: Maybe<Scalars['String']>;
  /** List of permissions which causes the error. */
  permissions: Maybe<Array<PermissionEnum>>;
  /** List of user IDs which causes the error. */
  users: Maybe<Array<Scalars['ID']>>;
};

/** Represents status of a staff account. */
export type StaffMemberStatus =
  /** User account has been activated. */
  | 'ACTIVE'
  /** User account has not been activated yet. */
  | 'DEACTIVATED';

/** Represents a recipient of email notifications send by Saleor, such as notifications about new orders. Notifications can be assigned to staff users or arbitrary email addresses. */
export type StaffNotificationRecipient = Node & {
  __typename: 'StaffNotificationRecipient';
  /** Determines if a notification active. */
  active: Maybe<Scalars['Boolean']>;
  /** Returns email address of a user subscribed to email notifications. */
  email: Maybe<Scalars['String']>;
  /** The ID of the staff notification recipient. */
  id: Scalars['ID'];
  /** Returns a user subscribed to email notifications. */
  user: Maybe<User>;
};

/**
 * Creates a new staff notification recipient.
 *
 * Requires one of the following permissions: MANAGE_SETTINGS.
 */
export type StaffNotificationRecipientCreate = {
  __typename: 'StaffNotificationRecipientCreate';
  errors: Array<ShopError>;
  /** @deprecated Use `errors` field instead. */
  shopErrors: Array<ShopError>;
  staffNotificationRecipient: Maybe<StaffNotificationRecipient>;
};

/**
 * Deletes staff notification recipient.
 *
 * Requires one of the following permissions: MANAGE_SETTINGS.
 */
export type StaffNotificationRecipientDelete = {
  __typename: 'StaffNotificationRecipientDelete';
  errors: Array<ShopError>;
  /** @deprecated Use `errors` field instead. */
  shopErrors: Array<ShopError>;
  staffNotificationRecipient: Maybe<StaffNotificationRecipient>;
};

export type StaffNotificationRecipientInput = {
  /** Determines if a notification active. */
  active: InputMaybe<Scalars['Boolean']>;
  /** Email address of a user subscribed to email notifications. */
  email: InputMaybe<Scalars['String']>;
  /** The ID of the user subscribed to email notifications.. */
  user: InputMaybe<Scalars['ID']>;
};

/**
 * Updates a staff notification recipient.
 *
 * Requires one of the following permissions: MANAGE_SETTINGS.
 */
export type StaffNotificationRecipientUpdate = {
  __typename: 'StaffNotificationRecipientUpdate';
  errors: Array<ShopError>;
  /** @deprecated Use `errors` field instead. */
  shopErrors: Array<ShopError>;
  staffNotificationRecipient: Maybe<StaffNotificationRecipient>;
};

/** Event sent when setting a new password for staff is requested. */
export type StaffSetPasswordRequested = Event & {
  __typename: 'StaffSetPasswordRequested';
  /** The channel data. */
  channel: Maybe<Channel>;
  /** Time of the event. */
  issuedAt: Maybe<Scalars['DateTime']>;
  /** The user or application that triggered the event. */
  issuingPrincipal: Maybe<IssuingPrincipal>;
  /** The application receiving the webhook. */
  recipient: Maybe<App>;
  /** The URL to redirect the user after he accepts the request. */
  redirectUrl: Maybe<Scalars['String']>;
  /** Shop data. */
  shop: Maybe<Shop>;
  /** The token required to confirm request. */
  token: Maybe<Scalars['String']>;
  /** The user the event relates to. */
  user: Maybe<User>;
  /** Saleor version that triggered the event. */
  version: Maybe<Scalars['String']>;
};

/**
 * Updates an existing staff user. Apps are not allowed to perform this mutation.
 *
 * Requires one of the following permissions: MANAGE_STAFF.
 *
 * Triggers the following webhook events:
 * - STAFF_UPDATED (async): A staff account was updated.
 */
export type StaffUpdate = {
  __typename: 'StaffUpdate';
  errors: Array<StaffError>;
  /** @deprecated Use `errors` field instead. */
  staffErrors: Array<StaffError>;
  user: Maybe<User>;
};

/** Fields required to update a staff user. */
export type StaffUpdateInput = {
  /** List of permission group IDs to which user should be assigned. */
  addGroups: InputMaybe<Array<Scalars['ID']>>;
  /** The unique email address of the user. */
  email: InputMaybe<Scalars['String']>;
  /** Given name. */
  firstName: InputMaybe<Scalars['String']>;
  /** User account is active. */
  isActive: InputMaybe<Scalars['Boolean']>;
  /** Family name. */
  lastName: InputMaybe<Scalars['String']>;
  /**
   * Fields required to update the user metadata. Can be read by any API client authorized to read the object it's attached to.
   *
   * Warning: never store sensitive information, including financial data such as credit card details.
   */
  metadata: InputMaybe<Array<MetadataInput>>;
  /** A note about the user. */
  note: InputMaybe<Scalars['String']>;
  /**
   * Fields required to update the user private metadata. Requires permissions to modify and to read the metadata of the object it's attached to.
   *
   * Warning: never store sensitive information, including financial data such as credit card details.
   */
  privateMetadata: InputMaybe<Array<MetadataInput>>;
  /** List of permission group IDs from which user should be unassigned. */
  removeGroups: InputMaybe<Array<Scalars['ID']>>;
};

/** Event sent when staff user is updated. */
export type StaffUpdated = Event & {
  __typename: 'StaffUpdated';
  /** Time of the event. */
  issuedAt: Maybe<Scalars['DateTime']>;
  /** The user or application that triggered the event. */
  issuingPrincipal: Maybe<IssuingPrincipal>;
  /** The application receiving the webhook. */
  recipient: Maybe<App>;
  /** The user the event relates to. */
  user: Maybe<User>;
  /** Saleor version that triggered the event. */
  version: Maybe<Scalars['String']>;
};

export type StaffUserInput = {
  ids: InputMaybe<Array<Scalars['ID']>>;
  search: InputMaybe<Scalars['String']>;
  status: InputMaybe<StaffMemberStatus>;
};

/** Represents stock. */
export type Stock = Node & {
  __typename: 'Stock';
  /** The ID of stock. */
  id: Scalars['ID'];
  /** Information about the product variant. */
  productVariant: ProductVariant;
  /**
   * Quantity of a product in the warehouse's possession, including the allocated stock that is waiting for shipment.
   *
   * Requires one of the following permissions: MANAGE_PRODUCTS, MANAGE_ORDERS.
   */
  quantity: Scalars['Int'];
  /**
   * Quantity allocated for orders.
   *
   * Requires one of the following permissions: MANAGE_PRODUCTS, MANAGE_ORDERS.
   */
  quantityAllocated: Scalars['Int'];
  /**
   * Quantity reserved for checkouts.
   *
   * Requires one of the following permissions: MANAGE_PRODUCTS, MANAGE_ORDERS.
   */
  quantityReserved: Scalars['Int'];
  /** The warehouse associated with the stock. */
  warehouse: Warehouse;
};

export type StockAvailability =
  | 'IN_STOCK'
  | 'OUT_OF_STOCK';

export type StockBulkResult = {
  __typename: 'StockBulkResult';
  /** List of errors occurred on create or update attempt. */
  errors: Maybe<Array<StockBulkUpdateError>>;
  /** Stock data. */
  stock: Maybe<Stock>;
};

/**
 * Updates stocks for a given variant and warehouse. Variant and warehouse selectors have to be the same for all stock inputs. Is not allowed to use 'variantId' in one input and 'variantExternalReference' in another.
 *
 * Requires one of the following permissions: MANAGE_PRODUCTS.
 *
 * Triggers the following webhook events:
 * - PRODUCT_VARIANT_STOCK_UPDATED (async): A product variant stock details were updated.
 */
export type StockBulkUpdate = {
  __typename: 'StockBulkUpdate';
  /** Returns how many objects were updated. */
  count: Scalars['Int'];
  errors: Array<StockBulkUpdateError>;
  /** List of the updated stocks. */
  results: Array<StockBulkResult>;
};

export type StockBulkUpdateError = {
  __typename: 'StockBulkUpdateError';
  /** The error code. */
  code: StockBulkUpdateErrorCode;
  /** Name of a field that caused the error. A value of `null` indicates that the error isn't associated with a particular field. */
  field: Maybe<Scalars['String']>;
  /** The error message. */
  message: Maybe<Scalars['String']>;
};

export type StockBulkUpdateErrorCode =
  | 'GRAPHQL_ERROR'
  | 'INVALID'
  | 'NOT_FOUND'
  | 'REQUIRED';

export type StockBulkUpdateInput = {
  /** Quantity of items available for sell. */
  quantity: Scalars['Int'];
  /** Variant external reference. */
  variantExternalReference: InputMaybe<Scalars['String']>;
  /** Variant ID. */
  variantId: InputMaybe<Scalars['ID']>;
  /** Warehouse external reference. */
  warehouseExternalReference: InputMaybe<Scalars['String']>;
  /** Warehouse ID. */
  warehouseId: InputMaybe<Scalars['ID']>;
};

export type StockCountableConnection = {
  __typename: 'StockCountableConnection';
  edges: Array<StockCountableEdge>;
  /** Pagination data for this connection. */
  pageInfo: PageInfo;
  /** A total count of items in the collection. */
  totalCount: Maybe<Scalars['Int']>;
};

export type StockCountableEdge = {
  __typename: 'StockCountableEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node: Stock;
};

export type StockError = {
  __typename: 'StockError';
  /** The error code. */
  code: StockErrorCode;
  /** Name of a field that caused the error. A value of `null` indicates that the error isn't associated with a particular field. */
  field: Maybe<Scalars['String']>;
  /** The error message. */
  message: Maybe<Scalars['String']>;
};

export type StockErrorCode =
  | 'ALREADY_EXISTS'
  | 'GRAPHQL_ERROR'
  | 'INVALID'
  | 'NOT_FOUND'
  | 'REQUIRED'
  | 'UNIQUE';

export type StockFilterInput = {
  quantity: InputMaybe<Scalars['Float']>;
  search: InputMaybe<Scalars['String']>;
};

export type StockInput = {
  /** Quantity of items available for sell. */
  quantity: Scalars['Int'];
  /** Warehouse in which stock is located. */
  warehouse: Scalars['ID'];
};

/** Represents the channel stock settings. */
export type StockSettings = {
  __typename: 'StockSettings';
  /** Allocation strategy defines the preference of warehouses for allocations and reservations. */
  allocationStrategy: AllocationStrategyEnum;
};

export type StockSettingsInput = {
  /** Allocation strategy options. Strategy defines the preference of warehouses for allocations and reservations. */
  allocationStrategy: AllocationStrategyEnum;
};

export type StockUpdateInput = {
  /** Quantity of items available for sell. */
  quantity: Scalars['Int'];
  /** Stock. */
  stock: Scalars['ID'];
};

/**
 * Determine how stocks should be updated, while processing an order.
 *
 *     SKIP - stocks are not checked and not updated.
 *     UPDATE - only do update, if there is enough stock.
 *     FORCE - force update, if there is not enough stock.
 */
export type StockUpdatePolicyEnum =
  | 'FORCE'
  | 'SKIP'
  | 'UPDATE';

/** Enum representing the type of a payment storage in a gateway. */
export type StorePaymentMethodEnum =
  /** Storage is disabled. The payment is not stored. */
  | 'NONE'
  /** Off session storage type. The payment is stored to be reused even if the customer is absent. */
  | 'OFF_SESSION'
  /** On session storage type. The payment is stored only to be reused when the customer is present in the checkout flow. */
  | 'ON_SESSION';

/** Represents a payment method stored for user (tokenized) in payment gateway. */
export type StoredPaymentMethod = {
  __typename: 'StoredPaymentMethod';
  /** Stored credit card details if available. */
  creditCardInfo: Maybe<CreditCard>;
  /** JSON data returned by Payment Provider app for this payment method. */
  data: Maybe<Scalars['JSON']>;
  /** Payment gateway that stores this payment method. */
  gateway: PaymentGateway;
  /** Stored payment method ID. */
  id: Scalars['ID'];
  /** Payment method name. Example: last 4 digits of credit card, obfuscated email, etc. */
  name: Maybe<Scalars['String']>;
  /** ID of stored payment method used to make payment actions. Note: method ID is unique only within the payment gateway. */
  paymentMethodId: Scalars['String'];
  supportedPaymentFlows: Maybe<Array<TokenizedPaymentFlowEnum>>;
  /** Type of the payment method. Example: credit card, wallet, etc. */
  type: Scalars['String'];
};

/** Event sent when user requests to delete a payment method. */
export type StoredPaymentMethodDeleteRequested = Event & {
  __typename: 'StoredPaymentMethodDeleteRequested';
  /** Channel related to the requested delete action. */
  channel: Channel;
  /** Time of the event. */
  issuedAt: Maybe<Scalars['DateTime']>;
  /** The user or application that triggered the event. */
  issuingPrincipal: Maybe<IssuingPrincipal>;
  /** The ID of the payment method that should be deleted by the payment gateway. */
  paymentMethodId: Scalars['String'];
  /** The application receiving the webhook. */
  recipient: Maybe<App>;
  /** The user for which the app should proceed with payment method delete request. */
  user: User;
  /** Saleor version that triggered the event. */
  version: Maybe<Scalars['String']>;
};

/**
 * Request to delete a stored payment method on payment provider side.
 *
 * Requires one of the following permissions: AUTHENTICATED_USER.
 *
 * Triggers the following webhook events:
 * - STORED_PAYMENT_METHOD_DELETE_REQUESTED (sync): The customer requested to delete a payment method.
 */
export type StoredPaymentMethodRequestDelete = {
  __typename: 'StoredPaymentMethodRequestDelete';
  errors: Array<PaymentMethodRequestDeleteError>;
  /** The result of deleting a stored payment method. */
  result: StoredPaymentMethodRequestDeleteResult;
};

export type StoredPaymentMethodRequestDeleteErrorCode =
  | 'CHANNEL_INACTIVE'
  | 'GATEWAY_ERROR'
  | 'GRAPHQL_ERROR'
  | 'INVALID'
  | 'NOT_FOUND';

/**
 * Result of deleting a stored payment method.
 *
 *     This enum is used to determine the result of deleting a stored payment method.
 *     SUCCESSFULLY_DELETED - The stored payment method was successfully deleted.
 *     FAILED_TO_DELETE - The stored payment method was not deleted.
 *     FAILED_TO_DELIVER - The request to delete the stored payment method was not
 *     delivered.
 */
export type StoredPaymentMethodRequestDeleteResult =
  | 'FAILED_TO_DELETE'
  | 'FAILED_TO_DELIVER'
  | 'SUCCESSFULLY_DELETED';

/** Define the filtering options for string fields. */
export type StringFilterInput = {
  /** The value equal to. */
  eq: InputMaybe<Scalars['String']>;
  /** The value included in. */
  oneOf: InputMaybe<Array<Scalars['String']>>;
};

export type Subscription = {
  __typename: 'Subscription';
  /**
   * Event sent when new checkout is created.
   *
   * Added in Saleor 3.21.
   *
   * Note: this API is currently in Feature Preview and can be subject to changes at later point.
   */
  checkoutCreated: Maybe<CheckoutCreated>;
  /**
   * Event sent when checkout is fully authorized.
   *
   * Added in Saleor 3.21.
   *
   * Note: this API is currently in Feature Preview and can be subject to changes at later point.
   */
  checkoutFullyAuthorized: Maybe<CheckoutFullyAuthorized>;
  /**
   * Event sent when checkout is fully-paid.
   *
   * Added in Saleor 3.21.
   *
   * Note: this API is currently in Feature Preview and can be subject to changes at later point.
   */
  checkoutFullyPaid: Maybe<CheckoutFullyPaid>;
  /**
   * Event sent when checkout metadata is updated.
   *
   * Added in Saleor 3.21.
   *
   * Note: this API is currently in Feature Preview and can be subject to changes at later point.
   */
  checkoutMetadataUpdated: Maybe<CheckoutMetadataUpdated>;
  /**
   * Event sent when checkout is updated.
   *
   * Added in Saleor 3.21.
   *
   * Note: this API is currently in Feature Preview and can be subject to changes at later point.
   */
  checkoutUpdated: Maybe<CheckoutUpdated>;
  /**
   * Event sent when new draft order is created.
   *
   * Added in Saleor 3.20.
   *
   * Note: this API is currently in Feature Preview and can be subject to changes at later point.
   */
  draftOrderCreated: Maybe<DraftOrderCreated>;
  /**
   * Event sent when draft order is deleted.
   *
   * Added in Saleor 3.20.
   *
   * Note: this API is currently in Feature Preview and can be subject to changes at later point.
   */
  draftOrderDeleted: Maybe<DraftOrderDeleted>;
  /**
   * Event sent when draft order is updated.
   *
   * Added in Saleor 3.20.
   *
   * Note: this API is currently in Feature Preview and can be subject to changes at later point.
   */
  draftOrderUpdated: Maybe<DraftOrderUpdated>;
  /** Look up subscription event. */
  event: Maybe<Event>;
  /**
   * Event sent when orders are imported.
   *
   * Added in Saleor 3.20.
   *
   * Note: this API is currently in Feature Preview and can be subject to changes at later point.
   */
  orderBulkCreated: Maybe<OrderBulkCreated>;
  /**
   * Event sent when order is cancelled.
   *
   * Added in Saleor 3.20.
   *
   * Note: this API is currently in Feature Preview and can be subject to changes at later point.
   */
  orderCancelled: Maybe<OrderCancelled>;
  /**
   * Event sent when order is confirmed.
   *
   * Added in Saleor 3.20.
   *
   * Note: this API is currently in Feature Preview and can be subject to changes at later point.
   */
  orderConfirmed: Maybe<OrderConfirmed>;
  /**
   * Event sent when new order is created.
   *
   * Added in Saleor 3.20.
   *
   * Note: this API is currently in Feature Preview and can be subject to changes at later point.
   */
  orderCreated: Maybe<OrderCreated>;
  /**
   * Event sent when order becomes expired.
   *
   * Added in Saleor 3.20.
   *
   * Note: this API is currently in Feature Preview and can be subject to changes at later point.
   */
  orderExpired: Maybe<OrderExpired>;
  /**
   * Event sent when order is fulfilled.
   *
   * Added in Saleor 3.20.
   *
   * Note: this API is currently in Feature Preview and can be subject to changes at later point.
   */
  orderFulfilled: Maybe<OrderFulfilled>;
  /**
   * Event sent when order is fully paid.
   *
   * Added in Saleor 3.20.
   *
   * Note: this API is currently in Feature Preview and can be subject to changes at later point.
   */
  orderFullyPaid: Maybe<OrderFullyPaid>;
  /**
   * The order is fully refunded.
   *
   * Added in Saleor 3.20.
   *
   * Note: this API is currently in Feature Preview and can be subject to changes at later point.
   */
  orderFullyRefunded: Maybe<OrderFullyRefunded>;
  /**
   * Event sent when order metadata is updated.
   *
   * Added in Saleor 3.20.
   *
   * Note: this API is currently in Feature Preview and can be subject to changes at later point.
   */
  orderMetadataUpdated: Maybe<OrderMetadataUpdated>;
  /**
   * Payment has been made. The order may be partially or fully paid.
   *
   * Added in Saleor 3.20.
   *
   * Note: this API is currently in Feature Preview and can be subject to changes at later point.
   */
  orderPaid: Maybe<OrderPaid>;
  /**
   * The order received a refund. The order may be partially or fully refunded.
   *
   * Added in Saleor 3.20.
   *
   * Note: this API is currently in Feature Preview and can be subject to changes at later point.
   */
  orderRefunded: Maybe<OrderRefunded>;
  /**
   * Event sent when order is updated.
   *
   * Added in Saleor 3.20.
   *
   * Note: this API is currently in Feature Preview and can be subject to changes at later point.
   */
  orderUpdated: Maybe<OrderUpdated>;
};


export type SubscriptionCheckoutCreatedArgs = {
  channels: InputMaybe<Array<Scalars['String']>>;
};


export type SubscriptionCheckoutFullyAuthorizedArgs = {
  channels: InputMaybe<Array<Scalars['String']>>;
};


export type SubscriptionCheckoutFullyPaidArgs = {
  channels: InputMaybe<Array<Scalars['String']>>;
};


export type SubscriptionCheckoutMetadataUpdatedArgs = {
  channels: InputMaybe<Array<Scalars['String']>>;
};


export type SubscriptionCheckoutUpdatedArgs = {
  channels: InputMaybe<Array<Scalars['String']>>;
};


export type SubscriptionDraftOrderCreatedArgs = {
  channels: InputMaybe<Array<Scalars['String']>>;
};


export type SubscriptionDraftOrderDeletedArgs = {
  channels: InputMaybe<Array<Scalars['String']>>;
};


export type SubscriptionDraftOrderUpdatedArgs = {
  channels: InputMaybe<Array<Scalars['String']>>;
};


export type SubscriptionOrderBulkCreatedArgs = {
  channels: InputMaybe<Array<Scalars['String']>>;
};


export type SubscriptionOrderCancelledArgs = {
  channels: InputMaybe<Array<Scalars['String']>>;
};


export type SubscriptionOrderConfirmedArgs = {
  channels: InputMaybe<Array<Scalars['String']>>;
};


export type SubscriptionOrderCreatedArgs = {
  channels: InputMaybe<Array<Scalars['String']>>;
};


export type SubscriptionOrderExpiredArgs = {
  channels: InputMaybe<Array<Scalars['String']>>;
};


export type SubscriptionOrderFulfilledArgs = {
  channels: InputMaybe<Array<Scalars['String']>>;
};


export type SubscriptionOrderFullyPaidArgs = {
  channels: InputMaybe<Array<Scalars['String']>>;
};


export type SubscriptionOrderFullyRefundedArgs = {
  channels: InputMaybe<Array<Scalars['String']>>;
};


export type SubscriptionOrderMetadataUpdatedArgs = {
  channels: InputMaybe<Array<Scalars['String']>>;
};


export type SubscriptionOrderPaidArgs = {
  channels: InputMaybe<Array<Scalars['String']>>;
};


export type SubscriptionOrderRefundedArgs = {
  channels: InputMaybe<Array<Scalars['String']>>;
};


export type SubscriptionOrderUpdatedArgs = {
  channels: InputMaybe<Array<Scalars['String']>>;
};

export type TaxCalculationStrategy =
  | 'FLAT_RATES'
  | 'TAX_APP';

/** Tax class is a named object used to define tax rates per country. Tax class can be assigned to product types, products and shipping methods to define their tax rates. */
export type TaxClass = Node & ObjectWithMetadata & {
  __typename: 'TaxClass';
  /** Country-specific tax rates for this tax class. */
  countries: Array<TaxClassCountryRate>;
  /** The ID of the object. */
  id: Scalars['ID'];
  /** List of public metadata items. Can be accessed without permissions. */
  metadata: Array<MetadataItem>;
  /**
   * A single key from public metadata.
   *
   * Tip: Use GraphQL aliases to fetch multiple keys.
   */
  metafield: Maybe<Scalars['String']>;
  /** Public metadata. Use `keys` to control which fields you want to include. The default is to include everything. */
  metafields: Maybe<Scalars['Metadata']>;
  /** Name of the tax class. */
  name: Scalars['String'];
  /** List of private metadata items. Requires staff permissions to access. */
  privateMetadata: Array<MetadataItem>;
  /**
   * A single key from private metadata. Requires staff permissions to access.
   *
   * Tip: Use GraphQL aliases to fetch multiple keys.
   */
  privateMetafield: Maybe<Scalars['String']>;
  /** Private metadata. Requires staff permissions to access. Use `keys` to control which fields you want to include. The default is to include everything. */
  privateMetafields: Maybe<Scalars['Metadata']>;
};


/** Tax class is a named object used to define tax rates per country. Tax class can be assigned to product types, products and shipping methods to define their tax rates. */
export type TaxClassMetafieldArgs = {
  key: Scalars['String'];
};


/** Tax class is a named object used to define tax rates per country. Tax class can be assigned to product types, products and shipping methods to define their tax rates. */
export type TaxClassMetafieldsArgs = {
  keys: InputMaybe<Array<Scalars['String']>>;
};


/** Tax class is a named object used to define tax rates per country. Tax class can be assigned to product types, products and shipping methods to define their tax rates. */
export type TaxClassPrivateMetafieldArgs = {
  key: Scalars['String'];
};


/** Tax class is a named object used to define tax rates per country. Tax class can be assigned to product types, products and shipping methods to define their tax rates. */
export type TaxClassPrivateMetafieldsArgs = {
  keys: InputMaybe<Array<Scalars['String']>>;
};

export type TaxClassCountableConnection = {
  __typename: 'TaxClassCountableConnection';
  edges: Array<TaxClassCountableEdge>;
  /** Pagination data for this connection. */
  pageInfo: PageInfo;
  /** A total count of items in the collection. */
  totalCount: Maybe<Scalars['Int']>;
};

export type TaxClassCountableEdge = {
  __typename: 'TaxClassCountableEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node: TaxClass;
};

/** Tax rate for a country. When tax class is null, it represents the default tax rate for that country; otherwise it's a country tax rate specific to the given tax class. */
export type TaxClassCountryRate = {
  __typename: 'TaxClassCountryRate';
  /** Country in which this tax rate applies. */
  country: CountryDisplay;
  /** Tax rate value. */
  rate: Scalars['Float'];
  /** Related tax class. */
  taxClass: Maybe<TaxClass>;
};

/**
 * Creates a tax class.
 *
 * Requires one of the following permissions: MANAGE_TAXES.
 */
export type TaxClassCreate = {
  __typename: 'TaxClassCreate';
  errors: Array<TaxClassCreateError>;
  taxClass: Maybe<TaxClass>;
};

export type TaxClassCreateError = {
  __typename: 'TaxClassCreateError';
  /** The error code. */
  code: TaxClassCreateErrorCode;
  /** List of country codes for which the configuration is invalid. */
  countryCodes: Array<Scalars['String']>;
  /** Name of a field that caused the error. A value of `null` indicates that the error isn't associated with a particular field. */
  field: Maybe<Scalars['String']>;
  /** The error message. */
  message: Maybe<Scalars['String']>;
};

export type TaxClassCreateErrorCode =
  | 'GRAPHQL_ERROR'
  | 'INVALID'
  | 'NOT_FOUND';

export type TaxClassCreateInput = {
  /** List of country-specific tax rates to create for this tax class. */
  createCountryRates: InputMaybe<Array<CountryRateInput>>;
  /** Name of the tax class. */
  name: Scalars['String'];
};

/**
 * Deletes a tax class. After deleting the tax class any products, product types or shipping methods using it are updated to use the default tax class.
 *
 * Requires one of the following permissions: MANAGE_TAXES.
 */
export type TaxClassDelete = {
  __typename: 'TaxClassDelete';
  errors: Array<TaxClassDeleteError>;
  taxClass: Maybe<TaxClass>;
};

export type TaxClassDeleteError = {
  __typename: 'TaxClassDeleteError';
  /** The error code. */
  code: TaxClassDeleteErrorCode;
  /** Name of a field that caused the error. A value of `null` indicates that the error isn't associated with a particular field. */
  field: Maybe<Scalars['String']>;
  /** The error message. */
  message: Maybe<Scalars['String']>;
};

export type TaxClassDeleteErrorCode =
  | 'GRAPHQL_ERROR'
  | 'INVALID'
  | 'NOT_FOUND';

export type TaxClassFilterInput = {
  countries: InputMaybe<Array<CountryCode>>;
  ids: InputMaybe<Array<Scalars['ID']>>;
  metadata: InputMaybe<Array<MetadataFilter>>;
};

export type TaxClassRateInput = {
  /** Tax rate value. */
  rate: InputMaybe<Scalars['Float']>;
  /** ID of a tax class for which to update the tax rate */
  taxClassId: InputMaybe<Scalars['ID']>;
};

export type TaxClassSortField =
  /** Sort tax classes by name. */
  | 'NAME';

export type TaxClassSortingInput = {
  /** Specifies the direction in which to sort tax classes. */
  direction: OrderDirection;
  /** Sort tax classes by the selected field. */
  field: TaxClassSortField;
};

/**
 * Updates a tax class.
 *
 * Requires one of the following permissions: MANAGE_TAXES.
 */
export type TaxClassUpdate = {
  __typename: 'TaxClassUpdate';
  errors: Array<TaxClassUpdateError>;
  taxClass: Maybe<TaxClass>;
};

export type TaxClassUpdateError = {
  __typename: 'TaxClassUpdateError';
  /** The error code. */
  code: TaxClassUpdateErrorCode;
  /** List of country codes for which the configuration is invalid. */
  countryCodes: Array<Scalars['String']>;
  /** Name of a field that caused the error. A value of `null` indicates that the error isn't associated with a particular field. */
  field: Maybe<Scalars['String']>;
  /** The error message. */
  message: Maybe<Scalars['String']>;
};

export type TaxClassUpdateErrorCode =
  | 'DUPLICATED_INPUT_ITEM'
  | 'GRAPHQL_ERROR'
  | 'INVALID'
  | 'NOT_FOUND';

export type TaxClassUpdateInput = {
  /** Name of the tax class. */
  name: InputMaybe<Scalars['String']>;
  /** List of country codes for which to remove the tax class rates. Note: It removes all rates for given country code. */
  removeCountryRates: InputMaybe<Array<CountryCode>>;
  /** List of country-specific tax rates to create or update for this tax class. */
  updateCountryRates: InputMaybe<Array<CountryRateUpdateInput>>;
};

/** Channel-specific tax configuration. */
export type TaxConfiguration = Node & ObjectWithMetadata & {
  __typename: 'TaxConfiguration';
  /** A channel to which the tax configuration applies to. */
  channel: Channel;
  /** Determines whether taxes are charged in the given channel. */
  chargeTaxes: Scalars['Boolean'];
  /** List of country-specific exceptions in tax configuration. */
  countries: Array<TaxConfigurationPerCountry>;
  /** Determines whether displayed prices should include taxes. */
  displayGrossPrices: Scalars['Boolean'];
  /** The ID of the object. */
  id: Scalars['ID'];
  /** List of public metadata items. Can be accessed without permissions. */
  metadata: Array<MetadataItem>;
  /**
   * A single key from public metadata.
   *
   * Tip: Use GraphQL aliases to fetch multiple keys.
   */
  metafield: Maybe<Scalars['String']>;
  /** Public metadata. Use `keys` to control which fields you want to include. The default is to include everything. */
  metafields: Maybe<Scalars['Metadata']>;
  /** Determines whether prices are entered with the tax included. */
  pricesEnteredWithTax: Scalars['Boolean'];
  /** List of private metadata items. Requires staff permissions to access. */
  privateMetadata: Array<MetadataItem>;
  /**
   * A single key from private metadata. Requires staff permissions to access.
   *
   * Tip: Use GraphQL aliases to fetch multiple keys.
   */
  privateMetafield: Maybe<Scalars['String']>;
  /** Private metadata. Requires staff permissions to access. Use `keys` to control which fields you want to include. The default is to include everything. */
  privateMetafields: Maybe<Scalars['Metadata']>;
  /**
   * The tax app `App.identifier` that will be used to calculate the taxes for the given channel. Empty value for `TAX_APP` set as `taxCalculationStrategy` means that Saleor will iterate over all installed tax apps. If multiple tax apps exist with provided tax app id use the `App` with newest `created` date. Will become mandatory in 4.0 for `TAX_APP` `taxCalculationStrategy`.
   *
   * Added in Saleor 3.19.
   */
  taxAppId: Maybe<Scalars['String']>;
  /** The default strategy to use for tax calculation in the given channel. Taxes can be calculated either using user-defined flat rates or with a tax app. Empty value means that no method is selected and taxes are not calculated. */
  taxCalculationStrategy: Maybe<TaxCalculationStrategy>;
  /**
   * Determines whether to use weighted tax for shipping. When set to true, the tax rate for shipping will be calculated based on the weighted average of tax rates from the order or checkout lines.
   *
   * Added in Saleor 3.21.
   */
  useWeightedTaxForShipping: Maybe<Scalars['Boolean']>;
};


/** Channel-specific tax configuration. */
export type TaxConfigurationMetafieldArgs = {
  key: Scalars['String'];
};


/** Channel-specific tax configuration. */
export type TaxConfigurationMetafieldsArgs = {
  keys: InputMaybe<Array<Scalars['String']>>;
};


/** Channel-specific tax configuration. */
export type TaxConfigurationPrivateMetafieldArgs = {
  key: Scalars['String'];
};


/** Channel-specific tax configuration. */
export type TaxConfigurationPrivateMetafieldsArgs = {
  keys: InputMaybe<Array<Scalars['String']>>;
};

export type TaxConfigurationCountableConnection = {
  __typename: 'TaxConfigurationCountableConnection';
  edges: Array<TaxConfigurationCountableEdge>;
  /** Pagination data for this connection. */
  pageInfo: PageInfo;
  /** A total count of items in the collection. */
  totalCount: Maybe<Scalars['Int']>;
};

export type TaxConfigurationCountableEdge = {
  __typename: 'TaxConfigurationCountableEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node: TaxConfiguration;
};

export type TaxConfigurationFilterInput = {
  ids: InputMaybe<Array<Scalars['ID']>>;
  metadata: InputMaybe<Array<MetadataFilter>>;
};

/** Country-specific exceptions of a channel's tax configuration. */
export type TaxConfigurationPerCountry = {
  __typename: 'TaxConfigurationPerCountry';
  /** Determines whether taxes are charged in this country. */
  chargeTaxes: Scalars['Boolean'];
  /** Country in which this configuration applies. */
  country: CountryDisplay;
  /** Determines whether displayed prices should include taxes for this country. */
  displayGrossPrices: Scalars['Boolean'];
  /**
   * The tax app `App.identifier` that will be used to calculate the taxes for the given channel and country. If not provided, use the value from the channel's tax configuration.
   *
   * Added in Saleor 3.19.
   */
  taxAppId: Maybe<Scalars['String']>;
  /** A country-specific strategy to use for tax calculation. Taxes can be calculated either using user-defined flat rates or with a tax app. If not provided, use the value from the channel's tax configuration. */
  taxCalculationStrategy: Maybe<TaxCalculationStrategy>;
  /**
   * Determines whether to use weighted tax for shipping. When set to true, the tax rate for shipping will be calculated based on the weighted average of tax rates from the order or checkout lines.
   *
   * Added in Saleor 3.21.
   */
  useWeightedTaxForShipping: Maybe<Scalars['Boolean']>;
};

export type TaxConfigurationPerCountryInput = {
  /** Determines whether taxes are charged in this country. */
  chargeTaxes: Scalars['Boolean'];
  /** Country in which this configuration applies. */
  countryCode: CountryCode;
  /** Determines whether displayed prices should include taxes for this country. */
  displayGrossPrices: Scalars['Boolean'];
  /**
   * The tax app `App.identifier` that will be used to calculate the taxes for the given channel and country. If not provided, use the value from the channel's tax configuration.
   *
   * Added in Saleor 3.19.
   */
  taxAppId: InputMaybe<Scalars['String']>;
  /** A country-specific strategy to use for tax calculation. Taxes can be calculated either using user-defined flat rates or with a tax app. If not provided, use the value from the channel's tax configuration. */
  taxCalculationStrategy: InputMaybe<TaxCalculationStrategy>;
  /**
   * Determines whether to use weighted tax for shipping. When set to true, the tax rate for shipping will be calculated based on the weighted average of tax rates from the order or checkout lines. Default value is `False`.Can be used only with `taxCalculationStrategy` set to `FLAT_RATES`.
   *
   * Added in Saleor 3.21.
   */
  useWeightedTaxForShipping: InputMaybe<Scalars['Boolean']>;
};

/**
 * Updates tax configuration for a channel.
 *
 * Requires one of the following permissions: MANAGE_TAXES.
 */
export type TaxConfigurationUpdate = {
  __typename: 'TaxConfigurationUpdate';
  errors: Array<TaxConfigurationUpdateError>;
  taxConfiguration: Maybe<TaxConfiguration>;
};

export type TaxConfigurationUpdateError = {
  __typename: 'TaxConfigurationUpdateError';
  /** The error code. */
  code: TaxConfigurationUpdateErrorCode;
  /** List of country codes for which the configuration is invalid. */
  countryCodes: Array<Scalars['String']>;
  /** Name of a field that caused the error. A value of `null` indicates that the error isn't associated with a particular field. */
  field: Maybe<Scalars['String']>;
  /** The error message. */
  message: Maybe<Scalars['String']>;
};

export type TaxConfigurationUpdateErrorCode =
  | 'DUPLICATED_INPUT_ITEM'
  | 'GRAPHQL_ERROR'
  | 'INVALID'
  | 'NOT_FOUND';

export type TaxConfigurationUpdateInput = {
  /** Determines whether taxes are charged in the given channel. */
  chargeTaxes: InputMaybe<Scalars['Boolean']>;
  /** Determines whether displayed prices should include taxes. */
  displayGrossPrices: InputMaybe<Scalars['Boolean']>;
  /** Determines whether prices are entered with the tax included. */
  pricesEnteredWithTax: InputMaybe<Scalars['Boolean']>;
  /** List of country codes for which to remove the tax configuration. */
  removeCountriesConfiguration: InputMaybe<Array<CountryCode>>;
  /**
   * The tax app `App.identifier` that will be used to calculate the taxes for the given channel. Empty value for `TAX_APP` set as `taxCalculationStrategy` means that Saleor will iterate over all installed tax apps. If multiple tax apps exist with provided tax app id use the `App` with newest `created` date. It's possible to set plugin by using prefix `plugin:` with `PLUGIN_ID` e.g. with Avalara `plugin:mirumee.taxes.avalara`.Will become mandatory in 4.0 for `TAX_APP` `taxCalculationStrategy`.
   *
   * Added in Saleor 3.19.
   */
  taxAppId: InputMaybe<Scalars['String']>;
  /** The default strategy to use for tax calculation in the given channel. Taxes can be calculated either using user-defined flat rates or with a tax app. Empty value means that no method is selected and taxes are not calculated. */
  taxCalculationStrategy: InputMaybe<TaxCalculationStrategy>;
  /** List of tax country configurations to create or update (identified by a country code). */
  updateCountriesConfiguration: InputMaybe<Array<TaxConfigurationPerCountryInput>>;
  /**
   * Determines whether to use weighted tax for shipping. When set to true, the tax rate for shipping will be calculated based on the weighted average of tax rates from the order or checkout lines. Default value is `False`.Can be used only with `taxCalculationStrategy` set to `FLAT_RATES`.
   *
   * Added in Saleor 3.21.
   */
  useWeightedTaxForShipping: InputMaybe<Scalars['Boolean']>;
};

/** Tax class rates grouped by country. */
export type TaxCountryConfiguration = {
  __typename: 'TaxCountryConfiguration';
  /** A country for which tax class rates are grouped. */
  country: CountryDisplay;
  /** List of tax class rates. */
  taxClassCountryRates: Array<TaxClassCountryRate>;
};

/**
 * Remove all tax class rates for a specific country.
 *
 * Requires one of the following permissions: MANAGE_TAXES.
 */
export type TaxCountryConfigurationDelete = {
  __typename: 'TaxCountryConfigurationDelete';
  errors: Array<TaxCountryConfigurationDeleteError>;
  /** Updated tax class rates grouped by a country. */
  taxCountryConfiguration: Maybe<TaxCountryConfiguration>;
};

export type TaxCountryConfigurationDeleteError = {
  __typename: 'TaxCountryConfigurationDeleteError';
  /** The error code. */
  code: TaxCountryConfigurationDeleteErrorCode;
  /** Name of a field that caused the error. A value of `null` indicates that the error isn't associated with a particular field. */
  field: Maybe<Scalars['String']>;
  /** The error message. */
  message: Maybe<Scalars['String']>;
};

export type TaxCountryConfigurationDeleteErrorCode =
  | 'GRAPHQL_ERROR'
  | 'INVALID'
  | 'NOT_FOUND';

/**
 * Updates tax class rates for a specific country.
 *
 * Requires one of the following permissions: MANAGE_TAXES.
 */
export type TaxCountryConfigurationUpdate = {
  __typename: 'TaxCountryConfigurationUpdate';
  errors: Array<TaxCountryConfigurationUpdateError>;
  /** Updated tax class rates grouped by a country. */
  taxCountryConfiguration: Maybe<TaxCountryConfiguration>;
};

export type TaxCountryConfigurationUpdateError = {
  __typename: 'TaxCountryConfigurationUpdateError';
  /** The error code. */
  code: TaxCountryConfigurationUpdateErrorCode;
  /** Name of a field that caused the error. A value of `null` indicates that the error isn't associated with a particular field. */
  field: Maybe<Scalars['String']>;
  /** The error message. */
  message: Maybe<Scalars['String']>;
  /** List of tax class IDs for which the update failed. */
  taxClassIds: Array<Scalars['String']>;
};

export type TaxCountryConfigurationUpdateErrorCode =
  | 'CANNOT_CREATE_NEGATIVE_RATE'
  | 'GRAPHQL_ERROR'
  | 'INVALID'
  | 'NOT_FOUND'
  | 'ONLY_ONE_DEFAULT_COUNTRY_RATE_ALLOWED';

/**
 * Exempt checkout or order from charging the taxes. When tax exemption is enabled, taxes won't be charged for the checkout or order. Taxes may still be calculated in cases when product prices are entered with the tax included and the net price needs to be known.
 *
 * Requires one of the following permissions: MANAGE_TAXES.
 */
export type TaxExemptionManage = {
  __typename: 'TaxExemptionManage';
  errors: Array<TaxExemptionManageError>;
  taxableObject: Maybe<TaxSourceObject>;
};

export type TaxExemptionManageError = {
  __typename: 'TaxExemptionManageError';
  /** The error code. */
  code: TaxExemptionManageErrorCode;
  /** Name of a field that caused the error. A value of `null` indicates that the error isn't associated with a particular field. */
  field: Maybe<Scalars['String']>;
  /** The error message. */
  message: Maybe<Scalars['String']>;
};

export type TaxExemptionManageErrorCode =
  | 'GRAPHQL_ERROR'
  | 'INVALID'
  | 'NOT_EDITABLE_ORDER'
  | 'NOT_FOUND';

export type TaxSourceLine = CheckoutLine | OrderLine;

export type TaxSourceObject = Checkout | Order;

/** Representation of tax types fetched from tax gateway. */
export type TaxType = {
  __typename: 'TaxType';
  /** Description of the tax type. */
  description: Maybe<Scalars['String']>;
  /** External tax code used to identify given tax group. */
  taxCode: Maybe<Scalars['String']>;
};

/** Taxable object. */
export type TaxableObject = {
  __typename: 'TaxableObject';
  /** The address data. */
  address: Maybe<Address>;
  channel: Channel;
  /** The currency of the object. */
  currency: Scalars['String'];
  /** List of discounts. */
  discounts: Array<TaxableObjectDiscount>;
  /** List of lines assigned to the object. */
  lines: Array<TaxableObjectLine>;
  /** Determines if prices contain entered tax.. */
  pricesEnteredWithTax: Scalars['Boolean'];
  /** The price of shipping method, includes shipping voucher discount if applied. */
  shippingPrice: Money;
  /** The source object related to this tax object. */
  sourceObject: TaxSourceObject;
};

/** Taxable object discount. */
export type TaxableObjectDiscount = {
  __typename: 'TaxableObjectDiscount';
  /** The amount of the discount. */
  amount: Money;
  /** The name of the discount. */
  name: Maybe<Scalars['String']>;
  /** Indicates which part of the order the discount should affect: SUBTOTAL or SHIPPING. */
  type: TaxableObjectDiscountTypeEnum;
};

/** Indicates which part of the order the discount should affect: SUBTOTAL or SHIPPING. */
export type TaxableObjectDiscountTypeEnum =
  | 'SHIPPING'
  | 'SUBTOTAL';

export type TaxableObjectLine = {
  __typename: 'TaxableObjectLine';
  /** Determines if taxes are being charged for the product. */
  chargeTaxes: Scalars['Boolean'];
  /** The product name. */
  productName: Scalars['String'];
  /** The product sku. */
  productSku: Maybe<Scalars['String']>;
  /** Number of items. */
  quantity: Scalars['Int'];
  /** The source line related to this tax line. */
  sourceLine: TaxSourceLine;
  /** Price of the order line. The price includes catalogue promotions, specific product and applied once per order voucher discounts. The price does not include the entire order discount. */
  totalPrice: Money;
  /** Price of the single item in the order line. The price includes catalogue promotions, specific product and applied once per order voucher discounts. The price does not include the entire order discount. */
  unitPrice: Money;
  /** The variant name. */
  variantName: Scalars['String'];
};

/** Represents a monetary value with taxes. In cases where taxes were not applied, net and gross values will be equal. */
export type TaxedMoney = {
  __typename: 'TaxedMoney';
  /** Currency code. */
  currency: Scalars['String'];
  /** Amount of money including taxes. */
  gross: Money;
  /** Amount of money without taxes. */
  net: Money;
  /** Amount of taxes. */
  tax: Money;
};

export type TaxedMoneyInput = {
  /** Gross value of an item. */
  gross: Scalars['PositiveDecimal'];
  /** Net value of an item. */
  net: Scalars['PositiveDecimal'];
};

/** Represents a range of monetary values. */
export type TaxedMoneyRange = {
  __typename: 'TaxedMoneyRange';
  /** Lower bound of a price range. */
  start: Maybe<TaxedMoney>;
  /** Upper bound of a price range. */
  stop: Maybe<TaxedMoney>;
};

/** Event sent when thumbnail is created. */
export type ThumbnailCreated = Event & {
  __typename: 'ThumbnailCreated';
  /** Thumbnail id. */
  id: Maybe<Scalars['ID']>;
  /** Time of the event. */
  issuedAt: Maybe<Scalars['DateTime']>;
  /** The user or application that triggered the event. */
  issuingPrincipal: Maybe<IssuingPrincipal>;
  /** Original media url. */
  mediaUrl: Maybe<Scalars['String']>;
  /** Object the thumbnail refers to. */
  objectId: Maybe<Scalars['ID']>;
  /** The application receiving the webhook. */
  recipient: Maybe<App>;
  /** Thumbnail url. */
  url: Maybe<Scalars['String']>;
  /** Saleor version that triggered the event. */
  version: Maybe<Scalars['String']>;
};

export type ThumbnailFormatEnum =
  | 'AVIF'
  | 'ORIGINAL'
  | 'WEBP';

export type TimePeriod = {
  __typename: 'TimePeriod';
  /** The length of the period. */
  amount: Scalars['Int'];
  /** The type of the period. */
  type: TimePeriodTypeEnum;
};

export type TimePeriodInputType = {
  /** The length of the period. */
  amount: Scalars['Int'];
  /** The type of the period. */
  type: TimePeriodTypeEnum;
};

export type TimePeriodTypeEnum =
  | 'DAY'
  | 'MONTH'
  | 'WEEK'
  | 'YEAR';

/**
 * Represents possible tokenized payment flows that can be used to process payment.
 *
 *     The following flows are possible:
 *     INTERACTIVE - Payment method can be used for 1 click checkout - it's prefilled in
 *     checkout form (might require additional authentication from user)
 */
export type TokenizedPaymentFlowEnum =
  | 'INTERACTIVE';

/** An object representing a single payment. */
export type Transaction = Node & {
  __typename: 'Transaction';
  /** Total amount of the transaction. */
  amount: Maybe<Money>;
  /** Date and time at which transaction was created. */
  created: Scalars['DateTime'];
  /** Error associated with transaction, if any. */
  error: Maybe<Scalars['String']>;
  /**
   * Response returned by payment gateway.
   * @deprecated This field is a part of a legacy Payments API. Please use apps instead.
   */
  gatewayResponse: Scalars['JSONString'];
  /** ID of the transaction. */
  id: Scalars['ID'];
  /** Determines if the transaction was successful. */
  isSuccess: Scalars['Boolean'];
  /** Determines the type of transaction. */
  kind: TransactionKind;
  /** Determines the payment associated with a transaction. */
  payment: Payment;
  /** Unique token associated with a transaction. */
  token: Scalars['String'];
};

export type TransactionAction = {
  __typename: 'TransactionAction';
  /** Determines the action type. */
  actionType: TransactionActionEnum;
  /** Transaction request amount. */
  amount: Scalars['PositiveDecimal'];
  /** Currency code. */
  currency: Scalars['String'];
};

/**
 * Represents possible actions on payment transaction.
 *
 *     The following actions are possible:
 *     CHARGE - Represents the charge action.
 *     REFUND - Represents a refund action.
 *     CANCEL - Represents a cancel action. Added in Saleor 3.12.
 */
export type TransactionActionEnum =
  | 'CANCEL'
  | 'CHARGE'
  | 'REFUND';

/** Event sent when transaction cancelation is requested. */
export type TransactionCancelationRequested = Event & {
  __typename: 'TransactionCancelationRequested';
  /** Requested action data. */
  action: TransactionAction;
  /** Time of the event. */
  issuedAt: Maybe<Scalars['DateTime']>;
  /** The user or application that triggered the event. */
  issuingPrincipal: Maybe<IssuingPrincipal>;
  /** The application receiving the webhook. */
  recipient: Maybe<App>;
  /** Look up a transaction. */
  transaction: Maybe<TransactionItem>;
  /** Saleor version that triggered the event. */
  version: Maybe<Scalars['String']>;
};

/** Event sent when transaction charge is requested. */
export type TransactionChargeRequested = Event & {
  __typename: 'TransactionChargeRequested';
  /** Requested action data. */
  action: TransactionAction;
  /** Time of the event. */
  issuedAt: Maybe<Scalars['DateTime']>;
  /** The user or application that triggered the event. */
  issuingPrincipal: Maybe<IssuingPrincipal>;
  /** The application receiving the webhook. */
  recipient: Maybe<App>;
  /** Look up a transaction. */
  transaction: Maybe<TransactionItem>;
  /** Saleor version that triggered the event. */
  version: Maybe<Scalars['String']>;
};

export type TransactionCountableConnection = {
  __typename: 'TransactionCountableConnection';
  edges: Array<TransactionCountableEdge>;
  /** Pagination data for this connection. */
  pageInfo: PageInfo;
  /** A total count of items in the collection. */
  totalCount: Maybe<Scalars['Int']>;
};

export type TransactionCountableEdge = {
  __typename: 'TransactionCountableEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node: TransactionItem;
};

/**
 * Creates transaction for checkout or order.
 *
 * Requires one of the following permissions: HANDLE_PAYMENTS.
 */
export type TransactionCreate = {
  __typename: 'TransactionCreate';
  errors: Array<TransactionCreateError>;
  transaction: Maybe<TransactionItem>;
};

export type TransactionCreateError = {
  __typename: 'TransactionCreateError';
  /** The error code. */
  code: TransactionCreateErrorCode;
  /** Name of a field that caused the error. A value of `null` indicates that the error isn't associated with a particular field. */
  field: Maybe<Scalars['String']>;
  /** The error message. */
  message: Maybe<Scalars['String']>;
};

export type TransactionCreateErrorCode =
  | 'GRAPHQL_ERROR'
  | 'INCORRECT_CURRENCY'
  | 'INVALID'
  | 'METADATA_KEY_REQUIRED'
  | 'NOT_FOUND'
  | 'UNIQUE';

export type TransactionCreateInput = {
  /** Amount authorized by this transaction. */
  amountAuthorized: InputMaybe<MoneyInput>;
  /** Amount canceled by this transaction. */
  amountCanceled: InputMaybe<MoneyInput>;
  /** Amount charged by this transaction. */
  amountCharged: InputMaybe<MoneyInput>;
  /** Amount refunded by this transaction. */
  amountRefunded: InputMaybe<MoneyInput>;
  /** List of all possible actions for the transaction */
  availableActions: InputMaybe<Array<TransactionActionEnum>>;
  /** The url that will allow to redirect user to payment provider page with transaction event details. */
  externalUrl: InputMaybe<Scalars['String']>;
  /** The message of the transaction. */
  message: InputMaybe<Scalars['String']>;
  /**
   * Payment public metadata. Can be read by any API client authorized to read the object it's attached to.
   *
   * Warning: never store sensitive information, including financial data such as credit card details.
   */
  metadata: InputMaybe<Array<MetadataInput>>;
  /** Payment name of the transaction. */
  name: InputMaybe<Scalars['String']>;
  /**
   * Details of the payment method used for the transaction.
   *
   * Added in Saleor 3.22.
   */
  paymentMethodDetails: InputMaybe<PaymentMethodDetailsInput>;
  /**
   * Payment private metadata. Requires permissions to modify and to read the metadata of the object it's attached to.
   *
   * Warning: never store sensitive information, including financial data such as credit card details.
   */
  privateMetadata: InputMaybe<Array<MetadataInput>>;
  /** PSP Reference of the transaction. */
  pspReference: InputMaybe<Scalars['String']>;
};

/** Represents transaction's event. */
export type TransactionEvent = Node & {
  __typename: 'TransactionEvent';
  /** The amount related to this event. */
  amount: Money;
  /** Date and time at which a transaction event was created. */
  createdAt: Scalars['DateTime'];
  /** User or App that created the transaction event. */
  createdBy: Maybe<UserOrApp>;
  /** The url that will allow to redirect user to payment provider page with transaction details. */
  externalUrl: Scalars['String'];
  /** The ID of the object. */
  id: Scalars['ID'];
  /** Idempotency key assigned to the event. */
  idempotencyKey: Maybe<Scalars['String']>;
  /** Message related to the transaction's event. */
  message: Scalars['String'];
  /** PSP reference of transaction. */
  pspReference: Scalars['String'];
  /**
   * Reason model of the transaction refund.
   *
   * Added in Saleor 3.22.
   */
  reasonReference: Maybe<Page>;
  /** The type of action related to this event. */
  type: Maybe<TransactionEventTypeEnum>;
};

export type TransactionEventInput = {
  /** The message related to the event. */
  message: InputMaybe<Scalars['String']>;
  /** PSP Reference related to this action. */
  pspReference: InputMaybe<Scalars['String']>;
};

/**
 * Report the event for the transaction.
 *
 * Requires the following permissions: OWNER and HANDLE_PAYMENTS for apps, HANDLE_PAYMENTS for staff users. Staff user cannot update a transaction that is owned by the app.
 *
 * Triggers the following webhook events:
 * - TRANSACTION_ITEM_METADATA_UPDATED (async): Optionally called when transaction's metadata was updated.
 * - CHECKOUT_FULLY_PAID (async): Optionally called when the checkout charge status changed to `FULL` or `OVERCHARGED`.
 * - ORDER_UPDATED (async): Optionally called when the transaction is related to the order and the order was updated.
 */
export type TransactionEventReport = {
  __typename: 'TransactionEventReport';
  /** Defines if the reported event hasn't been processed earlier. */
  alreadyProcessed: Maybe<Scalars['Boolean']>;
  errors: Array<TransactionEventReportError>;
  /** The transaction related to the reported event. */
  transaction: Maybe<TransactionItem>;
  /** The event assigned to this report. if `alreadyProcessed` is set to `true`, the previously processed event will be returned. */
  transactionEvent: Maybe<TransactionEvent>;
};

export type TransactionEventReportError = {
  __typename: 'TransactionEventReportError';
  /** The error code. */
  code: TransactionEventReportErrorCode;
  /** Name of a field that caused the error. A value of `null` indicates that the error isn't associated with a particular field. */
  field: Maybe<Scalars['String']>;
  /** The error message. */
  message: Maybe<Scalars['String']>;
};

export type TransactionEventReportErrorCode =
  | 'ALREADY_EXISTS'
  | 'GRAPHQL_ERROR'
  | 'INCORRECT_DETAILS'
  | 'INVALID'
  | 'NOT_FOUND'
  | 'REQUIRED';

/**
 * Represents possible event types.
 *
 *     Added in Saleor 3.12.
 *
 *     The following types are possible:
 *     AUTHORIZATION_SUCCESS - represents success authorization.
 *     AUTHORIZATION_FAILURE - represents failure authorization.
 *     AUTHORIZATION_ADJUSTMENT - represents authorization adjustment.
 *     AUTHORIZATION_REQUEST - represents authorization request.
 *     AUTHORIZATION_ACTION_REQUIRED - represents authorization that needs
 *     additional actions from the customer.
 *     CHARGE_ACTION_REQUIRED - represents charge that needs
 *     additional actions from the customer.
 *     CHARGE_SUCCESS - represents success charge.
 *     CHARGE_FAILURE - represents failure charge.
 *     CHARGE_BACK - represents chargeback.
 *     CHARGE_REQUEST - represents charge request.
 *     REFUND_SUCCESS - represents success refund.
 *     REFUND_FAILURE - represents failure refund.
 *     REFUND_REVERSE - represents reverse refund.
 *     REFUND_REQUEST - represents refund request.
 *     CANCEL_SUCCESS - represents success cancel.
 *     CANCEL_FAILURE - represents failure cancel.
 *     CANCEL_REQUEST - represents cancel request.
 *     INFO - represents info event.
 */
export type TransactionEventTypeEnum =
  | 'AUTHORIZATION_ACTION_REQUIRED'
  | 'AUTHORIZATION_ADJUSTMENT'
  | 'AUTHORIZATION_FAILURE'
  | 'AUTHORIZATION_REQUEST'
  | 'AUTHORIZATION_SUCCESS'
  | 'CANCEL_FAILURE'
  | 'CANCEL_REQUEST'
  | 'CANCEL_SUCCESS'
  | 'CHARGE_ACTION_REQUIRED'
  | 'CHARGE_BACK'
  | 'CHARGE_FAILURE'
  | 'CHARGE_REQUEST'
  | 'CHARGE_SUCCESS'
  | 'INFO'
  | 'REFUND_FAILURE'
  | 'REFUND_REQUEST'
  | 'REFUND_REVERSE'
  | 'REFUND_SUCCESS';

/** Filter input for transactions. */
export type TransactionFilterInput = {
  /** Filter by metadata fields of transactions. */
  metadata: InputMaybe<MetadataFilterInput>;
  /** Filter by payment method details used to pay for the order. */
  paymentMethodDetails: InputMaybe<PaymentMethodDetailsFilterInput>;
  /**
   * Filter by PSP reference of transactions.
   *
   * Added in Saleor 3.22.
   */
  pspReference: InputMaybe<StringFilterInput>;
};

/**
 * Determine the transaction flow strategy.
 *
 *     AUTHORIZATION - the processed transaction should be only authorized
 *     CHARGE - the processed transaction should be charged.
 */
export type TransactionFlowStrategyEnum =
  | 'AUTHORIZATION'
  | 'CHARGE';

/** Initializes a transaction session. It triggers the webhook `TRANSACTION_INITIALIZE_SESSION`, to the requested `paymentGateways`. There is a limit of 100 transaction items per checkout / order. */
export type TransactionInitialize = {
  __typename: 'TransactionInitialize';
  /** The JSON data required to finalize the payment. */
  data: Maybe<Scalars['JSON']>;
  errors: Array<TransactionInitializeError>;
  /** The initialized transaction. */
  transaction: Maybe<TransactionItem>;
  /** The event created for the initialized transaction. */
  transactionEvent: Maybe<TransactionEvent>;
};

export type TransactionInitializeError = {
  __typename: 'TransactionInitializeError';
  /** The error code. */
  code: TransactionInitializeErrorCode;
  /** Name of a field that caused the error. A value of `null` indicates that the error isn't associated with a particular field. */
  field: Maybe<Scalars['String']>;
  /** The error message. */
  message: Maybe<Scalars['String']>;
};

export type TransactionInitializeErrorCode =
  | 'CHECKOUT_COMPLETION_IN_PROGRESS'
  | 'GRAPHQL_ERROR'
  | 'INVALID'
  | 'NOT_FOUND'
  | 'UNIQUE';

/** Event sent when user starts processing the payment. */
export type TransactionInitializeSession = Event & {
  __typename: 'TransactionInitializeSession';
  /** Action to proceed for the transaction */
  action: TransactionProcessAction;
  /** The customer's IP address. If not provided as a parameter in the mutation, Saleor will try to determine the customer's IP address on its own. */
  customerIpAddress: Maybe<Scalars['String']>;
  /** Payment gateway data in JSON format, received from storefront. */
  data: Maybe<Scalars['JSON']>;
  /** Idempotency key assigned to the transaction initialize. */
  idempotencyKey: Scalars['String'];
  /** Time of the event. */
  issuedAt: Maybe<Scalars['DateTime']>;
  /** The user or application that triggered the event. */
  issuingPrincipal: Maybe<IssuingPrincipal>;
  /** Merchant reference assigned to this payment. */
  merchantReference: Scalars['String'];
  /** The application receiving the webhook. */
  recipient: Maybe<App>;
  /** Checkout or order */
  sourceObject: OrderOrCheckout;
  /** Look up a transaction. */
  transaction: TransactionItem;
  /** Saleor version that triggered the event. */
  version: Maybe<Scalars['String']>;
};

/** Represents a payment transaction. */
export type TransactionItem = Node & ObjectWithMetadata & {
  __typename: 'TransactionItem';
  /** List of actions that can be performed in the current state of a payment. */
  actions: Array<TransactionActionEnum>;
  /** Total amount of ongoing authorization requests for the transaction. */
  authorizePendingAmount: Money;
  /** Total amount authorized for this payment. */
  authorizedAmount: Money;
  /** Total amount of ongoing cancel requests for the transaction. */
  cancelPendingAmount: Money;
  /** Total amount canceled for this payment. */
  canceledAmount: Money;
  /** Total amount of ongoing charge requests for the transaction. */
  chargePendingAmount: Money;
  /** Total amount charged for this payment. */
  chargedAmount: Money;
  /** The related checkout. */
  checkout: Maybe<Checkout>;
  /** Date and time at which payment transaction was created. */
  createdAt: Scalars['DateTime'];
  /** User or App that created the transaction. */
  createdBy: Maybe<UserOrApp>;
  /** List of all transaction's events. */
  events: Array<TransactionEvent>;
  /** The url that will allow to redirect user to payment provider page with transaction details. */
  externalUrl: Scalars['String'];
  /** The ID of the object. */
  id: Scalars['ID'];
  /** Message related to the transaction. */
  message: Scalars['String'];
  /** List of public metadata items. Can be accessed without permissions. */
  metadata: Array<MetadataItem>;
  /**
   * A single key from public metadata.
   *
   * Tip: Use GraphQL aliases to fetch multiple keys.
   */
  metafield: Maybe<Scalars['String']>;
  /** Public metadata. Use `keys` to control which fields you want to include. The default is to include everything. */
  metafields: Maybe<Scalars['Metadata']>;
  /** Date and time at which payment transaction was modified. */
  modifiedAt: Scalars['DateTime'];
  /** Name of the transaction. */
  name: Scalars['String'];
  /** The related order. */
  order: Maybe<Order>;
  /**
   * The payment method used for this transaction.
   *
   * Added in Saleor 3.22.
   */
  paymentMethodDetails: Maybe<PaymentMethodDetails>;
  /** List of private metadata items. Requires staff permissions to access. */
  privateMetadata: Array<MetadataItem>;
  /**
   * A single key from private metadata. Requires staff permissions to access.
   *
   * Tip: Use GraphQL aliases to fetch multiple keys.
   */
  privateMetafield: Maybe<Scalars['String']>;
  /** Private metadata. Requires staff permissions to access. Use `keys` to control which fields you want to include. The default is to include everything. */
  privateMetafields: Maybe<Scalars['Metadata']>;
  /** PSP reference of transaction. */
  pspReference: Scalars['String'];
  /**
   * Reason of the refund.
   *
   * Added in Saleor 3.22.
   */
  reason: Maybe<Scalars['String']>;
  /**
   * Reason `Page` (Model) for refund.
   *
   * Added in Saleor 3.22.
   */
  reasonReference: Maybe<Page>;
  /** Total amount of ongoing refund requests for the transaction. */
  refundPendingAmount: Money;
  /** Total amount refunded for this payment. */
  refundedAmount: Money;
  /** The transaction token. */
  token: Scalars['UUID'];
};


/** Represents a payment transaction. */
export type TransactionItemMetafieldArgs = {
  key: Scalars['String'];
};


/** Represents a payment transaction. */
export type TransactionItemMetafieldsArgs = {
  keys: InputMaybe<Array<Scalars['String']>>;
};


/** Represents a payment transaction. */
export type TransactionItemPrivateMetafieldArgs = {
  key: Scalars['String'];
};


/** Represents a payment transaction. */
export type TransactionItemPrivateMetafieldsArgs = {
  keys: InputMaybe<Array<Scalars['String']>>;
};

/** Event sent when transaction item metadata is updated. */
export type TransactionItemMetadataUpdated = Event & {
  __typename: 'TransactionItemMetadataUpdated';
  /** Time of the event. */
  issuedAt: Maybe<Scalars['DateTime']>;
  /** The user or application that triggered the event. */
  issuingPrincipal: Maybe<IssuingPrincipal>;
  /** The application receiving the webhook. */
  recipient: Maybe<App>;
  /** Look up a transaction. */
  transaction: Maybe<TransactionItem>;
  /** Saleor version that triggered the event. */
  version: Maybe<Scalars['String']>;
};

export type TransactionKind =
  | 'ACTION_TO_CONFIRM'
  | 'AUTH'
  | 'CANCEL'
  | 'CAPTURE'
  | 'CONFIRM'
  | 'EXTERNAL'
  | 'PENDING'
  | 'REFUND'
  | 'REFUND_ONGOING'
  | 'VOID';

/** Processes a transaction session. It triggers the webhook `TRANSACTION_PROCESS_SESSION`, to the assigned `paymentGateways`. */
export type TransactionProcess = {
  __typename: 'TransactionProcess';
  /** The json data required to finalize the payment. */
  data: Maybe<Scalars['JSON']>;
  errors: Array<TransactionProcessError>;
  /** The processed transaction. */
  transaction: Maybe<TransactionItem>;
  /** The event created for the processed transaction. */
  transactionEvent: Maybe<TransactionEvent>;
};

export type TransactionProcessAction = {
  __typename: 'TransactionProcessAction';
  actionType: TransactionFlowStrategyEnum;
  /** Transaction amount to process. */
  amount: Scalars['PositiveDecimal'];
  /** Currency of the amount. */
  currency: Scalars['String'];
};

export type TransactionProcessError = {
  __typename: 'TransactionProcessError';
  /** The error code. */
  code: TransactionProcessErrorCode;
  /** Name of a field that caused the error. A value of `null` indicates that the error isn't associated with a particular field. */
  field: Maybe<Scalars['String']>;
  /** The error message. */
  message: Maybe<Scalars['String']>;
};

export type TransactionProcessErrorCode =
  | 'CHECKOUT_COMPLETION_IN_PROGRESS'
  | 'GRAPHQL_ERROR'
  | 'INVALID'
  | 'MISSING_PAYMENT_APP'
  | 'MISSING_PAYMENT_APP_RELATION'
  | 'NOT_FOUND'
  | 'TRANSACTION_ALREADY_PROCESSED';

/** Event sent when user has additional payment action to process. */
export type TransactionProcessSession = Event & {
  __typename: 'TransactionProcessSession';
  /** Action to proceed for the transaction */
  action: TransactionProcessAction;
  /** The customer's IP address. If not provided as a parameter in the mutation, Saleor will try to determine the customer's IP address on its own. */
  customerIpAddress: Maybe<Scalars['String']>;
  /** Payment gateway data in JSON format, received from storefront. */
  data: Maybe<Scalars['JSON']>;
  /** Time of the event. */
  issuedAt: Maybe<Scalars['DateTime']>;
  /** The user or application that triggered the event. */
  issuingPrincipal: Maybe<IssuingPrincipal>;
  /** Merchant reference assigned to this payment. */
  merchantReference: Scalars['String'];
  /** The application receiving the webhook. */
  recipient: Maybe<App>;
  /** Checkout or order */
  sourceObject: OrderOrCheckout;
  /** Look up a transaction. */
  transaction: TransactionItem;
  /** Saleor version that triggered the event. */
  version: Maybe<Scalars['String']>;
};

/** Event sent when transaction refund is requested. */
export type TransactionRefundRequested = Event & {
  __typename: 'TransactionRefundRequested';
  /** Requested action data. */
  action: TransactionAction;
  /**
   * Granted refund related to refund request.
   *
   * Note: this API is currently in Feature Preview and can be subject to changes at later point.
   */
  grantedRefund: Maybe<OrderGrantedRefund>;
  /** Time of the event. */
  issuedAt: Maybe<Scalars['DateTime']>;
  /** The user or application that triggered the event. */
  issuingPrincipal: Maybe<IssuingPrincipal>;
  /** The application receiving the webhook. */
  recipient: Maybe<App>;
  /** Look up a transaction. */
  transaction: Maybe<TransactionItem>;
  /** Saleor version that triggered the event. */
  version: Maybe<Scalars['String']>;
};

/**
 * Request an action for payment transaction.
 *
 * Requires one of the following permissions: HANDLE_PAYMENTS.
 */
export type TransactionRequestAction = {
  __typename: 'TransactionRequestAction';
  errors: Array<TransactionRequestActionError>;
  transaction: Maybe<TransactionItem>;
};

export type TransactionRequestActionError = {
  __typename: 'TransactionRequestActionError';
  /** The error code. */
  code: TransactionRequestActionErrorCode;
  /** Name of a field that caused the error. A value of `null` indicates that the error isn't associated with a particular field. */
  field: Maybe<Scalars['String']>;
  /** The error message. */
  message: Maybe<Scalars['String']>;
};

export type TransactionRequestActionErrorCode =
  | 'GRAPHQL_ERROR'
  | 'INVALID'
  | 'MISSING_TRANSACTION_ACTION_REQUEST_WEBHOOK'
  | 'NOT_FOUND'
  | 'REQUIRED';

/**
 * Request a refund for payment transaction based on granted refund.
 *
 * Requires one of the following permissions: HANDLE_PAYMENTS.
 */
export type TransactionRequestRefundForGrantedRefund = {
  __typename: 'TransactionRequestRefundForGrantedRefund';
  errors: Array<TransactionRequestRefundForGrantedRefundError>;
  transaction: Maybe<TransactionItem>;
};

export type TransactionRequestRefundForGrantedRefundError = {
  __typename: 'TransactionRequestRefundForGrantedRefundError';
  /** The error code. */
  code: TransactionRequestRefundForGrantedRefundErrorCode;
  /** Name of a field that caused the error. A value of `null` indicates that the error isn't associated with a particular field. */
  field: Maybe<Scalars['String']>;
  /** The error message. */
  message: Maybe<Scalars['String']>;
};

export type TransactionRequestRefundForGrantedRefundErrorCode =
  | 'AMOUNT_GREATER_THAN_AVAILABLE'
  | 'GRAPHQL_ERROR'
  | 'INVALID'
  | 'MISSING_TRANSACTION_ACTION_REQUEST_WEBHOOK'
  | 'NOT_FOUND'
  | 'REFUND_ALREADY_PROCESSED'
  | 'REFUND_IS_PENDING';

/**
 * Update transaction.
 *
 * Requires the following permissions: OWNER and HANDLE_PAYMENTS for apps, HANDLE_PAYMENTS for staff users. Staff user cannot update a transaction that is owned by the app.
 */
export type TransactionUpdate = {
  __typename: 'TransactionUpdate';
  errors: Array<TransactionUpdateError>;
  transaction: Maybe<TransactionItem>;
};

export type TransactionUpdateError = {
  __typename: 'TransactionUpdateError';
  /** The error code. */
  code: TransactionUpdateErrorCode;
  /** Name of a field that caused the error. A value of `null` indicates that the error isn't associated with a particular field. */
  field: Maybe<Scalars['String']>;
  /** The error message. */
  message: Maybe<Scalars['String']>;
};

export type TransactionUpdateErrorCode =
  | 'GRAPHQL_ERROR'
  | 'INCORRECT_CURRENCY'
  | 'INVALID'
  | 'METADATA_KEY_REQUIRED'
  | 'NOT_FOUND'
  | 'UNIQUE';

export type TransactionUpdateInput = {
  /** Amount authorized by this transaction. */
  amountAuthorized: InputMaybe<MoneyInput>;
  /** Amount canceled by this transaction. */
  amountCanceled: InputMaybe<MoneyInput>;
  /** Amount charged by this transaction. */
  amountCharged: InputMaybe<MoneyInput>;
  /** Amount refunded by this transaction. */
  amountRefunded: InputMaybe<MoneyInput>;
  /** List of all possible actions for the transaction */
  availableActions: InputMaybe<Array<TransactionActionEnum>>;
  /** The url that will allow to redirect user to payment provider page with transaction event details. */
  externalUrl: InputMaybe<Scalars['String']>;
  /** The message of the transaction. */
  message: InputMaybe<Scalars['String']>;
  /**
   * Payment public metadata. Can be read by any API client authorized to read the object it's attached to.
   *
   * Warning: never store sensitive information, including financial data such as credit card details.
   */
  metadata: InputMaybe<Array<MetadataInput>>;
  /** Payment name of the transaction. */
  name: InputMaybe<Scalars['String']>;
  /**
   * Details of the payment method used for the transaction.
   *
   * Added in Saleor 3.22.
   */
  paymentMethodDetails: InputMaybe<PaymentMethodDetailsInput>;
  /**
   * Payment private metadata. Requires permissions to modify and to read the metadata of the object it's attached to.
   *
   * Warning: never store sensitive information, including financial data such as credit card details.
   */
  privateMetadata: InputMaybe<Array<MetadataInput>>;
  /** PSP Reference of the transaction. */
  pspReference: InputMaybe<Scalars['String']>;
};

export type TransactionWhereInput = {
  /** List of conditions that must be met. */
  AND: InputMaybe<Array<TransactionWhereInput>>;
  /** A list of conditions of which at least one must be met. */
  OR: InputMaybe<Array<TransactionWhereInput>>;
  /** Filter by app identifier. */
  appIdentifier: InputMaybe<StringFilterInput>;
  ids: InputMaybe<Array<Scalars['ID']>>;
  /** Filter by PSP reference. */
  pspReference: InputMaybe<StringFilterInput>;
};

export type TranslatableItem = AttributeTranslatableContent | AttributeValueTranslatableContent | CategoryTranslatableContent | CollectionTranslatableContent | MenuItemTranslatableContent | PageTranslatableContent | ProductTranslatableContent | ProductVariantTranslatableContent | PromotionRuleTranslatableContent | PromotionTranslatableContent | SaleTranslatableContent | ShippingMethodTranslatableContent | VoucherTranslatableContent;

export type TranslatableItemConnection = {
  __typename: 'TranslatableItemConnection';
  edges: Array<TranslatableItemEdge>;
  /** Pagination data for this connection. */
  pageInfo: PageInfo;
  /** A total count of items in the collection. */
  totalCount: Maybe<Scalars['Int']>;
};

export type TranslatableItemEdge = {
  __typename: 'TranslatableItemEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node: TranslatableItem;
};

export type TranslatableKinds =
  | 'ATTRIBUTE'
  | 'ATTRIBUTE_VALUE'
  | 'CATEGORY'
  | 'COLLECTION'
  | 'MENU_ITEM'
  | 'PAGE'
  | 'PRODUCT'
  | 'PROMOTION'
  | 'PROMOTION_RULE'
  | 'SALE'
  | 'SHIPPING_METHOD'
  | 'VARIANT'
  | 'VOUCHER';

/** Event sent when new translation is created. */
export type TranslationCreated = Event & {
  __typename: 'TranslationCreated';
  /** Time of the event. */
  issuedAt: Maybe<Scalars['DateTime']>;
  /** The user or application that triggered the event. */
  issuingPrincipal: Maybe<IssuingPrincipal>;
  /** The application receiving the webhook. */
  recipient: Maybe<App>;
  /** The translation the event relates to. */
  translation: Maybe<TranslationTypes>;
  /** Saleor version that triggered the event. */
  version: Maybe<Scalars['String']>;
};

export type TranslationError = {
  __typename: 'TranslationError';
  /** The error code. */
  code: TranslationErrorCode;
  /** Name of a field that caused the error. A value of `null` indicates that the error isn't associated with a particular field. */
  field: Maybe<Scalars['String']>;
  /** The error message. */
  message: Maybe<Scalars['String']>;
};

export type TranslationErrorCode =
  | 'GRAPHQL_ERROR'
  | 'INVALID'
  | 'NOT_FOUND'
  | 'REQUIRED'
  | 'UNIQUE';

export type TranslationInput = {
  /**
   * Translated description.
   *
   * Rich text format. For reference see https://editorjs.io/
   */
  description: InputMaybe<Scalars['JSONString']>;
  name: InputMaybe<Scalars['String']>;
  seoDescription: InputMaybe<Scalars['String']>;
  seoTitle: InputMaybe<Scalars['String']>;
  slug: InputMaybe<Scalars['String']>;
};

export type TranslationTypes = AttributeTranslation | AttributeValueTranslation | CategoryTranslation | CollectionTranslation | MenuItemTranslation | PageTranslation | ProductTranslation | ProductVariantTranslation | PromotionRuleTranslation | PromotionTranslation | SaleTranslation | ShippingMethodTranslation | VoucherTranslation;

/** Event sent when translation is updated. */
export type TranslationUpdated = Event & {
  __typename: 'TranslationUpdated';
  /** Time of the event. */
  issuedAt: Maybe<Scalars['DateTime']>;
  /** The user or application that triggered the event. */
  issuingPrincipal: Maybe<IssuingPrincipal>;
  /** The application receiving the webhook. */
  recipient: Maybe<App>;
  /** The translation the event relates to. */
  translation: Maybe<TranslationTypes>;
  /** Saleor version that triggered the event. */
  version: Maybe<Scalars['String']>;
};

/** Define the filtering options for string fields. */
export type UuidFilterInput = {
  /** The value equal to. */
  eq: InputMaybe<Scalars['UUID']>;
  /** The value included in. */
  oneOf: InputMaybe<Array<Scalars['UUID']>>;
};

export type UpdateInvoiceInput = {
  /**
   * Fields required to update the invoice metadata. Can be read by any API client authorized to read the object it's attached to.
   *
   * Warning: never store sensitive information, including financial data such as credit card details.
   */
  metadata: InputMaybe<Array<MetadataInput>>;
  /** Invoice number */
  number: InputMaybe<Scalars['String']>;
  /**
   * Fields required to update the invoice private metadata. Requires permissions to modify and to read the metadata of the object it's attached to.
   *
   * Warning: never store sensitive information, including financial data such as credit card details.
   */
  privateMetadata: InputMaybe<Array<MetadataInput>>;
  /** URL of an invoice to download. */
  url: InputMaybe<Scalars['String']>;
};

/**
 * Updates metadata of an object.Requires permissions to modify and to read the metadata of the object it's attached to.
 *
 * Warning: never store sensitive information, including financial data such as credit card details.
 */
export type UpdateMetadata = {
  __typename: 'UpdateMetadata';
  errors: Array<MetadataError>;
  item: Maybe<ObjectWithMetadata>;
  /** @deprecated Use `errors` field instead. */
  metadataErrors: Array<MetadataError>;
};

/**
 * Updates private metadata of an object. Requires permissions to modify and to read the metadata of the object it's attached to.
 *
 * Warning: never store sensitive information, including financial data such as credit card details.
 */
export type UpdatePrivateMetadata = {
  __typename: 'UpdatePrivateMetadata';
  errors: Array<MetadataError>;
  item: Maybe<ObjectWithMetadata>;
  /** @deprecated Use `errors` field instead. */
  metadataErrors: Array<MetadataError>;
};

export type UploadError = {
  __typename: 'UploadError';
  /** The error code. */
  code: UploadErrorCode;
  /** Name of a field that caused the error. A value of `null` indicates that the error isn't associated with a particular field. */
  field: Maybe<Scalars['String']>;
  /** The error message. */
  message: Maybe<Scalars['String']>;
};

export type UploadErrorCode =
  | 'GRAPHQL_ERROR'
  | 'INVALID_FILE_TYPE'
  | 'UNSUPPORTED_MIME_TYPE';

/** Represents user data. */
export type User = Node & ObjectWithMetadata & {
  __typename: 'User';
  /** List of channels the user has access to. The sum of channels from all user groups. If at least one group has `restrictedAccessToChannels` set to False - all channels are returned. */
  accessibleChannels: Maybe<Array<Channel>>;
  /** List of all user's addresses. */
  addresses: Array<Address>;
  /** The avatar of the user. */
  avatar: Maybe<Image>;
  /**
   * Returns the last open checkout of this user.
   * @deprecated Use the `checkoutTokens` field to fetch the user checkouts.
   */
  checkout: Maybe<Checkout>;
  /** Returns the checkout ID's assigned to this user. */
  checkoutIds: Maybe<Array<Scalars['ID']>>;
  /**
   * Returns the checkout UUID's assigned to this user.
   * @deprecated Use `checkoutIds` instead.
   */
  checkoutTokens: Maybe<Array<Scalars['UUID']>>;
  /** Returns checkouts assigned to this user. The query will not initiate any external requests, including fetching external shipping methods, filtering available shipping methods, or performing external tax calculations. */
  checkouts: Maybe<CheckoutCountableConnection>;
  /** The data when the user create account. */
  dateJoined: Scalars['DateTime'];
  /** The default billing address of the user. */
  defaultBillingAddress: Maybe<Address>;
  /** The default shipping address of the user. */
  defaultShippingAddress: Maybe<Address>;
  /** List of user's permission groups which user can manage. */
  editableGroups: Maybe<Array<Group>>;
  /** The email address of the user. */
  email: Scalars['String'];
  /**
   * List of events associated with the user.
   *
   * Requires one of the following permissions: MANAGE_USERS, MANAGE_STAFF.
   */
  events: Maybe<Array<CustomerEvent>>;
  /** External ID of this user. */
  externalReference: Maybe<Scalars['String']>;
  /** The given name of the address. */
  firstName: Scalars['String'];
  /** List of the user gift cards. */
  giftCards: Maybe<GiftCardCountableConnection>;
  /** The ID of the user. */
  id: Scalars['ID'];
  /** Determine if the user is active. */
  isActive: Scalars['Boolean'];
  /** Determines if user has confirmed email. */
  isConfirmed: Scalars['Boolean'];
  /** Determine if the user is a staff admin. */
  isStaff: Scalars['Boolean'];
  /** User language code. */
  languageCode: LanguageCodeEnum;
  /** The date when the user last time log in to the system. */
  lastLogin: Maybe<Scalars['DateTime']>;
  /** The family name of the address. */
  lastName: Scalars['String'];
  /** List of public metadata items. Can be accessed without permissions. */
  metadata: Array<MetadataItem>;
  /**
   * A single key from public metadata.
   *
   * Tip: Use GraphQL aliases to fetch multiple keys.
   */
  metafield: Maybe<Scalars['String']>;
  /** Public metadata. Use `keys` to control which fields you want to include. The default is to include everything. */
  metafields: Maybe<Scalars['Metadata']>;
  /**
   * A note about the customer.
   *
   * Requires one of the following permissions: MANAGE_USERS, MANAGE_STAFF.
   */
  note: Maybe<Scalars['String']>;
  /** List of user's orders. The query will not initiate any external requests, including filtering available shipping methods, or performing external tax calculations. Requires one of the following permissions: MANAGE_STAFF, OWNER. */
  orders: Maybe<OrderCountableConnection>;
  /** List of user's permission groups. */
  permissionGroups: Maybe<Array<Group>>;
  /** List of private metadata items. Requires staff permissions to access. */
  privateMetadata: Array<MetadataItem>;
  /**
   * A single key from private metadata. Requires staff permissions to access.
   *
   * Tip: Use GraphQL aliases to fetch multiple keys.
   */
  privateMetafield: Maybe<Scalars['String']>;
  /** Private metadata. Requires staff permissions to access. Use `keys` to control which fields you want to include. The default is to include everything. */
  privateMetafields: Maybe<Scalars['Metadata']>;
  /** Determine if user have restricted access to channels. False if at least one user group has `restrictedAccessToChannels` set to False. */
  restrictedAccessToChannels: Scalars['Boolean'];
  /** Returns a list of user's stored payment methods that can be used in provided channel. The field returns a list of stored payment methods by payment apps. When `amount` is not provided, 0 will be used as default value. */
  storedPaymentMethods: Maybe<Array<StoredPaymentMethod>>;
  /** List of stored payment sources. The field returns a list of payment sources stored for payment plugins. */
  storedPaymentSources: Maybe<Array<PaymentSource>>;
  /** The data when the user last update the account information. */
  updatedAt: Scalars['DateTime'];
  /** List of user's permissions. */
  userPermissions: Maybe<Array<UserPermission>>;
};


/** Represents user data. */
export type UserAvatarArgs = {
  format?: InputMaybe<ThumbnailFormatEnum>;
  size: InputMaybe<Scalars['Int']>;
};


/** Represents user data. */
export type UserCheckoutIdsArgs = {
  channel: InputMaybe<Scalars['String']>;
};


/** Represents user data. */
export type UserCheckoutTokensArgs = {
  channel: InputMaybe<Scalars['String']>;
};


/** Represents user data. */
export type UserCheckoutsArgs = {
  after: InputMaybe<Scalars['String']>;
  before: InputMaybe<Scalars['String']>;
  channel: InputMaybe<Scalars['String']>;
  first: InputMaybe<Scalars['Int']>;
  last: InputMaybe<Scalars['Int']>;
};


/** Represents user data. */
export type UserGiftCardsArgs = {
  after: InputMaybe<Scalars['String']>;
  before: InputMaybe<Scalars['String']>;
  first: InputMaybe<Scalars['Int']>;
  last: InputMaybe<Scalars['Int']>;
};


/** Represents user data. */
export type UserMetafieldArgs = {
  key: Scalars['String'];
};


/** Represents user data. */
export type UserMetafieldsArgs = {
  keys: InputMaybe<Array<Scalars['String']>>;
};


/** Represents user data. */
export type UserOrdersArgs = {
  after: InputMaybe<Scalars['String']>;
  before: InputMaybe<Scalars['String']>;
  first: InputMaybe<Scalars['Int']>;
  last: InputMaybe<Scalars['Int']>;
};


/** Represents user data. */
export type UserPrivateMetafieldArgs = {
  key: Scalars['String'];
};


/** Represents user data. */
export type UserPrivateMetafieldsArgs = {
  keys: InputMaybe<Array<Scalars['String']>>;
};


/** Represents user data. */
export type UserStoredPaymentMethodsArgs = {
  channel: Scalars['String'];
};


/** Represents user data. */
export type UserStoredPaymentSourcesArgs = {
  channel: InputMaybe<Scalars['String']>;
};

/**
 * Deletes a user avatar. Only for staff members.
 *
 * Requires one of the following permissions: AUTHENTICATED_STAFF_USER.
 */
export type UserAvatarDelete = {
  __typename: 'UserAvatarDelete';
  /** @deprecated Use `errors` field instead. */
  accountErrors: Array<AccountError>;
  errors: Array<AccountError>;
  /** An updated user instance. */
  user: Maybe<User>;
};

/**
 * Create a user avatar. Only for staff members. This mutation must be sent as a `multipart` request. More detailed specs of the upload format can be found here: https://github.com/jaydenseric/graphql-multipart-request-spec
 *
 * Requires one of the following permissions: AUTHENTICATED_STAFF_USER.
 */
export type UserAvatarUpdate = {
  __typename: 'UserAvatarUpdate';
  /** @deprecated Use `errors` field instead. */
  accountErrors: Array<AccountError>;
  errors: Array<AccountError>;
  /** An updated user instance. */
  user: Maybe<User>;
};

/**
 * Activate or deactivate users.
 *
 * Requires one of the following permissions: MANAGE_USERS.
 */
export type UserBulkSetActive = {
  __typename: 'UserBulkSetActive';
  /** @deprecated Use `errors` field instead. */
  accountErrors: Array<AccountError>;
  /** Returns how many objects were affected. */
  count: Scalars['Int'];
  errors: Array<AccountError>;
};

export type UserCountableConnection = {
  __typename: 'UserCountableConnection';
  edges: Array<UserCountableEdge>;
  /** Pagination data for this connection. */
  pageInfo: PageInfo;
  /** A total count of items in the collection. */
  totalCount: Maybe<Scalars['Int']>;
};

export type UserCountableEdge = {
  __typename: 'UserCountableEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node: User;
};

export type UserCreateInput = {
  /** Slug of a channel which will be used for notify user. Optional when only one channel exists. */
  channel: InputMaybe<Scalars['String']>;
  /** Billing address of the customer. */
  defaultBillingAddress: InputMaybe<AddressInput>;
  /** Shipping address of the customer. */
  defaultShippingAddress: InputMaybe<AddressInput>;
  /** The unique email address of the user. */
  email: InputMaybe<Scalars['String']>;
  /** External ID of the customer. */
  externalReference: InputMaybe<Scalars['String']>;
  /** Given name. */
  firstName: InputMaybe<Scalars['String']>;
  /** User account is active. */
  isActive: InputMaybe<Scalars['Boolean']>;
  /**
   * User account is confirmed.
   * @deprecated The user will be always set as unconfirmed. The confirmation will take place when the user sets the password.
   */
  isConfirmed: InputMaybe<Scalars['Boolean']>;
  /** User language code. */
  languageCode: InputMaybe<LanguageCodeEnum>;
  /** Family name. */
  lastName: InputMaybe<Scalars['String']>;
  /**
   * Fields required to update the user metadata. Can be read by any API client authorized to read the object it's attached to.
   *
   * Warning: never store sensitive information, including financial data such as credit card details.
   */
  metadata: InputMaybe<Array<MetadataInput>>;
  /** A note about the user. */
  note: InputMaybe<Scalars['String']>;
  /**
   * Fields required to update the user private metadata. Requires permissions to modify and to read the metadata of the object it's attached to.
   *
   * Warning: never store sensitive information, including financial data such as credit card details.
   */
  privateMetadata: InputMaybe<Array<MetadataInput>>;
  /** URL of a view where users should be redirected to set the password. URL in RFC 1808 format. */
  redirectUrl: InputMaybe<Scalars['String']>;
};

export type UserOrApp = App | User;

/** Represents user's permissions. */
export type UserPermission = {
  __typename: 'UserPermission';
  /** Internal code for permission. */
  code: PermissionEnum;
  /** Describe action(s) allowed to do by permission. */
  name: Scalars['String'];
  /** List of user permission groups which contains this permission. */
  sourcePermissionGroups: Maybe<Array<Group>>;
};


/** Represents user's permissions. */
export type UserPermissionSourcePermissionGroupsArgs = {
  userId: Scalars['ID'];
};

export type UserSortField =
  /** Sort users by created at. */
  | 'CREATED_AT'
  /** Sort users by email. */
  | 'EMAIL'
  /** Sort users by first name. */
  | 'FIRST_NAME'
  /** Sort users by last modified at. */
  | 'LAST_MODIFIED_AT'
  /** Sort users by last name. */
  | 'LAST_NAME'
  /** Sort users by order count. */
  | 'ORDER_COUNT';

export type UserSortingInput = {
  /** Specifies the direction in which to sort users. */
  direction: OrderDirection;
  /** Sort users by the selected field. */
  field: UserSortField;
};

/** Represents a VAT rate for a country. */
export type Vat = {
  __typename: 'VAT';
  /** Country code. */
  countryCode: Scalars['String'];
  /** Country's VAT rate exceptions for specific types of goods. */
  reducedRates: Array<ReducedRate>;
  /** Standard VAT rate in percent. */
  standardRate: Maybe<Scalars['Float']>;
};

export type VariantAttributeScope =
  | 'ALL'
  | 'NOT_VARIANT_SELECTION'
  | 'VARIANT_SELECTION';

/**
 * Assign an media to a product variant.
 *
 * Requires one of the following permissions: MANAGE_PRODUCTS.
 */
export type VariantMediaAssign = {
  __typename: 'VariantMediaAssign';
  errors: Array<ProductError>;
  media: Maybe<ProductMedia>;
  /** @deprecated Use `errors` field instead. */
  productErrors: Array<ProductError>;
  productVariant: Maybe<ProductVariant>;
};

/**
 * Unassign an media from a product variant.
 *
 * Requires one of the following permissions: MANAGE_PRODUCTS.
 */
export type VariantMediaUnassign = {
  __typename: 'VariantMediaUnassign';
  errors: Array<ProductError>;
  media: Maybe<ProductMedia>;
  /** @deprecated Use `errors` field instead. */
  productErrors: Array<ProductError>;
  productVariant: Maybe<ProductVariant>;
};

/** Represents availability of a variant in the storefront. */
export type VariantPricingInfo = {
  __typename: 'VariantPricingInfo';
  /** The discount amount if in sale (null otherwise). */
  discount: Maybe<TaxedMoney>;
  /**
   * The discount amount in the local currency.
   * @deprecated Always returns `null`.
   */
  discountLocalCurrency: Maybe<TaxedMoney>;
  /**
   * The discount amount compared to prior price. Null if product is not on sale or prior price was not provided in VariantChannelListing
   *
   * Added in Saleor 3.21.
   */
  discountPrior: Maybe<TaxedMoney>;
  /** Whether it is in sale or not. */
  onSale: Maybe<Scalars['Boolean']>;
  /** The price, with any discount subtracted. */
  price: Maybe<TaxedMoney>;
  /**
   * The discounted price in the local currency.
   * @deprecated Always returns `null`.
   */
  priceLocalCurrency: Maybe<TaxedMoney>;
  /**
   * The price prior to discount.
   *
   * Added in Saleor 3.21.
   */
  pricePrior: Maybe<TaxedMoney>;
  /** The price without any discount. */
  priceUndiscounted: Maybe<TaxedMoney>;
};

/** Verify JWT token. */
export type VerifyToken = {
  __typename: 'VerifyToken';
  /** @deprecated Use `errors` field instead. */
  accountErrors: Array<AccountError>;
  errors: Array<AccountError>;
  /** Determine if token is valid or not. */
  isValid: Scalars['Boolean'];
  /** JWT payload. */
  payload: Maybe<Scalars['GenericScalar']>;
  /** User assigned to token. */
  user: Maybe<User>;
};

export type VolumeUnitsEnum =
  | 'ACRE_FT'
  | 'ACRE_IN'
  | 'CUBIC_CENTIMETER'
  | 'CUBIC_DECIMETER'
  | 'CUBIC_FOOT'
  | 'CUBIC_INCH'
  | 'CUBIC_METER'
  | 'CUBIC_MILLIMETER'
  | 'CUBIC_YARD'
  | 'FL_OZ'
  | 'LITER'
  | 'PINT'
  | 'QT';

/** Vouchers allow giving discounts to particular customers on categories, collections or specific products. They can be used during checkout by providing valid voucher codes. */
export type Voucher = Node & ObjectWithMetadata & {
  __typename: 'Voucher';
  /** Determine if the voucher usage should be limited to one use per customer. */
  applyOncePerCustomer: Scalars['Boolean'];
  /** Determine if the voucher should be applied once per order. If set to True, the voucher is applied to a single cheapest eligible product in checkout. */
  applyOncePerOrder: Scalars['Boolean'];
  /** List of categories this voucher applies to. */
  categories: Maybe<CategoryCountableConnection>;
  /**
   * List of availability in channels for the voucher.
   *
   * Requires one of the following permissions: MANAGE_DISCOUNTS.
   */
  channelListings: Maybe<Array<VoucherChannelListing>>;
  /** The code of the voucher. */
  code: Maybe<Scalars['String']>;
  /**
   * List of codes available for this voucher.
   *
   * Added in Saleor 3.18.
   */
  codes: Maybe<VoucherCodeCountableConnection>;
  /**
   * List of collections this voucher applies to.
   *
   * Requires one of the following permissions: MANAGE_DISCOUNTS.
   */
  collections: Maybe<CollectionCountableConnection>;
  /** List of countries available for the shipping voucher. */
  countries: Maybe<Array<CountryDisplay>>;
  /** Currency code for voucher. */
  currency: Maybe<Scalars['String']>;
  /** Voucher value. */
  discountValue: Maybe<Scalars['Float']>;
  /** Determines a type of discount for voucher - value or percentage */
  discountValueType: DiscountValueTypeEnum;
  /** The end date and time of voucher. */
  endDate: Maybe<Scalars['DateTime']>;
  /** The ID of the voucher. */
  id: Scalars['ID'];
  /** List of public metadata items. Can be accessed without permissions. */
  metadata: Array<MetadataItem>;
  /**
   * A single key from public metadata.
   *
   * Tip: Use GraphQL aliases to fetch multiple keys.
   */
  metafield: Maybe<Scalars['String']>;
  /** Public metadata. Use `keys` to control which fields you want to include. The default is to include everything. */
  metafields: Maybe<Scalars['Metadata']>;
  /** Determine minimum quantity of items for checkout. */
  minCheckoutItemsQuantity: Maybe<Scalars['Int']>;
  /** Minimum order value to apply voucher. */
  minSpent: Maybe<Money>;
  /** The name of the voucher. */
  name: Maybe<Scalars['String']>;
  /** Determine if the voucher is available only for staff members. */
  onlyForStaff: Scalars['Boolean'];
  /** List of private metadata items. Requires staff permissions to access. */
  privateMetadata: Array<MetadataItem>;
  /**
   * A single key from private metadata. Requires staff permissions to access.
   *
   * Tip: Use GraphQL aliases to fetch multiple keys.
   */
  privateMetafield: Maybe<Scalars['String']>;
  /** Private metadata. Requires staff permissions to access. Use `keys` to control which fields you want to include. The default is to include everything. */
  privateMetafields: Maybe<Scalars['Metadata']>;
  /**
   * List of products this voucher applies to.
   *
   * Requires one of the following permissions: MANAGE_DISCOUNTS.
   */
  products: Maybe<ProductCountableConnection>;
  /**
   * Determine if the voucher codes can be used once or multiple times.
   *
   * Added in Saleor 3.18.
   *
   * Note: this API is currently in Feature Preview and can be subject to changes at later point.
   */
  singleUse: Scalars['Boolean'];
  /** The start date and time of voucher. */
  startDate: Scalars['DateTime'];
  /** Returns translated voucher fields for the given language code. */
  translation: Maybe<VoucherTranslation>;
  /** Determines a type of voucher. */
  type: VoucherTypeEnum;
  /** The number of times a voucher can be used. */
  usageLimit: Maybe<Scalars['Int']>;
  /** Usage count of the voucher. */
  used: Scalars['Int'];
  /**
   * List of product variants this voucher applies to.
   *
   * Requires one of the following permissions: MANAGE_DISCOUNTS.
   */
  variants: Maybe<ProductVariantCountableConnection>;
};


/** Vouchers allow giving discounts to particular customers on categories, collections or specific products. They can be used during checkout by providing valid voucher codes. */
export type VoucherCategoriesArgs = {
  after: InputMaybe<Scalars['String']>;
  before: InputMaybe<Scalars['String']>;
  first: InputMaybe<Scalars['Int']>;
  last: InputMaybe<Scalars['Int']>;
};


/** Vouchers allow giving discounts to particular customers on categories, collections or specific products. They can be used during checkout by providing valid voucher codes. */
export type VoucherCodesArgs = {
  after: InputMaybe<Scalars['String']>;
  before: InputMaybe<Scalars['String']>;
  first: InputMaybe<Scalars['Int']>;
  last: InputMaybe<Scalars['Int']>;
};


/** Vouchers allow giving discounts to particular customers on categories, collections or specific products. They can be used during checkout by providing valid voucher codes. */
export type VoucherCollectionsArgs = {
  after: InputMaybe<Scalars['String']>;
  before: InputMaybe<Scalars['String']>;
  first: InputMaybe<Scalars['Int']>;
  last: InputMaybe<Scalars['Int']>;
};


/** Vouchers allow giving discounts to particular customers on categories, collections or specific products. They can be used during checkout by providing valid voucher codes. */
export type VoucherMetafieldArgs = {
  key: Scalars['String'];
};


/** Vouchers allow giving discounts to particular customers on categories, collections or specific products. They can be used during checkout by providing valid voucher codes. */
export type VoucherMetafieldsArgs = {
  keys: InputMaybe<Array<Scalars['String']>>;
};


/** Vouchers allow giving discounts to particular customers on categories, collections or specific products. They can be used during checkout by providing valid voucher codes. */
export type VoucherPrivateMetafieldArgs = {
  key: Scalars['String'];
};


/** Vouchers allow giving discounts to particular customers on categories, collections or specific products. They can be used during checkout by providing valid voucher codes. */
export type VoucherPrivateMetafieldsArgs = {
  keys: InputMaybe<Array<Scalars['String']>>;
};


/** Vouchers allow giving discounts to particular customers on categories, collections or specific products. They can be used during checkout by providing valid voucher codes. */
export type VoucherProductsArgs = {
  after: InputMaybe<Scalars['String']>;
  before: InputMaybe<Scalars['String']>;
  first: InputMaybe<Scalars['Int']>;
  last: InputMaybe<Scalars['Int']>;
};


/** Vouchers allow giving discounts to particular customers on categories, collections or specific products. They can be used during checkout by providing valid voucher codes. */
export type VoucherTranslationArgs = {
  languageCode: LanguageCodeEnum;
};


/** Vouchers allow giving discounts to particular customers on categories, collections or specific products. They can be used during checkout by providing valid voucher codes. */
export type VoucherVariantsArgs = {
  after: InputMaybe<Scalars['String']>;
  before: InputMaybe<Scalars['String']>;
  first: InputMaybe<Scalars['Int']>;
  last: InputMaybe<Scalars['Int']>;
};

/**
 * Adds products, categories, collections to a voucher.
 *
 * Requires one of the following permissions: MANAGE_DISCOUNTS.
 *
 * Triggers the following webhook events:
 * - VOUCHER_UPDATED (async): A voucher was updated.
 */
export type VoucherAddCatalogues = {
  __typename: 'VoucherAddCatalogues';
  /** @deprecated Use `errors` field instead. */
  discountErrors: Array<DiscountError>;
  errors: Array<DiscountError>;
  /** Voucher of which catalogue IDs will be modified. */
  voucher: Maybe<Voucher>;
};

/**
 * Deletes vouchers.
 *
 * Requires one of the following permissions: MANAGE_DISCOUNTS.
 *
 * Triggers the following webhook events:
 * - VOUCHER_DELETED (async): A voucher was deleted.
 */
export type VoucherBulkDelete = {
  __typename: 'VoucherBulkDelete';
  /** Returns how many objects were affected. */
  count: Scalars['Int'];
  /** @deprecated Use `errors` field instead. */
  discountErrors: Array<DiscountError>;
  errors: Array<DiscountError>;
};

/** Represents voucher channel listing. */
export type VoucherChannelListing = Node & {
  __typename: 'VoucherChannelListing';
  /** The channel in which voucher can be applied. */
  channel: Channel;
  /** Currency code for voucher in a channel. */
  currency: Scalars['String'];
  /** The value of the discount on voucher in a channel. */
  discountValue: Scalars['Float'];
  /** The ID of channel listing. */
  id: Scalars['ID'];
  /** Minimum order value for voucher to apply in channel. */
  minSpent: Maybe<Money>;
};

export type VoucherChannelListingAddInput = {
  /** ID of a channel. */
  channelId: Scalars['ID'];
  /** Value of the voucher. */
  discountValue: InputMaybe<Scalars['PositiveDecimal']>;
  /** Min purchase amount required to apply the voucher. */
  minAmountSpent: InputMaybe<Scalars['PositiveDecimal']>;
};

export type VoucherChannelListingInput = {
  /** List of channels to which the voucher should be assigned. */
  addChannels: InputMaybe<Array<VoucherChannelListingAddInput>>;
  /** List of channels from which the voucher should be unassigned. */
  removeChannels: InputMaybe<Array<Scalars['ID']>>;
};

/**
 * Manage voucher's availability in channels.
 *
 * Requires one of the following permissions: MANAGE_DISCOUNTS.
 *
 * Triggers the following webhook events:
 * - VOUCHER_UPDATED (async): A voucher was updated.
 */
export type VoucherChannelListingUpdate = {
  __typename: 'VoucherChannelListingUpdate';
  /** @deprecated Use `errors` field instead. */
  discountErrors: Array<DiscountError>;
  errors: Array<DiscountError>;
  /** An updated voucher instance. */
  voucher: Maybe<Voucher>;
};

/**
 * Represents voucher code.
 *
 * Added in Saleor 3.18.
 *
 * Note: this API is currently in Feature Preview and can be subject to changes at later point.
 */
export type VoucherCode = {
  __typename: 'VoucherCode';
  /** Code to use the voucher. */
  code: Maybe<Scalars['String']>;
  /** Date time of code creation. */
  createdAt: Scalars['DateTime'];
  /** The ID of the voucher code. */
  id: Scalars['ID'];
  /** Whether a code is active or not. */
  isActive: Maybe<Scalars['Boolean']>;
  /** Number of times a code has been used. */
  used: Maybe<Scalars['Int']>;
};

/**
 * Deletes voucher codes.
 *
 * Added in Saleor 3.18.
 *
 * Requires one of the following permissions: MANAGE_DISCOUNTS.
 *
 * Triggers the following webhook events:
 * - VOUCHER_CODES_DELETED (async): A voucher codes were deleted.
 */
export type VoucherCodeBulkDelete = {
  __typename: 'VoucherCodeBulkDelete';
  /** Returns how many codes were deleted. */
  count: Scalars['Int'];
  errors: Array<VoucherCodeBulkDeleteError>;
};

export type VoucherCodeBulkDeleteError = {
  __typename: 'VoucherCodeBulkDeleteError';
  /** The error code. */
  code: VoucherCodeBulkDeleteErrorCode;
  /** The error message. */
  message: Maybe<Scalars['String']>;
  /** Path to field that caused the error. A value of `null` indicates that the error isn't associated with a particular field. */
  path: Maybe<Scalars['String']>;
  /** List of voucher codes which causes the error. */
  voucherCodes: Maybe<Array<Scalars['ID']>>;
};

export type VoucherCodeBulkDeleteErrorCode =
  | 'GRAPHQL_ERROR'
  | 'INVALID'
  | 'NOT_FOUND';

export type VoucherCodeCountableConnection = {
  __typename: 'VoucherCodeCountableConnection';
  edges: Array<VoucherCodeCountableEdge>;
  /** Pagination data for this connection. */
  pageInfo: PageInfo;
  /** A total count of items in the collection. */
  totalCount: Maybe<Scalars['Int']>;
};

export type VoucherCodeCountableEdge = {
  __typename: 'VoucherCodeCountableEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node: VoucherCode;
};

/**
 * Event sent when voucher code export is completed.
 *
 * Added in Saleor 3.18.
 */
export type VoucherCodeExportCompleted = Event & {
  __typename: 'VoucherCodeExportCompleted';
  /** The export file for voucher codes. */
  export: Maybe<ExportFile>;
  /** Time of the event. */
  issuedAt: Maybe<Scalars['DateTime']>;
  /** The user or application that triggered the event. */
  issuingPrincipal: Maybe<IssuingPrincipal>;
  /** The application receiving the webhook. */
  recipient: Maybe<App>;
  /** Saleor version that triggered the event. */
  version: Maybe<Scalars['String']>;
};

/**
 * Event sent when new voucher codes were created.
 *
 * Added in Saleor 3.19.
 */
export type VoucherCodesCreated = Event & {
  __typename: 'VoucherCodesCreated';
  /** Time of the event. */
  issuedAt: Maybe<Scalars['DateTime']>;
  /** The user or application that triggered the event. */
  issuingPrincipal: Maybe<IssuingPrincipal>;
  /** The application receiving the webhook. */
  recipient: Maybe<App>;
  /** Saleor version that triggered the event. */
  version: Maybe<Scalars['String']>;
  /** The voucher codes the event relates to. */
  voucherCodes: Maybe<Array<VoucherCode>>;
};

/**
 * Event sent when voucher codes were deleted.
 *
 * Added in Saleor 3.19.
 */
export type VoucherCodesDeleted = Event & {
  __typename: 'VoucherCodesDeleted';
  /** Time of the event. */
  issuedAt: Maybe<Scalars['DateTime']>;
  /** The user or application that triggered the event. */
  issuingPrincipal: Maybe<IssuingPrincipal>;
  /** The application receiving the webhook. */
  recipient: Maybe<App>;
  /** Saleor version that triggered the event. */
  version: Maybe<Scalars['String']>;
  /** The voucher codes the event relates to. */
  voucherCodes: Maybe<Array<VoucherCode>>;
};

export type VoucherCountableConnection = {
  __typename: 'VoucherCountableConnection';
  edges: Array<VoucherCountableEdge>;
  /** Pagination data for this connection. */
  pageInfo: PageInfo;
  /** A total count of items in the collection. */
  totalCount: Maybe<Scalars['Int']>;
};

export type VoucherCountableEdge = {
  __typename: 'VoucherCountableEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node: Voucher;
};

/**
 * Creates a new voucher.
 *
 * Requires one of the following permissions: MANAGE_DISCOUNTS.
 *
 * Triggers the following webhook events:
 * - VOUCHER_CREATED (async): A voucher was created.
 * - VOUCHER_CODES_CREATED (async): A voucher codes were created.
 */
export type VoucherCreate = {
  __typename: 'VoucherCreate';
  /** @deprecated Use `errors` field instead. */
  discountErrors: Array<DiscountError>;
  errors: Array<DiscountError>;
  voucher: Maybe<Voucher>;
};

/** Event sent when new voucher is created. */
export type VoucherCreated = Event & {
  __typename: 'VoucherCreated';
  /** Time of the event. */
  issuedAt: Maybe<Scalars['DateTime']>;
  /** The user or application that triggered the event. */
  issuingPrincipal: Maybe<IssuingPrincipal>;
  /** The application receiving the webhook. */
  recipient: Maybe<App>;
  /** Saleor version that triggered the event. */
  version: Maybe<Scalars['String']>;
  /** The voucher the event relates to. */
  voucher: Maybe<Voucher>;
};


/** Event sent when new voucher is created. */
export type VoucherCreatedVoucherArgs = {
  channel: InputMaybe<Scalars['String']>;
};

/**
 * Deletes a voucher.
 *
 * Requires one of the following permissions: MANAGE_DISCOUNTS.
 *
 * Triggers the following webhook events:
 * - VOUCHER_DELETED (async): A voucher was deleted.
 */
export type VoucherDelete = {
  __typename: 'VoucherDelete';
  /** @deprecated Use `errors` field instead. */
  discountErrors: Array<DiscountError>;
  errors: Array<DiscountError>;
  voucher: Maybe<Voucher>;
};

/** Event sent when voucher is deleted. */
export type VoucherDeleted = Event & {
  __typename: 'VoucherDeleted';
  /** Time of the event. */
  issuedAt: Maybe<Scalars['DateTime']>;
  /** The user or application that triggered the event. */
  issuingPrincipal: Maybe<IssuingPrincipal>;
  /** The application receiving the webhook. */
  recipient: Maybe<App>;
  /** Saleor version that triggered the event. */
  version: Maybe<Scalars['String']>;
  /** The voucher the event relates to. */
  voucher: Maybe<Voucher>;
};


/** Event sent when voucher is deleted. */
export type VoucherDeletedVoucherArgs = {
  channel: InputMaybe<Scalars['String']>;
};

export type VoucherDiscountType =
  | 'FIXED'
  | 'PERCENTAGE'
  | 'SHIPPING';

export type VoucherFilterInput = {
  discountType: InputMaybe<Array<VoucherDiscountType>>;
  ids: InputMaybe<Array<Scalars['ID']>>;
  metadata: InputMaybe<Array<MetadataFilter>>;
  search: InputMaybe<Scalars['String']>;
  started: InputMaybe<DateTimeRangeInput>;
  status: InputMaybe<Array<DiscountStatusEnum>>;
  timesUsed: InputMaybe<IntRangeInput>;
};

export type VoucherInput = {
  /**
   * List of codes to add.
   *
   * Added in Saleor 3.18.
   *
   * Note: this API is currently in Feature Preview and can be subject to changes at later point.
   */
  addCodes: InputMaybe<Array<Scalars['String']>>;
  /** Voucher should be applied once per customer. */
  applyOncePerCustomer: InputMaybe<Scalars['Boolean']>;
  /** Voucher should be applied to the cheapest item or entire order. */
  applyOncePerOrder: InputMaybe<Scalars['Boolean']>;
  /** Categories discounted by the voucher. */
  categories: InputMaybe<Array<Scalars['ID']>>;
  /**
   * Code to use the voucher.
   * @deprecated Use `addCodes` instead.
   */
  code: InputMaybe<Scalars['String']>;
  /** Collections discounted by the voucher. */
  collections: InputMaybe<Array<Scalars['ID']>>;
  /** Country codes that can be used with the shipping voucher. */
  countries: InputMaybe<Array<Scalars['String']>>;
  /** Choices: fixed or percentage. */
  discountValueType: InputMaybe<DiscountValueTypeEnum>;
  /** End date of the voucher in ISO 8601 format. */
  endDate: InputMaybe<Scalars['DateTime']>;
  /** Minimal quantity of checkout items required to apply the voucher. */
  minCheckoutItemsQuantity: InputMaybe<Scalars['Int']>;
  /** Voucher name. */
  name: InputMaybe<Scalars['String']>;
  /** Voucher can be used only by staff user. */
  onlyForStaff: InputMaybe<Scalars['Boolean']>;
  /** Products discounted by the voucher. */
  products: InputMaybe<Array<Scalars['ID']>>;
  /**
   * When set to 'True', each voucher code can be used only once; otherwise, codes can be used multiple times depending on `usageLimit`.
   *
   * The option can only be changed if none of the voucher codes have been used.
   *
   * Added in Saleor 3.18.
   *
   * Note: this API is currently in Feature Preview and can be subject to changes at later point.
   */
  singleUse: InputMaybe<Scalars['Boolean']>;
  /** Start date of the voucher in ISO 8601 format. */
  startDate: InputMaybe<Scalars['DateTime']>;
  /** Voucher type: PRODUCT, CATEGORY SHIPPING or ENTIRE_ORDER. */
  type: InputMaybe<VoucherTypeEnum>;
  /** Limit number of times this voucher can be used in total. */
  usageLimit: InputMaybe<Scalars['Int']>;
  /** Variants discounted by the voucher. */
  variants: InputMaybe<Array<Scalars['ID']>>;
};

/** Event sent when voucher metadata is updated. */
export type VoucherMetadataUpdated = Event & {
  __typename: 'VoucherMetadataUpdated';
  /** Time of the event. */
  issuedAt: Maybe<Scalars['DateTime']>;
  /** The user or application that triggered the event. */
  issuingPrincipal: Maybe<IssuingPrincipal>;
  /** The application receiving the webhook. */
  recipient: Maybe<App>;
  /** Saleor version that triggered the event. */
  version: Maybe<Scalars['String']>;
  /** The voucher the event relates to. */
  voucher: Maybe<Voucher>;
};


/** Event sent when voucher metadata is updated. */
export type VoucherMetadataUpdatedVoucherArgs = {
  channel: InputMaybe<Scalars['String']>;
};

/**
 * Removes products, categories, collections from a voucher.
 *
 * Requires one of the following permissions: MANAGE_DISCOUNTS.
 *
 * Triggers the following webhook events:
 * - VOUCHER_UPDATED (async): A voucher was updated.
 */
export type VoucherRemoveCatalogues = {
  __typename: 'VoucherRemoveCatalogues';
  /** @deprecated Use `errors` field instead. */
  discountErrors: Array<DiscountError>;
  errors: Array<DiscountError>;
  /** Voucher of which catalogue IDs will be modified. */
  voucher: Maybe<Voucher>;
};

export type VoucherSortField =
  /** Sort vouchers by code. */
  | 'CODE'
  /** Sort vouchers by end date. */
  | 'END_DATE'
  /**
   * Sort vouchers by minimum spent amount.
   *
   * This option requires a channel filter to work as the values can vary between channels.
   */
  | 'MINIMUM_SPENT_AMOUNT'
  /**
   * Sort vouchers by name.
   *
   * Added in Saleor 3.18.
   */
  | 'NAME'
  /** Sort vouchers by start date. */
  | 'START_DATE'
  /** Sort vouchers by type. */
  | 'TYPE'
  /** Sort vouchers by usage limit. */
  | 'USAGE_LIMIT'
  /**
   * Sort vouchers by value.
   *
   * This option requires a channel filter to work as the values can vary between channels.
   */
  | 'VALUE';

export type VoucherSortingInput = {
  /**
   * Specifies the channel in which to sort the data.
   * @deprecated Use root-level channel argument instead.
   */
  channel: InputMaybe<Scalars['String']>;
  /** Specifies the direction in which to sort vouchers. */
  direction: OrderDirection;
  /** Sort vouchers by the selected field. */
  field: VoucherSortField;
};

/** Represents voucher's original translatable fields and related translations. */
export type VoucherTranslatableContent = Node & {
  __typename: 'VoucherTranslatableContent';
  /** The ID of the voucher translatable content. */
  id: Scalars['ID'];
  /** Voucher name to translate. */
  name: Maybe<Scalars['String']>;
  /** Returns translated voucher fields for the given language code. */
  translation: Maybe<VoucherTranslation>;
  /**
   * Vouchers allow giving discounts to particular customers on categories, collections or specific products. They can be used during checkout by providing valid voucher codes.
   *
   * Requires one of the following permissions: MANAGE_DISCOUNTS.
   * @deprecated Get model fields from the root level queries.
   */
  voucher: Maybe<Voucher>;
  /** The ID of the voucher to translate. */
  voucherId: Scalars['ID'];
};


/** Represents voucher's original translatable fields and related translations. */
export type VoucherTranslatableContentTranslationArgs = {
  languageCode: LanguageCodeEnum;
};

/**
 * Creates/updates translations for a voucher.
 *
 * Requires one of the following permissions: MANAGE_TRANSLATIONS.
 */
export type VoucherTranslate = {
  __typename: 'VoucherTranslate';
  errors: Array<TranslationError>;
  /** @deprecated Use `errors` field instead. */
  translationErrors: Array<TranslationError>;
  voucher: Maybe<Voucher>;
};

/** Represents voucher translations. */
export type VoucherTranslation = Node & {
  __typename: 'VoucherTranslation';
  /** The ID of the voucher translation. */
  id: Scalars['ID'];
  /** Translation language. */
  language: LanguageDisplay;
  /** Translated voucher name. */
  name: Maybe<Scalars['String']>;
  /** Represents the voucher fields to translate. */
  translatableContent: Maybe<VoucherTranslatableContent>;
};

export type VoucherTypeEnum =
  | 'ENTIRE_ORDER'
  | 'SHIPPING'
  | 'SPECIFIC_PRODUCT';

/**
 * Updates a voucher.
 *
 * Requires one of the following permissions: MANAGE_DISCOUNTS.
 *
 * Triggers the following webhook events:
 * - VOUCHER_UPDATED (async): A voucher was updated.
 * - VOUCHER_CODES_CREATED (async): A voucher code was created.
 */
export type VoucherUpdate = {
  __typename: 'VoucherUpdate';
  /** @deprecated Use `errors` field instead. */
  discountErrors: Array<DiscountError>;
  errors: Array<DiscountError>;
  voucher: Maybe<Voucher>;
};

/** Event sent when voucher is updated. */
export type VoucherUpdated = Event & {
  __typename: 'VoucherUpdated';
  /** Time of the event. */
  issuedAt: Maybe<Scalars['DateTime']>;
  /** The user or application that triggered the event. */
  issuingPrincipal: Maybe<IssuingPrincipal>;
  /** The application receiving the webhook. */
  recipient: Maybe<App>;
  /** Saleor version that triggered the event. */
  version: Maybe<Scalars['String']>;
  /** The voucher the event relates to. */
  voucher: Maybe<Voucher>;
};


/** Event sent when voucher is updated. */
export type VoucherUpdatedVoucherArgs = {
  channel: InputMaybe<Scalars['String']>;
};

/** Represents warehouse. */
export type Warehouse = Node & ObjectWithMetadata & {
  __typename: 'Warehouse';
  /** Address of the warehouse. */
  address: Address;
  /** Click and collect options: local, all or disabled. */
  clickAndCollectOption: WarehouseClickAndCollectOptionEnum;
  /**
   * Warehouse company name.
   * @deprecated Use `Address.companyName` instead.
   */
  companyName: Scalars['String'];
  /** Warehouse email. */
  email: Scalars['String'];
  /** External ID of this warehouse. */
  externalReference: Maybe<Scalars['String']>;
  /** The ID of the warehouse. */
  id: Scalars['ID'];
  /** Determine if the warehouse is private. */
  isPrivate: Scalars['Boolean'];
  /** List of public metadata items. Can be accessed without permissions. */
  metadata: Array<MetadataItem>;
  /**
   * A single key from public metadata.
   *
   * Tip: Use GraphQL aliases to fetch multiple keys.
   */
  metafield: Maybe<Scalars['String']>;
  /** Public metadata. Use `keys` to control which fields you want to include. The default is to include everything. */
  metafields: Maybe<Scalars['Metadata']>;
  /** Warehouse name. */
  name: Scalars['String'];
  /** List of private metadata items. Requires staff permissions to access. */
  privateMetadata: Array<MetadataItem>;
  /**
   * A single key from private metadata. Requires staff permissions to access.
   *
   * Tip: Use GraphQL aliases to fetch multiple keys.
   */
  privateMetafield: Maybe<Scalars['String']>;
  /** Private metadata. Requires staff permissions to access. Use `keys` to control which fields you want to include. The default is to include everything. */
  privateMetafields: Maybe<Scalars['Metadata']>;
  /** Shipping zones supported by the warehouse. */
  shippingZones: ShippingZoneCountableConnection;
  /** Warehouse slug. */
  slug: Scalars['String'];
  /**
   * Stocks that belong to this warehouse.
   *
   * Added in Saleor 3.20.
   *
   * Requires one of the following permissions: MANAGE_PRODUCTS, MANAGE_ORDERS.
   */
  stocks: Maybe<StockCountableConnection>;
};


/** Represents warehouse. */
export type WarehouseMetafieldArgs = {
  key: Scalars['String'];
};


/** Represents warehouse. */
export type WarehouseMetafieldsArgs = {
  keys: InputMaybe<Array<Scalars['String']>>;
};


/** Represents warehouse. */
export type WarehousePrivateMetafieldArgs = {
  key: Scalars['String'];
};


/** Represents warehouse. */
export type WarehousePrivateMetafieldsArgs = {
  keys: InputMaybe<Array<Scalars['String']>>;
};


/** Represents warehouse. */
export type WarehouseShippingZonesArgs = {
  after: InputMaybe<Scalars['String']>;
  before: InputMaybe<Scalars['String']>;
  first: InputMaybe<Scalars['Int']>;
  last: InputMaybe<Scalars['Int']>;
};


/** Represents warehouse. */
export type WarehouseStocksArgs = {
  after: InputMaybe<Scalars['String']>;
  before: InputMaybe<Scalars['String']>;
  first: InputMaybe<Scalars['Int']>;
  last: InputMaybe<Scalars['Int']>;
};

export type WarehouseClickAndCollectOptionEnum =
  | 'ALL'
  | 'DISABLED'
  | 'LOCAL';

export type WarehouseCountableConnection = {
  __typename: 'WarehouseCountableConnection';
  edges: Array<WarehouseCountableEdge>;
  /** Pagination data for this connection. */
  pageInfo: PageInfo;
  /** A total count of items in the collection. */
  totalCount: Maybe<Scalars['Int']>;
};

export type WarehouseCountableEdge = {
  __typename: 'WarehouseCountableEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node: Warehouse;
};

/**
 * Creates a new warehouse.
 *
 * Requires one of the following permissions: MANAGE_PRODUCTS.
 */
export type WarehouseCreate = {
  __typename: 'WarehouseCreate';
  errors: Array<WarehouseError>;
  warehouse: Maybe<Warehouse>;
  /** @deprecated Use `errors` field instead. */
  warehouseErrors: Array<WarehouseError>;
};

export type WarehouseCreateInput = {
  /** Address of the warehouse. */
  address: AddressInput;
  /** The email address of the warehouse. */
  email: InputMaybe<Scalars['String']>;
  /** External ID of the warehouse. */
  externalReference: InputMaybe<Scalars['String']>;
  /** Warehouse name. */
  name: Scalars['String'];
  /**
   * Shipping zones supported by the warehouse.
   * @deprecated Providing the zone ids will raise a ValidationError.
   */
  shippingZones: InputMaybe<Array<Scalars['ID']>>;
  /** Warehouse slug. */
  slug: InputMaybe<Scalars['String']>;
};

/** Event sent when new warehouse is created. */
export type WarehouseCreated = Event & {
  __typename: 'WarehouseCreated';
  /** Time of the event. */
  issuedAt: Maybe<Scalars['DateTime']>;
  /** The user or application that triggered the event. */
  issuingPrincipal: Maybe<IssuingPrincipal>;
  /** The application receiving the webhook. */
  recipient: Maybe<App>;
  /** Saleor version that triggered the event. */
  version: Maybe<Scalars['String']>;
  /** The warehouse the event relates to. */
  warehouse: Maybe<Warehouse>;
};

/**
 * Deletes selected warehouse.
 *
 * Requires one of the following permissions: MANAGE_PRODUCTS.
 */
export type WarehouseDelete = {
  __typename: 'WarehouseDelete';
  errors: Array<WarehouseError>;
  warehouse: Maybe<Warehouse>;
  /** @deprecated Use `errors` field instead. */
  warehouseErrors: Array<WarehouseError>;
};

/** Event sent when warehouse is deleted. */
export type WarehouseDeleted = Event & {
  __typename: 'WarehouseDeleted';
  /** Time of the event. */
  issuedAt: Maybe<Scalars['DateTime']>;
  /** The user or application that triggered the event. */
  issuingPrincipal: Maybe<IssuingPrincipal>;
  /** The application receiving the webhook. */
  recipient: Maybe<App>;
  /** Saleor version that triggered the event. */
  version: Maybe<Scalars['String']>;
  /** The warehouse the event relates to. */
  warehouse: Maybe<Warehouse>;
};

export type WarehouseError = {
  __typename: 'WarehouseError';
  /** The error code. */
  code: WarehouseErrorCode;
  /** Name of a field that caused the error. A value of `null` indicates that the error isn't associated with a particular field. */
  field: Maybe<Scalars['String']>;
  /** The error message. */
  message: Maybe<Scalars['String']>;
  /** List of shipping zones IDs which causes the error. */
  shippingZones: Maybe<Array<Scalars['ID']>>;
};

export type WarehouseErrorCode =
  | 'ALREADY_EXISTS'
  | 'GRAPHQL_ERROR'
  | 'INVALID'
  | 'NOT_FOUND'
  | 'REQUIRED'
  | 'UNIQUE';

export type WarehouseFilterInput = {
  channels: InputMaybe<Array<Scalars['ID']>>;
  clickAndCollectOption: InputMaybe<WarehouseClickAndCollectOptionEnum>;
  ids: InputMaybe<Array<Scalars['ID']>>;
  isPrivate: InputMaybe<Scalars['Boolean']>;
  metadata: InputMaybe<Array<MetadataFilter>>;
  search: InputMaybe<Scalars['String']>;
  slugs: InputMaybe<Array<Scalars['String']>>;
};

/** Event sent when warehouse metadata is updated. */
export type WarehouseMetadataUpdated = Event & {
  __typename: 'WarehouseMetadataUpdated';
  /** Time of the event. */
  issuedAt: Maybe<Scalars['DateTime']>;
  /** The user or application that triggered the event. */
  issuingPrincipal: Maybe<IssuingPrincipal>;
  /** The application receiving the webhook. */
  recipient: Maybe<App>;
  /** Saleor version that triggered the event. */
  version: Maybe<Scalars['String']>;
  /** The warehouse the event relates to. */
  warehouse: Maybe<Warehouse>;
};

/**
 * Add shipping zone to given warehouse.
 *
 * Requires one of the following permissions: MANAGE_PRODUCTS.
 */
export type WarehouseShippingZoneAssign = {
  __typename: 'WarehouseShippingZoneAssign';
  errors: Array<WarehouseError>;
  warehouse: Maybe<Warehouse>;
  /** @deprecated Use `errors` field instead. */
  warehouseErrors: Array<WarehouseError>;
};

/**
 * Remove shipping zone from given warehouse.
 *
 * Requires one of the following permissions: MANAGE_PRODUCTS.
 */
export type WarehouseShippingZoneUnassign = {
  __typename: 'WarehouseShippingZoneUnassign';
  errors: Array<WarehouseError>;
  warehouse: Maybe<Warehouse>;
  /** @deprecated Use `errors` field instead. */
  warehouseErrors: Array<WarehouseError>;
};

export type WarehouseSortField =
  /** Sort warehouses by name. */
  | 'NAME';

export type WarehouseSortingInput = {
  /** Specifies the direction in which to sort warehouses. */
  direction: OrderDirection;
  /** Sort warehouses by the selected field. */
  field: WarehouseSortField;
};

/**
 * Updates given warehouse.
 *
 * Requires one of the following permissions: MANAGE_PRODUCTS.
 */
export type WarehouseUpdate = {
  __typename: 'WarehouseUpdate';
  errors: Array<WarehouseError>;
  warehouse: Maybe<Warehouse>;
  /** @deprecated Use `errors` field instead. */
  warehouseErrors: Array<WarehouseError>;
};

export type WarehouseUpdateInput = {
  /** Address of the warehouse. */
  address: InputMaybe<AddressInput>;
  /** Click and collect options: local, all or disabled. */
  clickAndCollectOption: InputMaybe<WarehouseClickAndCollectOptionEnum>;
  /** The email address of the warehouse. */
  email: InputMaybe<Scalars['String']>;
  /** External ID of the warehouse. */
  externalReference: InputMaybe<Scalars['String']>;
  /** Visibility of warehouse stocks. */
  isPrivate: InputMaybe<Scalars['Boolean']>;
  /** Warehouse name. */
  name: InputMaybe<Scalars['String']>;
  /** Warehouse slug. */
  slug: InputMaybe<Scalars['String']>;
};

/** Event sent when warehouse is updated. */
export type WarehouseUpdated = Event & {
  __typename: 'WarehouseUpdated';
  /** Time of the event. */
  issuedAt: Maybe<Scalars['DateTime']>;
  /** The user or application that triggered the event. */
  issuingPrincipal: Maybe<IssuingPrincipal>;
  /** The application receiving the webhook. */
  recipient: Maybe<App>;
  /** Saleor version that triggered the event. */
  version: Maybe<Scalars['String']>;
  /** The warehouse the event relates to. */
  warehouse: Maybe<Warehouse>;
};

/** Webhook. */
export type Webhook = Node & {
  __typename: 'Webhook';
  /** The app associated with Webhook. */
  app: App;
  /** List of asynchronous webhook events. */
  asyncEvents: Array<WebhookEventAsync>;
  /** Custom headers, which will be added to HTTP request. */
  customHeaders: Maybe<Scalars['JSONString']>;
  /** Event deliveries. */
  eventDeliveries: Maybe<EventDeliveryCountableConnection>;
  /**
   * List of webhook events.
   * @deprecated Use `asyncEvents` or `syncEvents` instead.
   */
  events: Array<WebhookEvent>;
  /** The ID of webhook. */
  id: Scalars['ID'];
  /** Informs if webhook is activated. */
  isActive: Scalars['Boolean'];
  /** The name of webhook. */
  name: Maybe<Scalars['String']>;
  /**
   * Used to create a hash signature for each payload.
   * @deprecated As of Saleor 3.5, webhook payloads default to signing using a verifiable JWS.
   */
  secretKey: Maybe<Scalars['String']>;
  /** Used to define payloads for specific events. */
  subscriptionQuery: Maybe<Scalars['String']>;
  /** List of synchronous webhook events. */
  syncEvents: Array<WebhookEventSync>;
  /** Target URL for webhook. */
  targetUrl: Scalars['String'];
};


/** Webhook. */
export type WebhookEventDeliveriesArgs = {
  after: InputMaybe<Scalars['String']>;
  before: InputMaybe<Scalars['String']>;
  filter: InputMaybe<EventDeliveryFilterInput>;
  first: InputMaybe<Scalars['Int']>;
  last: InputMaybe<Scalars['Int']>;
  sortBy: InputMaybe<EventDeliverySortingInput>;
};

/**
 * Creates a new webhook subscription.
 *
 * Requires one of the following permissions: MANAGE_APPS, AUTHENTICATED_APP.
 */
export type WebhookCreate = {
  __typename: 'WebhookCreate';
  errors: Array<WebhookError>;
  webhook: Maybe<Webhook>;
  /** @deprecated Use `errors` field instead. */
  webhookErrors: Array<WebhookError>;
};

export type WebhookCreateInput = {
  /** ID of the app to which webhook belongs. */
  app: InputMaybe<Scalars['ID']>;
  /** The asynchronous events that webhook wants to subscribe. */
  asyncEvents: InputMaybe<Array<WebhookEventTypeAsyncEnum>>;
  /** Custom headers, which will be added to HTTP request. There is a limitation of 5 headers per webhook and 998 characters per header.Only `X-*`, `Authorization*`, and `BrokerProperties` keys are allowed. */
  customHeaders: InputMaybe<Scalars['JSONString']>;
  /**
   * The events that webhook wants to subscribe.
   * @deprecated Use `asyncEvents` or `syncEvents` instead.
   */
  events: InputMaybe<Array<WebhookEventTypeEnum>>;
  /** Determine if webhook will be set active or not. */
  isActive: InputMaybe<Scalars['Boolean']>;
  /** The name of the webhook. */
  name: InputMaybe<Scalars['String']>;
  /** Subscription query used to define a webhook payload. */
  query: InputMaybe<Scalars['String']>;
  /**
   * The secret key used to create a hash signature with each payload.
   * @deprecated As of Saleor 3.5, webhook payloads default to signing using a verifiable JWS.
   */
  secretKey: InputMaybe<Scalars['String']>;
  /** The synchronous events that webhook wants to subscribe. */
  syncEvents: InputMaybe<Array<WebhookEventTypeSyncEnum>>;
  /** The url to receive the payload. */
  targetUrl: InputMaybe<Scalars['String']>;
};

/**
 * Deletes a webhook. Before the deletion, the webhook is deactivated to pause any deliveries that are already scheduled. The deletion might fail if delivery is in progress. In such a case, the webhook is not deleted but remains deactivated.
 *
 * Requires one of the following permissions: MANAGE_APPS, AUTHENTICATED_APP.
 */
export type WebhookDelete = {
  __typename: 'WebhookDelete';
  errors: Array<WebhookError>;
  webhook: Maybe<Webhook>;
  /** @deprecated Use `errors` field instead. */
  webhookErrors: Array<WebhookError>;
};

/**
 * Performs a dry run of a webhook event. Supports a single event (the first, if multiple provided in the `query`). Requires permission relevant to processed event.
 *
 * Requires one of the following permissions: AUTHENTICATED_STAFF_USER.
 */
export type WebhookDryRun = {
  __typename: 'WebhookDryRun';
  errors: Array<WebhookDryRunError>;
  /** JSON payload, that would be sent out to webhook's target URL. */
  payload: Maybe<Scalars['JSONString']>;
};

export type WebhookDryRunError = {
  __typename: 'WebhookDryRunError';
  /** The error code. */
  code: WebhookDryRunErrorCode;
  /** Name of a field that caused the error. A value of `null` indicates that the error isn't associated with a particular field. */
  field: Maybe<Scalars['String']>;
  /** The error message. */
  message: Maybe<Scalars['String']>;
};

export type WebhookDryRunErrorCode =
  | 'GRAPHQL_ERROR'
  | 'INVALID_ID'
  | 'MISSING_EVENT'
  | 'MISSING_PERMISSION'
  | 'MISSING_SUBSCRIPTION'
  | 'NOT_FOUND'
  | 'SYNTAX'
  | 'TYPE_NOT_SUPPORTED'
  | 'UNABLE_TO_PARSE';

export type WebhookError = {
  __typename: 'WebhookError';
  /** The error code. */
  code: WebhookErrorCode;
  /** Name of a field that caused the error. A value of `null` indicates that the error isn't associated with a particular field. */
  field: Maybe<Scalars['String']>;
  /** The error message. */
  message: Maybe<Scalars['String']>;
};

export type WebhookErrorCode =
  | 'DELETE_FAILED'
  | 'GRAPHQL_ERROR'
  | 'INVALID'
  | 'INVALID_CUSTOM_HEADERS'
  | 'INVALID_NOTIFY_WITH_SUBSCRIPTION'
  | 'MISSING_EVENT'
  | 'MISSING_SUBSCRIPTION'
  | 'NOT_FOUND'
  | 'REQUIRED'
  | 'SYNTAX'
  | 'UNABLE_TO_PARSE'
  | 'UNIQUE';

/** Webhook event. */
export type WebhookEvent = {
  __typename: 'WebhookEvent';
  /** Internal name of the event type. */
  eventType: WebhookEventTypeEnum;
  /** Display name of the event. */
  name: Scalars['String'];
};

/** Asynchronous webhook event. */
export type WebhookEventAsync = {
  __typename: 'WebhookEventAsync';
  /** Internal name of the event type. */
  eventType: WebhookEventTypeAsyncEnum;
  /** Display name of the event. */
  name: Scalars['String'];
};

/** Synchronous webhook event. */
export type WebhookEventSync = {
  __typename: 'WebhookEventSync';
  /** Internal name of the event type. */
  eventType: WebhookEventTypeSyncEnum;
  /** Display name of the event. */
  name: Scalars['String'];
};

/** Enum determining type of webhook. */
export type WebhookEventTypeAsyncEnum =
  /** An account email change is requested. */
  | 'ACCOUNT_CHANGE_EMAIL_REQUESTED'
  /** An account confirmation is requested. */
  | 'ACCOUNT_CONFIRMATION_REQUESTED'
  /** An account is confirmed. */
  | 'ACCOUNT_CONFIRMED'
  /** An account is deleted. */
  | 'ACCOUNT_DELETED'
  /** An account delete is requested. */
  | 'ACCOUNT_DELETE_REQUESTED'
  /** An account email was changed */
  | 'ACCOUNT_EMAIL_CHANGED'
  /** Setting a new password for the account is requested. */
  | 'ACCOUNT_SET_PASSWORD_REQUESTED'
  /** A new address created. */
  | 'ADDRESS_CREATED'
  /** An address deleted. */
  | 'ADDRESS_DELETED'
  /** An address updated. */
  | 'ADDRESS_UPDATED'
  /** All the events. */
  | 'ANY_EVENTS'
  /** An app deleted. */
  | 'APP_DELETED'
  /** A new app installed. */
  | 'APP_INSTALLED'
  /** An app status is changed. */
  | 'APP_STATUS_CHANGED'
  /** An app updated. */
  | 'APP_UPDATED'
  /** A new attribute is created. */
  | 'ATTRIBUTE_CREATED'
  /** An attribute is deleted. */
  | 'ATTRIBUTE_DELETED'
  /** An attribute is updated. */
  | 'ATTRIBUTE_UPDATED'
  /** A new attribute value is created. */
  | 'ATTRIBUTE_VALUE_CREATED'
  /** An attribute value is deleted. */
  | 'ATTRIBUTE_VALUE_DELETED'
  /** An attribute value is updated. */
  | 'ATTRIBUTE_VALUE_UPDATED'
  /** A new category created. */
  | 'CATEGORY_CREATED'
  /** A category is deleted. */
  | 'CATEGORY_DELETED'
  /** A category is updated. */
  | 'CATEGORY_UPDATED'
  /** A new channel created. */
  | 'CHANNEL_CREATED'
  /** A channel is deleted. */
  | 'CHANNEL_DELETED'
  /** A channel metadata is updated. */
  | 'CHANNEL_METADATA_UPDATED'
  /** A channel status is changed. */
  | 'CHANNEL_STATUS_CHANGED'
  /** A channel is updated. */
  | 'CHANNEL_UPDATED'
  /** A new checkout is created. */
  | 'CHECKOUT_CREATED'
  /**
   * A checkout was fully authorized (its `authorizeStatus` is `FULL`).
   *
   * This event is emitted only for checkouts whose payments are processed through the Transaction API.
   */
  | 'CHECKOUT_FULLY_AUTHORIZED'
  /**
   * A checkout was fully paid (its `chargeStatus` is `FULL` or `OVERCHARGED`). This event is not sent if payments are only authorized but not fully charged.
   *
   * This event is emitted only for checkouts whose payments are processed through the Transaction API.
   */
  | 'CHECKOUT_FULLY_PAID'
  /** A checkout metadata is updated. */
  | 'CHECKOUT_METADATA_UPDATED'
  /** A checkout is updated. It also triggers all updates related to the checkout. */
  | 'CHECKOUT_UPDATED'
  /** A new collection is created. */
  | 'COLLECTION_CREATED'
  /** A collection is deleted. */
  | 'COLLECTION_DELETED'
  /** A collection metadata is updated. */
  | 'COLLECTION_METADATA_UPDATED'
  /** A collection is updated. */
  | 'COLLECTION_UPDATED'
  /** A new customer account is created. */
  | 'CUSTOMER_CREATED'
  /** A customer account is deleted. */
  | 'CUSTOMER_DELETED'
  /** A customer account metadata is updated. */
  | 'CUSTOMER_METADATA_UPDATED'
  /** A customer account is updated. */
  | 'CUSTOMER_UPDATED'
  /** A draft order is created. */
  | 'DRAFT_ORDER_CREATED'
  /** A draft order is deleted. */
  | 'DRAFT_ORDER_DELETED'
  /** A draft order is updated. */
  | 'DRAFT_ORDER_UPDATED'
  /** A fulfillment is approved. */
  | 'FULFILLMENT_APPROVED'
  /** A fulfillment is cancelled. */
  | 'FULFILLMENT_CANCELED'
  /** A new fulfillment is created. */
  | 'FULFILLMENT_CREATED'
  /** A fulfillment metadata is updated. */
  | 'FULFILLMENT_METADATA_UPDATED'
  | 'FULFILLMENT_TRACKING_NUMBER_UPDATED'
  /** A new gift card created. */
  | 'GIFT_CARD_CREATED'
  /** A gift card is deleted. */
  | 'GIFT_CARD_DELETED'
  /** A gift card export is completed. */
  | 'GIFT_CARD_EXPORT_COMPLETED'
  /** A gift card metadata is updated. */
  | 'GIFT_CARD_METADATA_UPDATED'
  /** A gift card has been sent. */
  | 'GIFT_CARD_SENT'
  /** A gift card status is changed. */
  | 'GIFT_CARD_STATUS_CHANGED'
  /** A gift card is updated. */
  | 'GIFT_CARD_UPDATED'
  /** An invoice is deleted. */
  | 'INVOICE_DELETED'
  /** An invoice for order requested. */
  | 'INVOICE_REQUESTED'
  /** Invoice has been sent. */
  | 'INVOICE_SENT'
  /** A new menu created. */
  | 'MENU_CREATED'
  /** A menu is deleted. */
  | 'MENU_DELETED'
  /** A new menu item created. */
  | 'MENU_ITEM_CREATED'
  /** A menu item is deleted. */
  | 'MENU_ITEM_DELETED'
  /** A menu item is updated. */
  | 'MENU_ITEM_UPDATED'
  /** A menu is updated. */
  | 'MENU_UPDATED'
  /** User notification triggered. */
  | 'NOTIFY_USER'
  /** An observability event is created. */
  | 'OBSERVABILITY'
  /** Orders are imported. */
  | 'ORDER_BULK_CREATED'
  /** An order is cancelled. */
  | 'ORDER_CANCELLED'
  /** An order is confirmed (status change unconfirmed -> unfulfilled) by a staff user using the OrderConfirm mutation. It also triggers when the user completes the checkout and the shop setting `automatically_confirm_all_new_orders` is enabled. */
  | 'ORDER_CONFIRMED'
  /** A new order is placed. */
  | 'ORDER_CREATED'
  /** An order is expired. */
  | 'ORDER_EXPIRED'
  /** An order is fulfilled. */
  | 'ORDER_FULFILLED'
  /** Payment is made and an order is fully paid. */
  | 'ORDER_FULLY_PAID'
  /** The order is fully refunded. */
  | 'ORDER_FULLY_REFUNDED'
  /** An order metadata is updated. */
  | 'ORDER_METADATA_UPDATED'
  /** Payment has been made. The order may be partially or fully paid. */
  | 'ORDER_PAID'
  /** The order received a refund. The order may be partially or fully refunded. */
  | 'ORDER_REFUNDED'
  /** An order is updated; triggered for all changes related to an order; covers all other order webhooks, except for ORDER_CREATED. */
  | 'ORDER_UPDATED'
  /** A new page is created. */
  | 'PAGE_CREATED'
  /** A page is deleted. */
  | 'PAGE_DELETED'
  /** A new page type is created. */
  | 'PAGE_TYPE_CREATED'
  /** A page type is deleted. */
  | 'PAGE_TYPE_DELETED'
  /** A page type is updated. */
  | 'PAGE_TYPE_UPDATED'
  /** A page is updated. */
  | 'PAGE_UPDATED'
  /** A new permission group is created. */
  | 'PERMISSION_GROUP_CREATED'
  /** A permission group is deleted. */
  | 'PERMISSION_GROUP_DELETED'
  /** A permission group is updated. */
  | 'PERMISSION_GROUP_UPDATED'
  /** A new product is created. */
  | 'PRODUCT_CREATED'
  /** A product is deleted. */
  | 'PRODUCT_DELETED'
  /** A product export is completed. */
  | 'PRODUCT_EXPORT_COMPLETED'
  /** A new product media is created. */
  | 'PRODUCT_MEDIA_CREATED'
  /** A product media is deleted. */
  | 'PRODUCT_MEDIA_DELETED'
  /** A product media is updated. */
  | 'PRODUCT_MEDIA_UPDATED'
  /** A product metadata is updated. */
  | 'PRODUCT_METADATA_UPDATED'
  /** A product is updated. */
  | 'PRODUCT_UPDATED'
  /** A product variant is back in stock. */
  | 'PRODUCT_VARIANT_BACK_IN_STOCK'
  /** A new product variant is created. */
  | 'PRODUCT_VARIANT_CREATED'
  /** A product variant is deleted. Warning: this event will not be executed when parent product has been deleted. Check PRODUCT_DELETED. */
  | 'PRODUCT_VARIANT_DELETED'
  /** A product variant metadata is updated. */
  | 'PRODUCT_VARIANT_METADATA_UPDATED'
  /** A product variant is out of stock. */
  | 'PRODUCT_VARIANT_OUT_OF_STOCK'
  /** A product variant stock is updated */
  | 'PRODUCT_VARIANT_STOCK_UPDATED'
  /** A product variant is updated. */
  | 'PRODUCT_VARIANT_UPDATED'
  /** A promotion is created. */
  | 'PROMOTION_CREATED'
  /** A promotion is deleted. */
  | 'PROMOTION_DELETED'
  /** A promotion is deactivated. */
  | 'PROMOTION_ENDED'
  /** A promotion rule is created. */
  | 'PROMOTION_RULE_CREATED'
  /** A promotion rule is deleted. */
  | 'PROMOTION_RULE_DELETED'
  /** A promotion rule is updated. */
  | 'PROMOTION_RULE_UPDATED'
  /** A promotion is activated. */
  | 'PROMOTION_STARTED'
  /** A promotion is updated. */
  | 'PROMOTION_UPDATED'
  /** A sale is created. */
  | 'SALE_CREATED'
  /** A sale is deleted. */
  | 'SALE_DELETED'
  /** A sale is activated or deactivated. */
  | 'SALE_TOGGLE'
  /** A sale is updated. */
  | 'SALE_UPDATED'
  /** A new shipping price is created. */
  | 'SHIPPING_PRICE_CREATED'
  /** A shipping price is deleted. */
  | 'SHIPPING_PRICE_DELETED'
  /** A shipping price is updated. */
  | 'SHIPPING_PRICE_UPDATED'
  /** A new shipping zone is created. */
  | 'SHIPPING_ZONE_CREATED'
  /** A shipping zone is deleted. */
  | 'SHIPPING_ZONE_DELETED'
  /** A shipping zone metadata is updated. */
  | 'SHIPPING_ZONE_METADATA_UPDATED'
  /** A shipping zone is updated. */
  | 'SHIPPING_ZONE_UPDATED'
  /** Shop metadata is updated. */
  | 'SHOP_METADATA_UPDATED'
  /** A new staff user is created. */
  | 'STAFF_CREATED'
  /** A staff user is deleted. */
  | 'STAFF_DELETED'
  /** Setting a new password for the staff account is requested. */
  | 'STAFF_SET_PASSWORD_REQUESTED'
  /** A staff user is updated. */
  | 'STAFF_UPDATED'
  /** A thumbnail is created. */
  | 'THUMBNAIL_CREATED'
  /** Transaction item metadata is updated. */
  | 'TRANSACTION_ITEM_METADATA_UPDATED'
  /** A new translation is created. */
  | 'TRANSLATION_CREATED'
  /** A translation is updated. */
  | 'TRANSLATION_UPDATED'
  | 'VOUCHER_CODES_CREATED'
  | 'VOUCHER_CODES_DELETED'
  /**
   * A voucher code export is completed.
   *
   * Added in Saleor 3.18.
   */
  | 'VOUCHER_CODE_EXPORT_COMPLETED'
  /** A new voucher created. */
  | 'VOUCHER_CREATED'
  /** A voucher is deleted. */
  | 'VOUCHER_DELETED'
  /** A voucher metadata is updated. */
  | 'VOUCHER_METADATA_UPDATED'
  /** A voucher is updated. */
  | 'VOUCHER_UPDATED'
  /** A new warehouse created. */
  | 'WAREHOUSE_CREATED'
  /** A warehouse is deleted. */
  | 'WAREHOUSE_DELETED'
  /** A warehouse metadata is updated. */
  | 'WAREHOUSE_METADATA_UPDATED'
  /** A warehouse is updated. */
  | 'WAREHOUSE_UPDATED';

/** Enum determining type of webhook. */
export type WebhookEventTypeEnum =
  /** An account email change is requested. */
  | 'ACCOUNT_CHANGE_EMAIL_REQUESTED'
  /** An account confirmation is requested. */
  | 'ACCOUNT_CONFIRMATION_REQUESTED'
  /** An account is confirmed. */
  | 'ACCOUNT_CONFIRMED'
  /** An account is deleted. */
  | 'ACCOUNT_DELETED'
  /** An account delete is requested. */
  | 'ACCOUNT_DELETE_REQUESTED'
  /** An account email was changed */
  | 'ACCOUNT_EMAIL_CHANGED'
  /** Setting a new password for the account is requested. */
  | 'ACCOUNT_SET_PASSWORD_REQUESTED'
  /** A new address created. */
  | 'ADDRESS_CREATED'
  /** An address deleted. */
  | 'ADDRESS_DELETED'
  /** An address updated. */
  | 'ADDRESS_UPDATED'
  /** All the events. */
  | 'ANY_EVENTS'
  /** An app deleted. */
  | 'APP_DELETED'
  /** A new app installed. */
  | 'APP_INSTALLED'
  /** An app status is changed. */
  | 'APP_STATUS_CHANGED'
  /** An app updated. */
  | 'APP_UPDATED'
  /** A new attribute is created. */
  | 'ATTRIBUTE_CREATED'
  /** An attribute is deleted. */
  | 'ATTRIBUTE_DELETED'
  /** An attribute is updated. */
  | 'ATTRIBUTE_UPDATED'
  /** A new attribute value is created. */
  | 'ATTRIBUTE_VALUE_CREATED'
  /** An attribute value is deleted. */
  | 'ATTRIBUTE_VALUE_DELETED'
  /** An attribute value is updated. */
  | 'ATTRIBUTE_VALUE_UPDATED'
  /** A new category created. */
  | 'CATEGORY_CREATED'
  /** A category is deleted. */
  | 'CATEGORY_DELETED'
  /** A category is updated. */
  | 'CATEGORY_UPDATED'
  /** A new channel created. */
  | 'CHANNEL_CREATED'
  /** A channel is deleted. */
  | 'CHANNEL_DELETED'
  /** A channel metadata is updated. */
  | 'CHANNEL_METADATA_UPDATED'
  /** A channel status is changed. */
  | 'CHANNEL_STATUS_CHANGED'
  /** A channel is updated. */
  | 'CHANNEL_UPDATED'
  /** Event called for checkout tax calculation. */
  | 'CHECKOUT_CALCULATE_TAXES'
  /** A new checkout is created. */
  | 'CHECKOUT_CREATED'
  /** Filter shipping methods for checkout. */
  | 'CHECKOUT_FILTER_SHIPPING_METHODS'
  /**
   * A checkout was fully authorized (its `authorizeStatus` is `FULL`).
   *
   * This event is emitted only for checkouts whose payments are processed through the Transaction API.
   */
  | 'CHECKOUT_FULLY_AUTHORIZED'
  /**
   * A checkout was fully paid (its `chargeStatus` is `FULL` or `OVERCHARGED`). This event is not sent if payments are only authorized but not fully charged.
   *
   * This event is emitted only for checkouts whose payments are processed through the Transaction API.
   */
  | 'CHECKOUT_FULLY_PAID'
  /** A checkout metadata is updated. */
  | 'CHECKOUT_METADATA_UPDATED'
  /** A checkout is updated. It also triggers all updates related to the checkout. */
  | 'CHECKOUT_UPDATED'
  /** A new collection is created. */
  | 'COLLECTION_CREATED'
  /** A collection is deleted. */
  | 'COLLECTION_DELETED'
  /** A collection metadata is updated. */
  | 'COLLECTION_METADATA_UPDATED'
  /** A collection is updated. */
  | 'COLLECTION_UPDATED'
  /** A new customer account is created. */
  | 'CUSTOMER_CREATED'
  /** A customer account is deleted. */
  | 'CUSTOMER_DELETED'
  /** A customer account metadata is updated. */
  | 'CUSTOMER_METADATA_UPDATED'
  /** A customer account is updated. */
  | 'CUSTOMER_UPDATED'
  /** A draft order is created. */
  | 'DRAFT_ORDER_CREATED'
  /** A draft order is deleted. */
  | 'DRAFT_ORDER_DELETED'
  /** A draft order is updated. */
  | 'DRAFT_ORDER_UPDATED'
  /** A fulfillment is approved. */
  | 'FULFILLMENT_APPROVED'
  /** A fulfillment is cancelled. */
  | 'FULFILLMENT_CANCELED'
  /** A new fulfillment is created. */
  | 'FULFILLMENT_CREATED'
  /** A fulfillment metadata is updated. */
  | 'FULFILLMENT_METADATA_UPDATED'
  | 'FULFILLMENT_TRACKING_NUMBER_UPDATED'
  /** A new gift card created. */
  | 'GIFT_CARD_CREATED'
  /** A gift card is deleted. */
  | 'GIFT_CARD_DELETED'
  /** A gift card export is completed. */
  | 'GIFT_CARD_EXPORT_COMPLETED'
  /** A gift card metadata is updated. */
  | 'GIFT_CARD_METADATA_UPDATED'
  /** A gift card has been sent. */
  | 'GIFT_CARD_SENT'
  /** A gift card status is changed. */
  | 'GIFT_CARD_STATUS_CHANGED'
  /** A gift card is updated. */
  | 'GIFT_CARD_UPDATED'
  /** An invoice is deleted. */
  | 'INVOICE_DELETED'
  /** An invoice for order requested. */
  | 'INVOICE_REQUESTED'
  /** Invoice has been sent. */
  | 'INVOICE_SENT'
  | 'LIST_STORED_PAYMENT_METHODS'
  /** A new menu created. */
  | 'MENU_CREATED'
  /** A menu is deleted. */
  | 'MENU_DELETED'
  /** A new menu item created. */
  | 'MENU_ITEM_CREATED'
  /** A menu item is deleted. */
  | 'MENU_ITEM_DELETED'
  /** A menu item is updated. */
  | 'MENU_ITEM_UPDATED'
  /** A menu is updated. */
  | 'MENU_UPDATED'
  /** User notification triggered. */
  | 'NOTIFY_USER'
  /** An observability event is created. */
  | 'OBSERVABILITY'
  /** Orders are imported. */
  | 'ORDER_BULK_CREATED'
  /** Event called for order tax calculation. */
  | 'ORDER_CALCULATE_TAXES'
  /** An order is cancelled. */
  | 'ORDER_CANCELLED'
  /** An order is confirmed (status change unconfirmed -> unfulfilled) by a staff user using the OrderConfirm mutation. It also triggers when the user completes the checkout and the shop setting `automatically_confirm_all_new_orders` is enabled. */
  | 'ORDER_CONFIRMED'
  /** A new order is placed. */
  | 'ORDER_CREATED'
  /** An order is expired. */
  | 'ORDER_EXPIRED'
  /** Filter shipping methods for order. */
  | 'ORDER_FILTER_SHIPPING_METHODS'
  /** An order is fulfilled. */
  | 'ORDER_FULFILLED'
  /** Payment is made and an order is fully paid. */
  | 'ORDER_FULLY_PAID'
  /** The order is fully refunded. */
  | 'ORDER_FULLY_REFUNDED'
  /** An order metadata is updated. */
  | 'ORDER_METADATA_UPDATED'
  /** Payment has been made. The order may be partially or fully paid. */
  | 'ORDER_PAID'
  /** The order received a refund. The order may be partially or fully refunded. */
  | 'ORDER_REFUNDED'
  /** An order is updated; triggered for all changes related to an order; covers all other order webhooks, except for ORDER_CREATED. */
  | 'ORDER_UPDATED'
  /** A new page is created. */
  | 'PAGE_CREATED'
  /** A page is deleted. */
  | 'PAGE_DELETED'
  /** A new page type is created. */
  | 'PAGE_TYPE_CREATED'
  /** A page type is deleted. */
  | 'PAGE_TYPE_DELETED'
  /** A page type is updated. */
  | 'PAGE_TYPE_UPDATED'
  /** A page is updated. */
  | 'PAGE_UPDATED'
  /** Authorize payment. */
  | 'PAYMENT_AUTHORIZE'
  /** Capture payment. */
  | 'PAYMENT_CAPTURE'
  /** Confirm payment. */
  | 'PAYMENT_CONFIRM'
  | 'PAYMENT_GATEWAY_INITIALIZE_SESSION'
  | 'PAYMENT_GATEWAY_INITIALIZE_TOKENIZATION_SESSION'
  /** Listing available payment gateways. */
  | 'PAYMENT_LIST_GATEWAYS'
  | 'PAYMENT_METHOD_INITIALIZE_TOKENIZATION_SESSION'
  | 'PAYMENT_METHOD_PROCESS_TOKENIZATION_SESSION'
  /** Process payment. */
  | 'PAYMENT_PROCESS'
  /** Refund payment. */
  | 'PAYMENT_REFUND'
  /** Void payment. */
  | 'PAYMENT_VOID'
  /** A new permission group is created. */
  | 'PERMISSION_GROUP_CREATED'
  /** A permission group is deleted. */
  | 'PERMISSION_GROUP_DELETED'
  /** A permission group is updated. */
  | 'PERMISSION_GROUP_UPDATED'
  /** A new product is created. */
  | 'PRODUCT_CREATED'
  /** A product is deleted. */
  | 'PRODUCT_DELETED'
  /** A product export is completed. */
  | 'PRODUCT_EXPORT_COMPLETED'
  /** A new product media is created. */
  | 'PRODUCT_MEDIA_CREATED'
  /** A product media is deleted. */
  | 'PRODUCT_MEDIA_DELETED'
  /** A product media is updated. */
  | 'PRODUCT_MEDIA_UPDATED'
  /** A product metadata is updated. */
  | 'PRODUCT_METADATA_UPDATED'
  /** A product is updated. */
  | 'PRODUCT_UPDATED'
  /** A product variant is back in stock. */
  | 'PRODUCT_VARIANT_BACK_IN_STOCK'
  /** A new product variant is created. */
  | 'PRODUCT_VARIANT_CREATED'
  /** A product variant is deleted. Warning: this event will not be executed when parent product has been deleted. Check PRODUCT_DELETED. */
  | 'PRODUCT_VARIANT_DELETED'
  /** A product variant metadata is updated. */
  | 'PRODUCT_VARIANT_METADATA_UPDATED'
  /** A product variant is out of stock. */
  | 'PRODUCT_VARIANT_OUT_OF_STOCK'
  /** A product variant stock is updated */
  | 'PRODUCT_VARIANT_STOCK_UPDATED'
  /** A product variant is updated. */
  | 'PRODUCT_VARIANT_UPDATED'
  /** A promotion is created. */
  | 'PROMOTION_CREATED'
  /** A promotion is deleted. */
  | 'PROMOTION_DELETED'
  /** A promotion is deactivated. */
  | 'PROMOTION_ENDED'
  /** A promotion rule is created. */
  | 'PROMOTION_RULE_CREATED'
  /** A promotion rule is deleted. */
  | 'PROMOTION_RULE_DELETED'
  /** A promotion rule is updated. */
  | 'PROMOTION_RULE_UPDATED'
  /** A promotion is activated. */
  | 'PROMOTION_STARTED'
  /** A promotion is updated. */
  | 'PROMOTION_UPDATED'
  /** A sale is created. */
  | 'SALE_CREATED'
  /** A sale is deleted. */
  | 'SALE_DELETED'
  /** A sale is activated or deactivated. */
  | 'SALE_TOGGLE'
  /** A sale is updated. */
  | 'SALE_UPDATED'
  /** Fetch external shipping methods for checkout. */
  | 'SHIPPING_LIST_METHODS_FOR_CHECKOUT'
  /** A new shipping price is created. */
  | 'SHIPPING_PRICE_CREATED'
  /** A shipping price is deleted. */
  | 'SHIPPING_PRICE_DELETED'
  /** A shipping price is updated. */
  | 'SHIPPING_PRICE_UPDATED'
  /** A new shipping zone is created. */
  | 'SHIPPING_ZONE_CREATED'
  /** A shipping zone is deleted. */
  | 'SHIPPING_ZONE_DELETED'
  /** A shipping zone metadata is updated. */
  | 'SHIPPING_ZONE_METADATA_UPDATED'
  /** A shipping zone is updated. */
  | 'SHIPPING_ZONE_UPDATED'
  /** Shop metadata is updated. */
  | 'SHOP_METADATA_UPDATED'
  /** A new staff user is created. */
  | 'STAFF_CREATED'
  /** A staff user is deleted. */
  | 'STAFF_DELETED'
  /** Setting a new password for the staff account is requested. */
  | 'STAFF_SET_PASSWORD_REQUESTED'
  /** A staff user is updated. */
  | 'STAFF_UPDATED'
  | 'STORED_PAYMENT_METHOD_DELETE_REQUESTED'
  /** A thumbnail is created. */
  | 'THUMBNAIL_CREATED'
  /** Event called when cancel has been requested for transaction. */
  | 'TRANSACTION_CANCELATION_REQUESTED'
  /** Event called when charge has been requested for transaction. */
  | 'TRANSACTION_CHARGE_REQUESTED'
  | 'TRANSACTION_INITIALIZE_SESSION'
  /** Transaction item metadata is updated. */
  | 'TRANSACTION_ITEM_METADATA_UPDATED'
  | 'TRANSACTION_PROCESS_SESSION'
  /** Event called when refund has been requested for transaction. */
  | 'TRANSACTION_REFUND_REQUESTED'
  /** A new translation is created. */
  | 'TRANSLATION_CREATED'
  /** A translation is updated. */
  | 'TRANSLATION_UPDATED'
  | 'VOUCHER_CODES_CREATED'
  | 'VOUCHER_CODES_DELETED'
  /**
   * A voucher code export is completed.
   *
   * Added in Saleor 3.18.
   */
  | 'VOUCHER_CODE_EXPORT_COMPLETED'
  /** A new voucher created. */
  | 'VOUCHER_CREATED'
  /** A voucher is deleted. */
  | 'VOUCHER_DELETED'
  /** A voucher metadata is updated. */
  | 'VOUCHER_METADATA_UPDATED'
  /** A voucher is updated. */
  | 'VOUCHER_UPDATED'
  /** A new warehouse created. */
  | 'WAREHOUSE_CREATED'
  /** A warehouse is deleted. */
  | 'WAREHOUSE_DELETED'
  /** A warehouse metadata is updated. */
  | 'WAREHOUSE_METADATA_UPDATED'
  /** A warehouse is updated. */
  | 'WAREHOUSE_UPDATED';

/** Enum determining type of webhook. */
export type WebhookEventTypeSyncEnum =
  /** Event called for checkout tax calculation. */
  | 'CHECKOUT_CALCULATE_TAXES'
  /** Filter shipping methods for checkout. */
  | 'CHECKOUT_FILTER_SHIPPING_METHODS'
  | 'LIST_STORED_PAYMENT_METHODS'
  /** Event called for order tax calculation. */
  | 'ORDER_CALCULATE_TAXES'
  /** Filter shipping methods for order. */
  | 'ORDER_FILTER_SHIPPING_METHODS'
  /** Authorize payment. */
  | 'PAYMENT_AUTHORIZE'
  /** Capture payment. */
  | 'PAYMENT_CAPTURE'
  /** Confirm payment. */
  | 'PAYMENT_CONFIRM'
  | 'PAYMENT_GATEWAY_INITIALIZE_SESSION'
  | 'PAYMENT_GATEWAY_INITIALIZE_TOKENIZATION_SESSION'
  /** Listing available payment gateways. */
  | 'PAYMENT_LIST_GATEWAYS'
  | 'PAYMENT_METHOD_INITIALIZE_TOKENIZATION_SESSION'
  | 'PAYMENT_METHOD_PROCESS_TOKENIZATION_SESSION'
  /** Process payment. */
  | 'PAYMENT_PROCESS'
  /** Refund payment. */
  | 'PAYMENT_REFUND'
  /** Void payment. */
  | 'PAYMENT_VOID'
  /** Fetch external shipping methods for checkout. */
  | 'SHIPPING_LIST_METHODS_FOR_CHECKOUT'
  | 'STORED_PAYMENT_METHOD_DELETE_REQUESTED'
  /** Event called when cancel has been requested for transaction. */
  | 'TRANSACTION_CANCELATION_REQUESTED'
  /** Event called when charge has been requested for transaction. */
  | 'TRANSACTION_CHARGE_REQUESTED'
  | 'TRANSACTION_INITIALIZE_SESSION'
  | 'TRANSACTION_PROCESS_SESSION'
  /** Event called when refund has been requested for transaction. */
  | 'TRANSACTION_REFUND_REQUESTED';

export type WebhookSampleEventTypeEnum =
  | 'ACCOUNT_CHANGE_EMAIL_REQUESTED'
  | 'ACCOUNT_CONFIRMATION_REQUESTED'
  | 'ACCOUNT_CONFIRMED'
  | 'ACCOUNT_DELETED'
  | 'ACCOUNT_DELETE_REQUESTED'
  | 'ACCOUNT_EMAIL_CHANGED'
  | 'ACCOUNT_SET_PASSWORD_REQUESTED'
  | 'ADDRESS_CREATED'
  | 'ADDRESS_DELETED'
  | 'ADDRESS_UPDATED'
  | 'APP_DELETED'
  | 'APP_INSTALLED'
  | 'APP_STATUS_CHANGED'
  | 'APP_UPDATED'
  | 'ATTRIBUTE_CREATED'
  | 'ATTRIBUTE_DELETED'
  | 'ATTRIBUTE_UPDATED'
  | 'ATTRIBUTE_VALUE_CREATED'
  | 'ATTRIBUTE_VALUE_DELETED'
  | 'ATTRIBUTE_VALUE_UPDATED'
  | 'CATEGORY_CREATED'
  | 'CATEGORY_DELETED'
  | 'CATEGORY_UPDATED'
  | 'CHANNEL_CREATED'
  | 'CHANNEL_DELETED'
  | 'CHANNEL_METADATA_UPDATED'
  | 'CHANNEL_STATUS_CHANGED'
  | 'CHANNEL_UPDATED'
  | 'CHECKOUT_CREATED'
  | 'CHECKOUT_FULLY_AUTHORIZED'
  | 'CHECKOUT_FULLY_PAID'
  | 'CHECKOUT_METADATA_UPDATED'
  | 'CHECKOUT_UPDATED'
  | 'COLLECTION_CREATED'
  | 'COLLECTION_DELETED'
  | 'COLLECTION_METADATA_UPDATED'
  | 'COLLECTION_UPDATED'
  | 'CUSTOMER_CREATED'
  | 'CUSTOMER_DELETED'
  | 'CUSTOMER_METADATA_UPDATED'
  | 'CUSTOMER_UPDATED'
  | 'DRAFT_ORDER_CREATED'
  | 'DRAFT_ORDER_DELETED'
  | 'DRAFT_ORDER_UPDATED'
  | 'FULFILLMENT_APPROVED'
  | 'FULFILLMENT_CANCELED'
  | 'FULFILLMENT_CREATED'
  | 'FULFILLMENT_METADATA_UPDATED'
  | 'FULFILLMENT_TRACKING_NUMBER_UPDATED'
  | 'GIFT_CARD_CREATED'
  | 'GIFT_CARD_DELETED'
  | 'GIFT_CARD_EXPORT_COMPLETED'
  | 'GIFT_CARD_METADATA_UPDATED'
  | 'GIFT_CARD_SENT'
  | 'GIFT_CARD_STATUS_CHANGED'
  | 'GIFT_CARD_UPDATED'
  | 'INVOICE_DELETED'
  | 'INVOICE_REQUESTED'
  | 'INVOICE_SENT'
  | 'MENU_CREATED'
  | 'MENU_DELETED'
  | 'MENU_ITEM_CREATED'
  | 'MENU_ITEM_DELETED'
  | 'MENU_ITEM_UPDATED'
  | 'MENU_UPDATED'
  | 'NOTIFY_USER'
  | 'OBSERVABILITY'
  | 'ORDER_BULK_CREATED'
  | 'ORDER_CANCELLED'
  | 'ORDER_CONFIRMED'
  | 'ORDER_CREATED'
  | 'ORDER_EXPIRED'
  | 'ORDER_FULFILLED'
  | 'ORDER_FULLY_PAID'
  | 'ORDER_FULLY_REFUNDED'
  | 'ORDER_METADATA_UPDATED'
  | 'ORDER_PAID'
  | 'ORDER_REFUNDED'
  | 'ORDER_UPDATED'
  | 'PAGE_CREATED'
  | 'PAGE_DELETED'
  | 'PAGE_TYPE_CREATED'
  | 'PAGE_TYPE_DELETED'
  | 'PAGE_TYPE_UPDATED'
  | 'PAGE_UPDATED'
  | 'PERMISSION_GROUP_CREATED'
  | 'PERMISSION_GROUP_DELETED'
  | 'PERMISSION_GROUP_UPDATED'
  | 'PRODUCT_CREATED'
  | 'PRODUCT_DELETED'
  | 'PRODUCT_EXPORT_COMPLETED'
  | 'PRODUCT_MEDIA_CREATED'
  | 'PRODUCT_MEDIA_DELETED'
  | 'PRODUCT_MEDIA_UPDATED'
  | 'PRODUCT_METADATA_UPDATED'
  | 'PRODUCT_UPDATED'
  | 'PRODUCT_VARIANT_BACK_IN_STOCK'
  | 'PRODUCT_VARIANT_CREATED'
  | 'PRODUCT_VARIANT_DELETED'
  | 'PRODUCT_VARIANT_METADATA_UPDATED'
  | 'PRODUCT_VARIANT_OUT_OF_STOCK'
  | 'PRODUCT_VARIANT_STOCK_UPDATED'
  | 'PRODUCT_VARIANT_UPDATED'
  | 'PROMOTION_CREATED'
  | 'PROMOTION_DELETED'
  | 'PROMOTION_ENDED'
  | 'PROMOTION_RULE_CREATED'
  | 'PROMOTION_RULE_DELETED'
  | 'PROMOTION_RULE_UPDATED'
  | 'PROMOTION_STARTED'
  | 'PROMOTION_UPDATED'
  | 'SALE_CREATED'
  | 'SALE_DELETED'
  | 'SALE_TOGGLE'
  | 'SALE_UPDATED'
  | 'SHIPPING_PRICE_CREATED'
  | 'SHIPPING_PRICE_DELETED'
  | 'SHIPPING_PRICE_UPDATED'
  | 'SHIPPING_ZONE_CREATED'
  | 'SHIPPING_ZONE_DELETED'
  | 'SHIPPING_ZONE_METADATA_UPDATED'
  | 'SHIPPING_ZONE_UPDATED'
  | 'SHOP_METADATA_UPDATED'
  | 'STAFF_CREATED'
  | 'STAFF_DELETED'
  | 'STAFF_SET_PASSWORD_REQUESTED'
  | 'STAFF_UPDATED'
  | 'THUMBNAIL_CREATED'
  | 'TRANSACTION_ITEM_METADATA_UPDATED'
  | 'TRANSLATION_CREATED'
  | 'TRANSLATION_UPDATED'
  | 'VOUCHER_CODES_CREATED'
  | 'VOUCHER_CODES_DELETED'
  | 'VOUCHER_CODE_EXPORT_COMPLETED'
  | 'VOUCHER_CREATED'
  | 'VOUCHER_DELETED'
  | 'VOUCHER_METADATA_UPDATED'
  | 'VOUCHER_UPDATED'
  | 'WAREHOUSE_CREATED'
  | 'WAREHOUSE_DELETED'
  | 'WAREHOUSE_METADATA_UPDATED'
  | 'WAREHOUSE_UPDATED';

/**
 * Trigger a webhook event. Supports a single event (the first, if multiple provided in the `webhook.subscription_query`). Requires permission relevant to processed event. Successfully delivered webhook returns `delivery` with status='PENDING' and empty payload.
 *
 * Requires one of the following permissions: AUTHENTICATED_STAFF_USER.
 */
export type WebhookTrigger = {
  __typename: 'WebhookTrigger';
  delivery: Maybe<EventDelivery>;
  errors: Array<WebhookTriggerError>;
};

export type WebhookTriggerError = {
  __typename: 'WebhookTriggerError';
  /** The error code. */
  code: WebhookTriggerErrorCode;
  /** Name of a field that caused the error. A value of `null` indicates that the error isn't associated with a particular field. */
  field: Maybe<Scalars['String']>;
  /** The error message. */
  message: Maybe<Scalars['String']>;
};

export type WebhookTriggerErrorCode =
  | 'GRAPHQL_ERROR'
  | 'INVALID_ID'
  | 'MISSING_EVENT'
  | 'MISSING_PERMISSION'
  | 'MISSING_QUERY'
  | 'MISSING_SUBSCRIPTION'
  | 'NOT_FOUND'
  | 'SYNTAX'
  | 'TYPE_NOT_SUPPORTED'
  | 'UNABLE_TO_PARSE';

/**
 * Updates a webhook subscription.
 *
 * Requires one of the following permissions: MANAGE_APPS, AUTHENTICATED_APP.
 */
export type WebhookUpdate = {
  __typename: 'WebhookUpdate';
  errors: Array<WebhookError>;
  webhook: Maybe<Webhook>;
  /** @deprecated Use `errors` field instead. */
  webhookErrors: Array<WebhookError>;
};

export type WebhookUpdateInput = {
  /** ID of the app to which webhook belongs. */
  app: InputMaybe<Scalars['ID']>;
  /** The asynchronous events that webhook wants to subscribe. */
  asyncEvents: InputMaybe<Array<WebhookEventTypeAsyncEnum>>;
  /** Custom headers, which will be added to HTTP request. There is a limitation of 5 headers per webhook and 998 characters per header.Only `X-*`, `Authorization*`, and `BrokerProperties` keys are allowed. */
  customHeaders: InputMaybe<Scalars['JSONString']>;
  /**
   * The events that webhook wants to subscribe.
   * @deprecated Use `asyncEvents` or `syncEvents` instead.
   */
  events: InputMaybe<Array<WebhookEventTypeEnum>>;
  /** Determine if webhook will be set active or not. */
  isActive: InputMaybe<Scalars['Boolean']>;
  /** The new name of the webhook. */
  name: InputMaybe<Scalars['String']>;
  /** Subscription query used to define a webhook payload. */
  query: InputMaybe<Scalars['String']>;
  /**
   * Use to create a hash signature with each payload.
   * @deprecated As of Saleor 3.5, webhook payloads default to signing using a verifiable JWS.
   */
  secretKey: InputMaybe<Scalars['String']>;
  /** The synchronous events that webhook wants to subscribe. */
  syncEvents: InputMaybe<Array<WebhookEventTypeSyncEnum>>;
  /** The url to receive the payload. */
  targetUrl: InputMaybe<Scalars['String']>;
};

/** Represents weight value in a specific weight unit. */
export type Weight = {
  __typename: 'Weight';
  /** Weight unit. */
  unit: WeightUnitsEnum;
  /** Weight value. Returns a value with maximal three decimal places */
  value: Scalars['Float'];
};

export type WeightUnitsEnum =
  | 'G'
  | 'KG'
  | 'LB'
  | 'OZ'
  | 'TONNE';

/** Represents the WIDGET target options for an app extension. */
export type WidgetTargetOptions = {
  __typename: 'WidgetTargetOptions';
  /**
   * HTTP method for Widget target (GET or POST)
   * @deprecated Use `settings` field directly.
   */
  method: HttpMethod;
};

/** _Entity union as defined by Federation spec. */
export type _Entity = Address | App | Category | Collection | Group | Order | PageType | Product | ProductMedia | ProductType | ProductVariant | User;

/** _Service manifest as defined by Federation spec. */
export type _Service = {
  __typename: '_Service';
  sdl: Maybe<Scalars['String']>;
};
